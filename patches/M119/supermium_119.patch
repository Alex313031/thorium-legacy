diff --git a/0) b/0)
new file mode 100644
index 0000000000000..e69de29bb2d1d
diff --git a/LICENSE.chromium_os b/LICENSE.chromium_os
deleted file mode 100644
index 2e71f04e137a9..0000000000000
--- a/LICENSE.chromium_os
+++ /dev/null
@@ -1,27 +0,0 @@
-// Copyright 2006-2009 The ChromiumOS Authors
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions are
-// met:
-//
-//    * Redistributions of source code must retain the above copyright
-// notice, this list of conditions and the following disclaimer.
-//    * Redistributions in binary form must reproduce the above
-// copyright notice, this list of conditions and the following disclaimer
-// in the documentation and/or other materials provided with the
-// distribution.
-//    * Neither the name of Google LLC nor the names of its
-// contributors may be used to endorse or promote products derived from
-// this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/README.md b/README.md
index 08f1a0445babd..610c30a916a3c 100644
--- a/README.md
+++ b/README.md
@@ -1,21 +1,2 @@
-# ![Logo](chrome/app/theme/chromium/product_logo_64.png) Chromium
-
-Chromium is an open-source browser project that aims to build a safer, faster,
-and more stable way for all users to experience the web.
-
-The project's web site is https://www.chromium.org.
-
-To check out the source code locally, don't use `git clone`! Instead,
-follow [the instructions on how to get the code](docs/get_the_code.md).
-
-Documentation in the source is rooted in [docs/README.md](docs/README.md).
-
-Learn how to [Get Around the Chromium Source Code Directory Structure
-](https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code).
-
-For historical reasons, there are some small top level directories. Now the
-guidance is that new top level directories are for product (e.g. Chrome,
-Android WebView, Ash). Even if these products have multiple executables, the
-code should be in subdirectories of the product.
-
-If you found a bug, please file it at https://crbug.com/new.
+# supermium
+A Chromium-based browser for Windows Vista (exkernel), 7 and 8.x.
diff --git a/base/BUILD.gn b/base/BUILD.gn
index 55479f4187323..1c23a35cbce6b 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -134,11 +134,6 @@ if (is_win) {
     ldflags = [
       # Linking with shcore.lib causes the shcore api forwarder dll to load.
       "/DELAYLOAD:api-ms-win-shcore-scaling-l1-1-1.dll",
-
-      # Linking with OneCore.lib causes the next three dlls to load.
-      "/DELAYLOAD:api-ms-win-core-realtime-l1-1-1.dll",
-      "/DELAYLOAD:api-ms-win-power-base-l1-1-0.dll",
-      "/DELAYLOAD:api-ms-win-power-setting-l1-1-0.dll",
       "/DELAYLOAD:cfgmgr32.dll",
       "/DELAYLOAD:powrprof.dll",
       "/DELAYLOAD:setupapi.dll",
@@ -1912,7 +1907,6 @@ component("base") {
     libs += [
       "cfgmgr32.lib",
       "ntdll.lib",
-      "onecore.lib",
       "powrprof.lib",
       "propsys.lib",
       "setupapi.lib",
diff --git a/base/allocator/partition_allocator/page_allocator_internals_win.h b/base/allocator/partition_allocator/page_allocator_internals_win.h
index 1ac45fbe20bd8..57f6d86a34330 100644
--- a/base/allocator/partition_allocator/page_allocator_internals_win.h
+++ b/base/allocator/partition_allocator/page_allocator_internals_win.h
@@ -5,6 +5,8 @@
 #ifndef BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_INTERNALS_WIN_H_
 #define BASE_ALLOCATOR_PARTITION_ALLOCATOR_PAGE_ALLOCATOR_INTERNALS_WIN_H_
 
+#include <versionhelpers.h>
+
 #include <cstdint>
 
 #include "base/allocator/partition_allocator/oom.h"
@@ -16,6 +18,17 @@
 
 namespace partition_alloc::internal {
 
+namespace {
+
+// On Windows, discarded pages are not returned to the system immediately and
+// not guaranteed to be zeroed when returned to the application.
+using DiscardVirtualMemoryFunction = DWORD(WINAPI*)(PVOID virtualAddress,
+                                                    SIZE_T size);
+DiscardVirtualMemoryFunction s_discard_virtual_memory =
+    reinterpret_cast<DiscardVirtualMemoryFunction>(-1);
+
+}  // namespace
+
 // |VirtualAlloc| will fail if allocation at the hint address is blocked.
 constexpr bool kHintIsAdvisory = false;
 std::atomic<int32_t> s_allocPageErrorCode{ERROR_SUCCESS};
@@ -224,12 +237,27 @@ bool TryRecommitSystemPagesInternal(
 }
 
 void DiscardSystemPagesInternal(uintptr_t address, size_t length) {
+  if (s_discard_virtual_memory ==
+      reinterpret_cast<DiscardVirtualMemoryFunction>(-1)) {
+    // DiscardVirtualMemory's minimum supported client is Windows 8.1 Update.
+    // So skip GetProcAddress("DiscardVirtualMemory") if windows version is
+    // smaller than Windows 8.1.
+    if (IsWindows8Point1OrGreater()) {
+      s_discard_virtual_memory =
+          reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+              GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+    } else {
+      s_discard_virtual_memory = nullptr;
+    }
+  }
+
   void* ptr = reinterpret_cast<void*>(address);
   // Use DiscardVirtualMemory when available because it releases faster than
   // MEM_RESET.
-  DWORD ret = DiscardVirtualMemory(ptr, length);
-  // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
-  // failure.
+  DWORD ret = 1;
+  if (s_discard_virtual_memory) {
+    ret = s_discard_virtual_memory(ptr, length);
+  }
   if (ret) {
     PA_CHECK(VirtualAllocWithRetry(ptr, length, MEM_RESET, PAGE_READWRITE));
   }
diff --git a/base/allocator/partition_allocator/partition_address_space.cc b/base/allocator/partition_allocator/partition_address_space.cc
index fe5ebd51f3af1..398e6a66b6797 100644
--- a/base/allocator/partition_allocator/partition_address_space.cc
+++ b/base/allocator/partition_allocator/partition_address_space.cc
@@ -43,6 +43,34 @@ namespace {
 
 #if BUILDFLAG(IS_WIN)
 
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+bool IsLegacyWindowsVersion() {
+  // Use ::RtlGetVersion instead of ::GetVersionEx or helpers from
+  // VersionHelpers.h because those alternatives change their behavior depending
+  // on whether or not the calling executable has a compatibility manifest
+  // resource. It's better for the allocator to not depend on that to decide the
+  // pool size.
+  // Assume legacy if ::RtlGetVersion is not available or it fails.
+  using RtlGetVersion = LONG(WINAPI*)(OSVERSIONINFOEX*);
+  const RtlGetVersion rtl_get_version = reinterpret_cast<RtlGetVersion>(
+      ::GetProcAddress(::GetModuleHandle(L"ntdll.dll"), "RtlGetVersion"));
+  if (!rtl_get_version) {
+    return true;
+  }
+
+  OSVERSIONINFOEX version_info = {};
+  version_info.dwOSVersionInfoSize = sizeof(version_info);
+  if (rtl_get_version(&version_info) != ERROR_SUCCESS) {
+    return true;
+  }
+
+  // Anything prior to Windows 8.1 is considered legacy for the allocator.
+  // Windows 8.1 is major 6 with minor 3.
+  return version_info.dwMajorVersion < 6 ||
+         (version_info.dwMajorVersion == 6 && version_info.dwMinorVersion < 3);
+}
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+
 PA_NOINLINE void HandlePoolAllocFailureOutOfVASpace() {
   PA_NO_CODE_FOLDING();
   PA_CHECK(false);
@@ -66,9 +94,9 @@ PA_NOINLINE void HandlePoolAllocFailure() {
     // it must be VA space exhaustion.
     HandlePoolAllocFailureOutOfVASpace();
   } else if (alloc_page_error_code == ERROR_COMMITMENT_LIMIT) {
-    // Should not happen, since as of Windows 8.1+, reserving address space
-    // should not be charged against the commit limit, aside from a very small
-    // amount per 64kiB block. Keep this path anyway, to check in crash reports.
+    // On Windows <8.1, MEM_RESERVE increases commit charge to account for
+    // not-yet-committed PTEs needed to cover that VA space, if it was to be
+    // committed (see crbug.com/1101421#c16).
     HandlePoolAllocFailureOutOfCommitCharge();
   } else
 #endif  // BUILDFLAG(IS_WIN)
@@ -87,10 +115,7 @@ std::ptrdiff_t PartitionAddressSpace::brp_pool_shadow_offset_ = 0;
 #endif
 
 #if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
-#if !BUILDFLAG(IS_IOS)
-#error Dynamic pool size is only supported on iOS.
-#endif
-
+#if BUILDFLAG(IS_IOS)
 namespace {
 bool IsIOSTestProcess() {
   // On iOS, only applications with the extended virtual addressing entitlement
@@ -132,6 +157,15 @@ PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
 PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
   return IsIOSTestProcess() ? kBRPPoolSizeForIOSTestProcess : kBRPPoolSize;
 }
+#else
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::RegularPoolSize() {
+  return IsLegacyWindowsVersion() ? kRegularPoolSizeForLegacyWindows
+                                  : kRegularPoolSize;
+}
+PA_ALWAYS_INLINE size_t PartitionAddressSpace::BRPPoolSize() {
+  return IsLegacyWindowsVersion() ? kBRPPoolSizeForLegacyWindows : kBRPPoolSize;
+}
+#endif  // BUILDFLAG(IS_IOS)
 #endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
 
 void PartitionAddressSpace::Init() {
diff --git a/base/allocator/partition_allocator/partition_address_space.h b/base/allocator/partition_allocator/partition_address_space.h
index 260842f02b7d3..352e314df0e32 100644
--- a/base/allocator/partition_allocator/partition_address_space.h
+++ b/base/allocator/partition_allocator/partition_address_space.h
@@ -276,6 +276,16 @@ class PA_COMPONENT_EXPORT(PARTITION_ALLOC) PartitionAddressSpace {
   static constexpr size_t kThreadIsolatedPoolSize = kGiB / 4;
   static_assert(base::bits::IsPowerOfTwo(kThreadIsolatedPoolSize));
 #endif
+#if PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
+  // We can't afford pool sizes as large as kPoolMaxSize on Windows <8.1 (see
+  // crbug.com/1101421 and crbug.com/1217759).
+  static constexpr size_t kRegularPoolSizeForLegacyWindows = 1 * kGiB;
+  static constexpr size_t kBRPPoolSizeForLegacyWindows = 1 * kGiB;
+  static_assert(kRegularPoolSizeForLegacyWindows < kRegularPoolSize);
+  static_assert(kBRPPoolSizeForLegacyWindows < kBRPPoolSize);
+  static_assert(base::bits::IsPowerOfTwo(kRegularPoolSizeForLegacyWindows));
+  static_assert(base::bits::IsPowerOfTwo(kBRPPoolSizeForLegacyWindows));
+#endif  // PA_CONFIG(DYNAMICALLY_SELECT_POOL_SIZE)
   static constexpr size_t kConfigurablePoolMaxSize = kPoolMaxSize;
   static constexpr size_t kConfigurablePoolMinSize = 1 * kGiB;
   static_assert(kConfigurablePoolMinSize <= kConfigurablePoolMaxSize);
diff --git a/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc b/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
index c6071fa8b092f..cac35bc52ad53 100644
--- a/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
+++ b/base/allocator/partition_allocator/partition_alloc_base/rand_util_win.cc
@@ -8,36 +8,32 @@
 #include <stdint.h>
 #include <windows.h>
 
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
+
 #include <algorithm>
 #include <limits>
 
 #include "base/allocator/partition_allocator/partition_alloc_base/check.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace partition_alloc::internal::base {
 
 void RandBytes(void* output, size_t output_length) {
-  // Import bcryptprimitives directly rather than cryptbase to avoid opening a
-  // handle to \\Device\KsecDD in the renderer.
-  // Note: we cannot use a magic static here as PA runs too early in process
-  // startup, but this should be safe as the process will be single-threaded
-  // when this first runs.
-  static decltype(&ProcessPrng) process_prng_fn = nullptr;
-  if (!process_prng_fn) {
-    HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-    PA_BASE_CHECK(hmod);
-    process_prng_fn = reinterpret_cast<decltype(&ProcessPrng)>(
-        GetProcAddress(hmod, "ProcessPrng"));
-    PA_BASE_CHECK(process_prng_fn);
+  char* output_ptr = static_cast<char*>(output);
+  while (output_length > 0) {
+    const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_length, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+    const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    PA_BASE_CHECK(success);
+    output_length -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
   }
-  BOOL success = process_prng_fn(static_cast<BYTE*>(output), output_length);
-  // ProcessPrng is documented to always return TRUE.
-  PA_BASE_CHECK(success);
+ 
 }
 
 }  // namespace partition_alloc::internal::base
diff --git a/base/allocator/partition_allocator/partition_alloc_config.h b/base/allocator/partition_allocator/partition_alloc_config.h
index bb6195f590759..224a3507195c7 100644
--- a/base/allocator/partition_allocator/partition_alloc_config.h
+++ b/base/allocator/partition_allocator/partition_alloc_config.h
@@ -32,7 +32,7 @@
 static_assert(sizeof(void*) == 8, "");
 #else
 static_assert(sizeof(void*) != 8, "");
-#endif  // PA_CONFIG(HAS_64_BITS_POINTERS)
+#endif  // BUILDFLAG(HAS_64_BITS_POINTERS)
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (defined(__ARM_NEON) || defined(__ARM_NEON__)) && defined(__ARM_FP)
@@ -41,18 +41,23 @@ static_assert(sizeof(void*) != 8, "");
 #define PA_CONFIG_STARSCAN_NEON_SUPPORTED() 0
 #endif
 
-#if BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#if BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) || BUILDFLAG(IS_WIN))
 // Allow PA to select an alternate pool size at run-time before initialization,
 // rather than using a single constexpr value.
 //
 // This is needed on iOS because iOS test processes can't handle large pools
 // (see crbug.com/1250788).
 //
+// This is needed on Windows, because OS versions <8.1 incur commit charge even
+// on reserved address space, thus don't handle large pools well (see
+// crbug.com/1101421 and crbug.com/1217759).
+//
 // This setting is specific to 64-bit, as 32-bit has a different implementation.
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 1
 #else
 #define PA_CONFIG_DYNAMICALLY_SELECT_POOL_SIZE() 0
-#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && BUILDFLAG(IS_IOS)
+#endif  // BUILDFLAG(HAS_64_BIT_POINTERS) && (BUILDFLAG(IS_IOS) ||
+        // BUILDFLAG(IS_WIN))
 
 #if BUILDFLAG(HAS_64_BIT_POINTERS) && \
     (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_ANDROID))
diff --git a/base/command_line.cc b/base/command_line.cc
index d762b168a9ccf..5bbdb4e86d69a 100644
--- a/base/command_line.cc
+++ b/base/command_line.cc
@@ -27,8 +27,8 @@
 #include <windows.h>
 
 #include <shellapi.h>
-
 #include "base/strings/string_util_win.h"
+#include "base/win/windows_version.h"
 #endif  // BUILDFLAG(IS_WIN)
 
 namespace base {
@@ -301,6 +301,7 @@ bool CommandLine::HasSwitch(StringPiece switch_string) const {
 }
 
 bool CommandLine::HasSwitch(const char switch_constant[]) const {
+	
   return HasSwitch(StringPiece(switch_constant));
 }
 
diff --git a/base/features.cc b/base/features.cc
index b7dc8ce05d8ca..4e1e6bd2d243d 100644
--- a/base/features.cc
+++ b/base/features.cc
@@ -37,7 +37,15 @@ BASE_FEATURE(kUseRustJsonParser,
              FEATURE_DISABLED_BY_DEFAULT);
 
 BASE_FEATURE(kJsonNegativeZero, "JsonNegativeZero", FEATURE_ENABLED_BY_DEFAULT);
-
+			 
+BASE_FEATURE(kForceDarkModeFlag,
+             "ForceDarkModeFlag",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+#if BUILDFLAG(IS_WIN)
+BASE_FEATURE(kForceGdi,
+             "ForceGdi",
+             base::FEATURE_DISABLED_BY_DEFAULT);
+#endif
 #if BUILDFLAG(IS_ANDROID)
 // Force to enable LowEndDeviceMode partially on Android mid-range devices.
 // Such devices aren't considered low-end, but we'd like experiment with
diff --git a/base/features.h b/base/features.h
index 756445ec6bed3..ca9b953c9e2bc 100644
--- a/base/features.h
+++ b/base/features.h
@@ -27,6 +27,10 @@ BASE_EXPORT BASE_DECLARE_FEATURE(kUseRustJsonParser);
 
 BASE_EXPORT BASE_DECLARE_FEATURE(kJsonNegativeZero);
 
+BASE_EXPORT BASE_DECLARE_FEATURE(kForceDarkModeFlag);
+#if BUILDFLAG(IS_WIN)
+BASE_EXPORT BASE_DECLARE_FEATURE(kForceGdi);
+#endif
 #if BUILDFLAG(IS_ANDROID)
 BASE_EXPORT BASE_DECLARE_FEATURE(kPartialLowEndModeOnMidRangeDevices);
 extern const BASE_EXPORT FeatureParam<bool>
diff --git a/base/files/file_util_win.cc b/base/files/file_util_win.cc
index d7b5fb20aeb34..490d00454b657 100644
--- a/base/files/file_util_win.cc
+++ b/base/files/file_util_win.cc
@@ -1104,11 +1104,37 @@ bool SetNonBlocking(int fd) {
   return false;
 }
 
+namespace {
+
+// ::PrefetchVirtualMemory() is only available on Windows 8 and above. Chrome
+// supports Windows 7, so we need to check for the function's presence
+// dynamically.
+using PrefetchVirtualMemoryPtr = decltype(&::PrefetchVirtualMemory);
+
+// Returns null if ::PrefetchVirtualMemory() is not available.
+PrefetchVirtualMemoryPtr GetPrefetchVirtualMemoryPtr() {
+  HMODULE kernel32_dll = ::GetModuleHandleA("kernel32.dll");
+  return reinterpret_cast<PrefetchVirtualMemoryPtr>(
+      GetProcAddress(kernel32_dll, "PrefetchVirtualMemory"));
+}
+
+}  // namespace
+
 bool PreReadFile(const FilePath& file_path,
                  bool is_executable,
                  int64_t max_bytes) {
   DCHECK_GE(max_bytes, 0);
 
+  // On Win8 and higher use ::PrefetchVirtualMemory(). This is better than a
+  // simple data file read, more from a RAM perspective than CPU. This is
+  // because reading the file as data results in double mapping to
+  // Image/executable pages for all pages of code executed.
+  static PrefetchVirtualMemoryPtr prefetch_virtual_memory =
+      GetPrefetchVirtualMemoryPtr();
+
+  if (prefetch_virtual_memory == nullptr)
+    return internal::PreReadFileSlow(file_path, max_bytes);
+
   if (max_bytes == 0) {
     // ::PrefetchVirtualMemory() fails when asked to read zero bytes.
     // base::MemoryMappedFile::Initialize() fails on an empty file.
@@ -1131,7 +1157,7 @@ bool PreReadFile(const FilePath& file_path,
   // simple data file read, more from a RAM perspective than CPU. This is
   // because reading the file as data results in double mapping to
   // Image/executable pages for all pages of code executed.
-  if (!::PrefetchVirtualMemory(::GetCurrentProcess(),
+  if (!prefetch_virtual_memory(::GetCurrentProcess(),
                                /*NumberOfEntries=*/1, &address_range,
                                /*Flags=*/0)) {
     return internal::PreReadFileSlow(file_path, max_bytes);
diff --git a/base/memory/discardable_shared_memory.cc b/base/memory/discardable_shared_memory.cc
index 23c95bad719c7..62a0b3c1f1d17 100644
--- a/base/memory/discardable_shared_memory.cc
+++ b/base/memory/discardable_shared_memory.cc
@@ -422,11 +422,23 @@ bool DiscardableSharedMemory::Purge(Time current_time) {
 #elif BUILDFLAG(IS_WIN)
   // On Windows, discarded pages are not returned to the system immediately and
   // not guaranteed to be zeroed when returned to the application.
+  using DiscardVirtualMemoryFunction =
+      DWORD(WINAPI*)(PVOID virtualAddress, SIZE_T size);
+  static DiscardVirtualMemoryFunction discard_virtual_memory =
+      reinterpret_cast<DiscardVirtualMemoryFunction>(GetProcAddress(
+          GetModuleHandle(L"Kernel32.dll"), "DiscardVirtualMemory"));
+
   char* address = static_cast<char*>(shared_memory_mapping_.memory()) +
                   AlignToPageSize(sizeof(SharedState));
   size_t length = AlignToPageSize(mapped_size_);
 
-  DWORD ret = DiscardVirtualMemory(address, length);
+  // Use DiscardVirtualMemory when available because it releases faster than
+  // MEM_RESET.
+  DWORD ret = ERROR_NOT_SUPPORTED;
+  if (discard_virtual_memory) {
+    ret = discard_virtual_memory(address, length);
+  }
+
   // DiscardVirtualMemory is buggy in Win10 SP0, so fall back to MEM_RESET on
   // failure.
   if (ret != ERROR_SUCCESS) {
diff --git a/base/memory/platform_shared_memory_region_win.cc b/base/memory/platform_shared_memory_region_win.cc
index e387015249731..233ba25da5efe 100644
--- a/base/memory/platform_shared_memory_region_win.cc
+++ b/base/memory/platform_shared_memory_region_win.cc
@@ -14,7 +14,12 @@
 #include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/process/process_handle.h"
+#include "base/rand_util.h"
 #include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
+
 
 namespace base::subtle {
 
@@ -73,6 +78,7 @@ HANDLE CreateFileMappingWithReducedPermissions(SECURITY_ATTRIBUTES* sa,
   HANDLE h = CreateFileMapping(INVALID_HANDLE_VALUE, sa, PAGE_READWRITE, 0,
                                static_cast<DWORD>(rounded_size), name);
   if (!h) {
+     LOG(ERROR) << "CreateFileMappingW failed with error " << GetLastError() << ".";
     return nullptr;
   }
 
@@ -211,6 +217,17 @@ PlatformSharedMemoryRegion PlatformSharedMemoryRegion::Create(Mode mode,
   }
 
   std::u16string name;
+  if (win::GetVersion() < win::Version::WIN8_1) {
+    // Windows < 8.1 ignores DACLs on certain unnamed objects (like shared
+    // sections). So, we generate a random name when we need to enforce
+    // read-only.
+    uint64_t rand_values[4];
+    RandBytes(&rand_values, sizeof(rand_values));
+    name = ASCIIToUTF16(StringPrintf("CrSharedMem_%016llx%016llx%016llx%016llx",
+                                     rand_values[0], rand_values[1],
+                                     rand_values[2], rand_values[3]));
+    DCHECK(!name.empty());
+  }
   SECURITY_ATTRIBUTES sa = {sizeof(sa), &sd, FALSE};
   // Ask for the file mapping with reduced permisions to avoid passing the
   // access control permissions granted by default into unpriviledged process.
diff --git a/base/message_loop/message_pump_win.cc b/base/message_loop/message_pump_win.cc
index 9425ad4ba5432..395d86b6fa45f 100644
--- a/base/message_loop/message_pump_win.cc
+++ b/base/message_loop/message_pump_win.cc
@@ -790,6 +790,7 @@ bool MessagePumpForIO::GetIOItem(DWORD timeout, IOItem* item) {
                                    &overlapped, timeout)) {
     if (!overlapped)
       return false;  // Nothing in the queue.
+  
     item->error = GetLastError();
     item->bytes_transfered = 0;
   }
diff --git a/base/power_monitor/power_monitor_device_source_win.cc b/base/power_monitor/power_monitor_device_source_win.cc
index 4e7b6563bc229..3925a372ed509 100644
--- a/base/power_monitor/power_monitor_device_source_win.cc
+++ b/base/power_monitor/power_monitor_device_source_win.cc
@@ -32,8 +32,9 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
       power_event = PowerMonitorSource::POWER_STATE_EVENT;
       break;
     case PBT_APMRESUMEAUTOMATIC:  // Resume from suspend.
-      // We don't notify for PBT_APMRESUMESUSPEND
-      // because, if it occurs, it is always sent as a
+      //case PBT_APMRESUMESUSPEND:  // User-initiated resume from suspend.
+      // We don't notify for this latter event
+      // because if it occurs it is always sent as a
       // second event after PBT_APMRESUMEAUTOMATIC.
       power_event = PowerMonitorSource::RESUME_EVENT;
       break;
@@ -55,6 +56,28 @@ void ProcessWmPowerBroadcastMessage(WPARAM event_id) {
   ProcessPowerEventHelper(power_event);
 }
 
+HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags) {
+  const auto register_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::RegisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "RegisterSuspendResumeNotification"));
+  if (!register_suspend_resume_notification_ptr)
+    return nullptr;
+
+  return register_suspend_resume_notification_ptr(hRecipient, Flags);
+}
+
+BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle) {
+  const auto unregister_suspend_resume_notification_ptr =
+      reinterpret_cast<decltype(&::UnregisterSuspendResumeNotification)>(
+          ::GetProcAddress(::GetModuleHandle(L"user32.dll"),
+                           "UnregisterSuspendResumeNotification"));
+  if (!unregister_suspend_resume_notification_ptr)
+    return FALSE;
+
+  return unregister_suspend_resume_notification_ptr(Handle);
+}
+
 }  // namespace
 
 void PowerMonitorDeviceSource::PlatformInit() {
@@ -79,7 +102,7 @@ void PowerMonitorDeviceSource::PlatformDestroy() {
 // battery power.  Returns true if running on battery.
 bool PowerMonitorDeviceSource::IsOnBatteryPower() {
   SYSTEM_POWER_STATUS status;
-  if (!::GetSystemPowerStatus(&status)) {
+  if (!GetSystemPowerStatus(&status)) {
     DPLOG(ERROR) << "GetSystemPowerStatus failed";
     return false;
   }
@@ -92,7 +115,8 @@ int PowerMonitorDeviceSource::GetInitialSpeedLimit() {
   return PowerThermalObserver::kSpeedLimitMax;
 }
 
-PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
+PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow()
+    : instance_(NULL), message_hwnd_(NULL) {
   if (!CurrentUIThread::IsSet()) {
     // Creating this window in (e.g.) a renderer inhibits shutdown on Windows.
     // See http://crbug.com/230122. TODO(vandebo): http://crbug.com/236031
@@ -105,18 +129,21 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
       kWindowClassName,
       &base::win::WrappedWindowProc<
           PowerMonitorDeviceSource::PowerMessageWindow::WndProcThunk>,
-      0, 0, 0, nullptr, nullptr, nullptr, nullptr, nullptr, &window_class);
+      0, 0, 0, NULL, NULL, NULL, NULL, NULL,
+      &window_class);
   instance_ = window_class.hInstance;
-  ATOM clazz = ::RegisterClassEx(&window_class);
+  ATOM clazz = RegisterClassEx(&window_class);
   DCHECK(clazz);
 
   message_hwnd_ =
-      ::CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, nullptr, WS_POPUP, 0,
-                       0, 0, 0, nullptr, nullptr, instance_, nullptr);
+      CreateWindowEx(WS_EX_NOACTIVATE, kWindowClassName, NULL, WS_POPUP, 0, 0,
+                     0, 0, NULL, NULL, instance_, NULL);
   if (message_hwnd_) {
-    // On machines with modern standby calling RegisterSuspendResumeNotification
-    // is required in order to get the PBT_APMSUSPEND message.
-    power_notify_handle_ = ::RegisterSuspendResumeNotification(
+    // On machines with modern standby and Win8+, calling
+    // RegisterSuspendResumeNotification is required in order to get the
+    // PBT_APMSUSPEND message. The notification is no longer automatically
+    // fired.
+    power_notify_handle_ = base::RegisterSuspendResumeNotification(
         message_hwnd_, DEVICE_NOTIFY_WINDOW_HANDLE);
   }
 }
@@ -124,10 +151,10 @@ PowerMonitorDeviceSource::PowerMessageWindow::PowerMessageWindow() {
 PowerMonitorDeviceSource::PowerMessageWindow::~PowerMessageWindow() {
   if (message_hwnd_) {
     if (power_notify_handle_)
-      ::UnregisterSuspendResumeNotification(power_notify_handle_);
+      base::UnregisterSuspendResumeNotification(power_notify_handle_);
 
-    ::DestroyWindow(message_hwnd_);
-    ::UnregisterClass(kWindowClassName, instance_);
+    DestroyWindow(message_hwnd_);
+    UnregisterClass(kWindowClassName, instance_);
   }
 }
 
diff --git a/base/process/process_util_unittest.cc b/base/process/process_util_unittest.cc
index 306d850f6319c..9c59833f55bf3 100644
--- a/base/process/process_util_unittest.cc
+++ b/base/process/process_util_unittest.cc
@@ -829,11 +829,19 @@ TEST_F(ProcessUtilTest, LaunchAsUser) {
 }
 
 MULTIPROCESS_TEST_MAIN(ChildVerifiesCetDisabled) {
-  // Policy not defined for Win < Win10 20H1 but that's ok.
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
+  // Not available for Win7 but this process should still work.
+  if (!get_process_mitigation_policy)
+    return kSuccess;
+
+  // Policy not defined for Win < Win10 20H1 but that's also ok.
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-  if (GetProcessMitigationPolicy(GetCurrentProcess(),
-                                 ProcessUserShadowStackPolicy, &policy,
-                                 sizeof(policy))) {
+  if (get_process_mitigation_policy(GetCurrentProcess(),
+                                    ProcessUserShadowStackPolicy, &policy,
+                                    sizeof(policy))) {
     if (policy.EnableUserShadowStack)
       return 1;
   }
diff --git a/base/process/process_win.cc b/base/process/process_win.cc
index 9a414d886f779..917e2a9a18233 100644
--- a/base/process/process_win.cc
+++ b/base/process/process_win.cc
@@ -265,35 +265,12 @@ bool Process::SetPriority(Priority priority) {
   // priority inversion, and having a process put itself in background mode is
   // broken in Windows 11 22H2. So, it is no longer supported. See
   // https://crbug.com/1396155 for details.
+  // NOTE: NtSetInformationProcess call (SetProcessInformation really) using ProcessPowerThrottling class removed because it is useless before Windows 10.
   DCHECK(!is_current());
   const DWORD priority_class = priority == Priority::kBestEffort
                                    ? IDLE_PRIORITY_CLASS
                                    : NORMAL_PRIORITY_CLASS;
 
-  if (base::win::OSInfo::GetInstance()->version() >=
-          base::win::Version::WIN11 &&
-      FeatureList::IsEnabled(kUseEcoQoSForBackgroundProcess)) {
-    PROCESS_POWER_THROTTLING_STATE power_throttling;
-    RtlZeroMemory(&power_throttling, sizeof(power_throttling));
-    power_throttling.Version = PROCESS_POWER_THROTTLING_CURRENT_VERSION;
-
-    if (priority == Priority::kBestEffort) {
-      // Sets Eco QoS level.
-      power_throttling.ControlMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-      power_throttling.StateMask = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
-    } else {
-      // Uses system default.
-      power_throttling.ControlMask = 0;
-      power_throttling.StateMask = 0;
-    }
-    bool ret =
-        ::SetProcessInformation(Handle(), ProcessPowerThrottling,
-                                &power_throttling, sizeof(power_throttling));
-    if (ret == 0) {
-      DPLOG(ERROR) << "Setting process QoS policy fails";
-    }
-  }
-
   return (::SetPriorityClass(Handle(), priority_class) != 0);
 }
 
diff --git a/base/rand_util_win.cc b/base/rand_util_win.cc
index 549f4362af8b6..2d9a1633b564f 100644
--- a/base/rand_util_win.cc
+++ b/base/rand_util_win.cc
@@ -9,6 +9,13 @@
 #include <stddef.h>
 #include <stdint.h>
 
+// #define needed to link in RtlGenRandom(), a.k.a. SystemFunction036.  See the
+// "Community Additions" comment on MSDN here:
+// http://msdn.microsoft.com/en-us/library/windows/desktop/aa387694.aspx
+#define SystemFunction036 NTAPI SystemFunction036
+#include <NTSecAPI.h>
+#undef SystemFunction036
+
 #include <algorithm>
 #include <atomic>
 #include <limits>
@@ -18,12 +25,6 @@
 #include "third_party/boringssl/src/include/openssl/crypto.h"
 #include "third_party/boringssl/src/include/openssl/rand.h"
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace base {
 
 namespace internal {
@@ -53,18 +54,6 @@ bool UseBoringSSLForRandBytes() {
 
 namespace {
 
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
 void RandBytes(void* output, size_t output_length, bool avoid_allocation) {
   if (!avoid_allocation && internal::UseBoringSSLForRandBytes()) {
     // Ensure BoringSSL is initialized so it can use things like RDRAND.
@@ -74,10 +63,16 @@ void RandBytes(void* output, size_t output_length, bool avoid_allocation) {
     return;
   }
 
-  static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-  BOOL success = process_prng_fn(static_cast<BYTE*>(output), output_length);
-  // ProcessPrng is documented to always return TRUE.
-  CHECK(success);
+  char* output_ptr = static_cast<char*>(output);
+  while (output_length > 0) {
+    const ULONG output_bytes_this_pass = static_cast<ULONG>(std::min(
+        output_length, static_cast<size_t>(std::numeric_limits<ULONG>::max())));
+    const bool success =
+        RtlGenRandom(output_ptr, output_bytes_this_pass) != FALSE;
+    CHECK(success);
+    output_length -= output_bytes_this_pass;
+    output_ptr += output_bytes_this_pass;
+  }
 }
 
 }  // namespace
diff --git a/base/task/thread_pool/thread_group.cc b/base/task/thread_pool/thread_group.cc
index 7e9dd368eb0ec..0fb94478eb47b 100644
--- a/base/task/thread_pool/thread_group.cc
+++ b/base/task/thread_pool/thread_group.cc
@@ -16,7 +16,9 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/com_init_check_hook.h"
+#include "base/win/scoped_com_initializer.h"
 #include "base/win/scoped_winrt_initializer.h"
+#include "base/win/windows_version.h"
 #endif
 
 namespace base {
@@ -329,8 +331,18 @@ bool ThreadGroup::ShouldYield(TaskSourceSortKey sort_key) {
 std::unique_ptr<win::ScopedWindowsThreadEnvironment>
 ThreadGroup::GetScopedWindowsThreadEnvironment(WorkerEnvironment environment) {
   std::unique_ptr<win::ScopedWindowsThreadEnvironment> scoped_environment;
-  if (environment == WorkerEnvironment::COM_MTA) {
-    scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+  switch (environment) {
+    case WorkerEnvironment::COM_MTA: {
+      if (win::GetVersion() >= win::Version::WIN8) {
+        scoped_environment = std::make_unique<win::ScopedWinrtInitializer>();
+      } else {
+        scoped_environment = std::make_unique<win::ScopedCOMInitializer>(
+            win::ScopedCOMInitializer::kMTA);
+      }
+      break;
+    }
+    default:
+      break;
   }
 
   DCHECK(!scoped_environment || scoped_environment->Succeeded());
@@ -344,4 +356,4 @@ bool ThreadGroup::CurrentThreadHasGroup() {
 }
 
 }  // namespace internal
-}  // namespace base
+}  // namespace base
\ No newline at end of file
diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index 83a1402780b0d..a7cdeb078197f 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -50,6 +50,13 @@ namespace {
 // Flag used to set thread priority to |THREAD_PRIORITY_LOWEST| for
 // |kUseThreadPriorityLowest| Feature.
 std::atomic<bool> g_use_thread_priority_lowest{false};
+// The most common value returned by ::GetThreadPriority() after background
+// thread mode is enabled on Windows 7.
+constexpr int kWin7BackgroundThreadModePriority = 4;
+
+// Value sometimes returned by ::GetThreadPriority() after thread priority is
+// set to normal on Windows 7.
+constexpr int kWin7NormalPriority = 3;
 // Flag used to map Compositing ThreadType |THREAD_PRIORITY_ABOVE_NORMAL| on the
 // UI thread for |kAboveNormalCompositingBrowserWin| Feature.
 std::atomic<bool> g_above_normal_compositing_browser{true};
@@ -236,7 +243,10 @@ void AssertMemoryPriority(HANDLE thread, int memory_priority) {
       reinterpret_cast<decltype(&::GetThreadInformation)>(::GetProcAddress(
           ::GetModuleHandle(L"Kernel32.dll"), "GetThreadInformation"));
 
-  DCHECK(get_thread_information_fn);
+  if (!get_thread_information_fn) {
+    DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+    return;
+  }
 
   MEMORY_PRIORITY_INFORMATION memory_priority_information = {};
   DCHECK(get_thread_information_fn(thread, ::ThreadMemoryPriority,
@@ -536,8 +546,14 @@ ThreadPriorityForTest PlatformThread::GetCurrentThreadPriorityForTest() {
     return ThreadPriorityForTest::kBackground;
 
   switch (priority) {
+    case kWin7BackgroundThreadModePriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      return ThreadPriorityForTest::kBackground;
     case THREAD_PRIORITY_BELOW_NORMAL:
       return ThreadPriorityForTest::kUtility;
+    case kWin7NormalPriority:
+      DCHECK_EQ(win::GetVersion(), win::Version::WIN7);
+      [[fallthrough]];
     case THREAD_PRIORITY_NORMAL:
       return ThreadPriorityForTest::kNormal;
     case kWinDisplayPriority1:
diff --git a/base/time/time_win.cc b/base/time/time_win.cc
index c6540592a5c18..f453dc2ed20cf 100644
--- a/base/time/time_win.cc
+++ b/base/time/time_win.cc
@@ -646,11 +646,11 @@ TimeTicks::Clock TimeTicks::GetClock() {
 
 namespace subtle {
 LiveTicks LiveTicksNowIgnoringOverride() {
-  ULONGLONG unbiased_interrupt_time;
-  QueryUnbiasedInterruptTimePrecise(&unbiased_interrupt_time);
+  LARGE_INTEGER unbiased_interrupt_time;
+  QueryPerformanceCounter(&unbiased_interrupt_time);
   // QueryUnbiasedInterruptTimePrecise gets the interrupt time in system time
   // units of 100 nanoseconds.
-  return LiveTicks() + Nanoseconds(unbiased_interrupt_time * 100);
+  return LiveTicks() + Nanoseconds(unbiased_interrupt_time.QuadPart * 100);
 }
 }  // namespace subtle
 
diff --git a/base/trace_event/trace_logging_minimal_win.cc b/base/trace_event/trace_logging_minimal_win.cc
index b0db1074d9ca9..490d7a082ecc7 100644
--- a/base/trace_event/trace_logging_minimal_win.cc
+++ b/base/trace_event/trace_logging_minimal_win.cc
@@ -10,6 +10,61 @@
 #include "base/logging.h"
 #include "base/numerics/checked_math.h"
 
+/*
+EventSetInformation configuration macros:
+
+TraceLogging works best if the EventSetInformation API can be used to notify
+ETW that the provider uses TraceLogging event encoding.
+
+The EventSetInformation API is available on Windows 8 and later. (It is also
+available on fully-patched Windows 7, but not on Windows 7 RTM).
+
+The TLM_HAVE_EVENT_SET_INFORMATION and TLM_EVENT_SET_INFORMATION macros can
+be set before compiling this file to  control how the TlmProvider class deals
+with the EventSetInformation API.
+
+If these macros are not set, the default behavior is to check the WINVER
+macro at compile time:
+
+- If WINVER is set to Windows 7 or before, TlmProvider will use GetProcAddress
+  to locate EventSetInformation, and then invoke it if present. This is less
+  efficient, but works on older versions of Windows.
+- If WINVER is set to Windows 8 or later, TlmProvider will directly invoke
+  EventSetInformation. This is more efficient, but the resulting application
+  will only work correctly on newer versions of Windows.
+
+If you need to run on Windows 7 RTM, but for some reason need to set WINVER to
+Windows 8 or higher, you can override the default behavior by defining
+TLM_HAVE_EVENT_SET_INFORMATION=2 when compiling this file.
+
+Details:
+- The TLM_EVENT_SET_INFORMATION macro can be set the name of a replacement
+  function that TlmProvider should use instead of EventSetInformation.
+- The TLM_HAVE_EVENT_SET_INFORMATION macro can be set to 0 (disable the use of
+  EventSetInformation), 1 (directly invoke EventSetInformation), or 2 (try to
+  locate EventSetInformation via GetProcAddress, and invoke if found).
+*/
+
+// This code needs to run on Windows 7 and this is magic which
+// removes static linking to EventSetInformation
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+
+#ifndef TLM_EVENT_SET_INFORMATION
+#define TLM_EVENT_SET_INFORMATION EventSetInformation
+#ifndef TLM_HAVE_EVENT_SET_INFORMATION
+#if WINVER < 0x0602 || !defined(EVENT_FILTER_TYPE_SCHEMATIZED)
+// Find "EventSetInformation" via GetModuleHandleExW+GetProcAddress
+#define TLM_HAVE_EVENT_SET_INFORMATION 2
+#else
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+#endif
+#elif !defined(TLM_HAVE_EVENT_SET_INFORMATION)
+// Directly invoke TLM_EVENT_SET_INFORMATION(...)
+#define TLM_HAVE_EVENT_SET_INFORMATION 1
+#endif
+
 TlmProvider::~TlmProvider() {
   Unregister();
 }
@@ -20,7 +75,7 @@ TlmProvider::TlmProvider(const char* provider_name,
                          void* enable_callback_context) noexcept {
   ULONG status = Register(provider_name, provider_guid, enable_callback,
                           enable_callback_context);
-  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider resistration failure";
+  LOG_IF(ERROR, status != ERROR_SUCCESS) << "Provider registration failure";
 }
 
 // Appends a nul-terminated string to a metadata block.
@@ -79,9 +134,42 @@ ULONG TlmProvider::Register(const char* provider_name,
   if (status != ERROR_SUCCESS)
     return status;
 
+#if TLM_HAVE_EVENT_SET_INFORMATION == 1
+
   // Best-effort, ignore failure.
-  return ::EventSetInformation(reg_handle_, EventProviderSetTraits,
-                               provider_metadata_, provider_metadata_size_);
+  status =
+      TLM_EVENT_SET_INFORMATION(reg_handle_, EventProviderSetTraits,
+                                provider_metadata_, provider_metadata_size_);
+
+#elif TLM_HAVE_EVENT_SET_INFORMATION == 2
+
+  HMODULE eventing_lib;
+  if (GetModuleHandleExW(0, L"api-ms-win-eventing-provider-l1-1-0.dll",
+                         &eventing_lib) ||
+      GetModuleHandleExW(0, L"advapi32.dll", &eventing_lib)) {
+    typedef ULONG(WINAPI * PFEventSetInformation)(
+        REGHANDLE reg_handle, EVENT_INFO_CLASS information_class,
+        PVOID event_information, ULONG information_length);
+    PFEventSetInformation event_set_information_ptr =
+        reinterpret_cast<decltype(&::EventSetInformation)>(
+            GetProcAddress(eventing_lib, "EventSetInformation"));
+    if (event_set_information_ptr) {
+      // Best-effort, ignore failure.
+      status = event_set_information_ptr(reg_handle_, EventProviderSetTraits,
+                                         provider_metadata_,
+                                         provider_metadata_size_);
+    }
+
+    FreeLibrary(eventing_lib);
+  }
+
+#else  // TLM_HAVE_EVENT_SET_INFORMATION == 0
+
+    // Make no attempt to invoke EventSetInformation.
+
+#endif  // TLM_HAVE_EVENT_SET_INFORMATION
+
+  return status;
 }
 
 bool TlmProvider::IsEnabled() const noexcept {
diff --git a/base/win/cet_shadow_stack_unittest.cc b/base/win/cet_shadow_stack_unittest.cc
index 8c58163cfbf44..cb73ea9e8e388 100644
--- a/base/win/cet_shadow_stack_unittest.cc
+++ b/base/win/cet_shadow_stack_unittest.cc
@@ -19,10 +19,14 @@ bool IsHardwareEnforcedShadowStacksEnabled() {
   if (base::win::GetVersion() < base::win::Version::WIN10_20H1)
     return false;
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return false;
   }
 
diff --git a/base/win/core_winrt_util.cc b/base/win/core_winrt_util.cc
index 25f5885bf2f40..3508cfe474bfd 100644
--- a/base/win/core_winrt_util.cc
+++ b/base/win/core_winrt_util.cc
@@ -3,17 +3,54 @@
 // found in the LICENSE file.
 
 #include "base/win/core_winrt_util.h"
+#include "base/threading/scoped_thread_priority.h"
 
 namespace base::win {
 
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoActivateInstance) GetRoActivateInstanceFunction() {
+  static decltype(&::RoActivateInstance) const function =
+      reinterpret_cast<decltype(&::RoActivateInstance)>(
+          LoadComBaseFunction("RoActivateInstance"));
+  return function;
+}
+
+decltype(&::RoGetActivationFactory) GetRoGetActivationFactoryFunction() {
+  static decltype(&::RoGetActivationFactory) const function =
+      reinterpret_cast<decltype(&::RoGetActivationFactory)>(
+          LoadComBaseFunction("RoGetActivationFactory"));
+  return function;
+}
+
+bool ResolveCoreWinRTDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+  return GetRoActivateInstanceFunction() && GetRoGetActivationFactoryFunction();
+}
+
 HRESULT RoGetActivationFactory(HSTRING class_id,
                                const IID& iid,
                                void** out_factory) {
-  return ::RoGetActivationFactory(class_id, iid, out_factory);
+  auto get_factory_func = GetRoGetActivationFactoryFunction();
+  if (!get_factory_func)
+    return E_FAIL;
+  return get_factory_func(class_id, iid, out_factory);
 }
 
 HRESULT RoActivateInstance(HSTRING class_id, IInspectable** instance) {
-  return ::RoActivateInstance(class_id, instance);
+  auto activate_instance_func = GetRoActivateInstanceFunction();
+  if (!activate_instance_func)
+    return E_FAIL;
+  return activate_instance_func(class_id, instance);
 }
 
 }  // namespace base::win
diff --git a/base/win/core_winrt_util.h b/base/win/core_winrt_util.h
index 3a6e0c9f3774c..c4a802c85d6ed 100644
--- a/base/win/core_winrt_util.h
+++ b/base/win/core_winrt_util.h
@@ -15,6 +15,8 @@
 
 namespace base::win {
 
+BASE_EXPORT bool ResolveCoreWinRTDelayload();
+
 // The following stubs are provided for when component build is enabled, in
 // order to avoid the propagation of delay-loading CoreWinRT to other modules.
diff --git a/base/win/hstring_reference.cc b/base/win/hstring_reference.cc
index b254fc64310a1..6b2b1a6290990 100644
--- a/base/win/hstring_reference.cc
+++ b/base/win/hstring_reference.cc
@@ -12,18 +12,54 @@
 #include "base/check_op.h"
 #include "base/numerics/safe_conversions.h"
 
-namespace base::win {
+namespace base {
+namespace {
+
+bool g_winrt_string_loaded = false;
+
+decltype(&::WindowsCreateStringReference) GetWindowsCreateStringReference() {
+  static auto const create_string_reference_func =
+      []() -> decltype(&::WindowsCreateStringReference) {
+    const HMODULE handle =
+        ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+    if (handle) {
+      return reinterpret_cast<decltype(&::WindowsCreateStringReference)>(
+          ::GetProcAddress(handle, "WindowsCreateStringReference"));
+    }
+    return nullptr;
+  }();
+  return create_string_reference_func;
+}
+
+}  // namespace
+
+namespace win {
+
+// static
+bool HStringReference::ResolveCoreWinRTStringDelayload() {
+  g_winrt_string_loaded = GetWindowsCreateStringReference() != nullptr;
+  return g_winrt_string_loaded;
+}
 
 HStringReference::HStringReference(const wchar_t* str, size_t length) {
+
+  // This was added because otherwise, the checks below would consistently fail.
+  ResolveCoreWinRTStringDelayload();
+  DCHECK(g_winrt_string_loaded);
   // String must be null terminated for WindowsCreateStringReference.
   // nullptr str is OK so long as the length is 0.
   DCHECK(str ? str[length] == L'\0' : length == 0);
-  const HRESULT hr = ::WindowsCreateStringReference(
+  // If you nullptr crash here, you've failed to call
+  // ResolveCoreWinRTStringDelayLoad and check its return value.
+  const HRESULT hr = GetWindowsCreateStringReference()(
       str, checked_cast<UINT32>(length), &hstring_header_, &hstring_);
+  // All failure modes of WindowsCreateStringReference are handled gracefully
+  // but this class.
   DCHECK_EQ(hr, S_OK);
 }
 
 HStringReference::HStringReference(const wchar_t* str)
     : HStringReference(str, str ? wcslen(str) : 0) {}
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
diff --git a/base/win/hstring_reference.h b/base/win/hstring_reference.h
index 3cde4acef6f2e..2366a681e72c0 100644
--- a/base/win/hstring_reference.h
+++ b/base/win/hstring_reference.h
@@ -9,7 +9,8 @@
 
 #include "base/base_export.h"
 
-namespace base::win {
+namespace base {
+namespace win {
 
 // HStringReference is an HSTRING representation of a null terminated
 // string backed by memory that outlives the HStringReference instance.
@@ -17,12 +18,31 @@ namespace base::win {
 // If you need an HSTRING class that manages its own memory, you should
 // use ScopedHString instead.
 //
+// Note that HStringReference requires certain functions that are only
+// available on Windows 8 and later, and that these functions need to be
+// delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using HStringReference.
+//
+// One-time Initialization for HStringReference:
+//
+//   const bool success = HStringReference::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // HStringReference can be used.
+//   } else {
+//     // Handle error.
+//   }
+//
 // Example use:
 //
 //   HStringReference string(L"abc");
 //
 class BASE_EXPORT HStringReference {
  public:
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  static bool ResolveCoreWinRTStringDelayload();
+
   HStringReference(const wchar_t* str, size_t len);
   explicit HStringReference(const wchar_t* str);
 
@@ -47,6 +67,7 @@ class BASE_EXPORT HStringReference {
   HSTRING_HEADER hstring_header_;
 };
 
-}  // namespace base::win
+}  // namespace win
+}  // namespace base
 
 #endif  // BASE_WIN_HSTRING_REFERENCE_H_
diff --git a/base/win/hstring_reference_unittest.cc b/base/win/hstring_reference_unittest.cc
index 64fa91320a040..5761ea461574a 100644
--- a/base/win/hstring_reference_unittest.cc
+++ b/base/win/hstring_reference_unittest.cc
@@ -26,6 +26,8 @@ void VerifyHSTRINGEquals(HSTRING hstring, const wchar_t* test_string) {
 }  // namespace
 
 TEST(HStringReferenceTest, Init) {
+  EXPECT_TRUE(HStringReference::ResolveCoreWinRTStringDelayload());
+ 
   const HStringReference string(kTestString);
   EXPECT_NE(string.Get(), nullptr);
   VerifyHSTRINGEquals(string.Get(), kTestString);
diff --git a/base/win/registry.cc b/base/win/registry.cc
index 7b9dcb90e627e..d24a4b0ede9d5 100644
--- a/base/win/registry.cc
+++ b/base/win/registry.cc
@@ -23,6 +23,7 @@
 #include "base/win/object_watcher.h"
 #include "base/win/scoped_handle.h"
 #include "base/win/shlwapi.h"
+#include "base/win/windows_version.h"
 
 extern "C" NTSTATUS WINAPI NtDeleteKey(IN HANDLE KeyHandle);
 
@@ -87,8 +88,9 @@ bool RegKey::Watcher::StartWatching(HKEY key, ChangeCallback callback) {
   }
 
   DWORD filter = REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_ATTRIBUTES |
-                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY |
-                 REG_NOTIFY_THREAD_AGNOSTIC;
+                 REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_SECURITY;
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    filter |= REG_NOTIFY_THREAD_AGNOSTIC;
   // Watch the registry key for a change of value.
   LONG result =
       RegNotifyChangeKeyValue(key, /*bWatchSubtree=*/TRUE, filter,
diff --git a/base/win/scoped_hstring.cc b/base/win/scoped_hstring.cc
index 042768f2b249e..6a8b7eff01b90 100644
--- a/base/win/scoped_hstring.cc
+++ b/base/win/scoped_hstring.cc
@@ -18,24 +18,88 @@
 
 namespace base {
 
+namespace {
+
+static bool g_load_succeeded = false;
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle =
+      ::LoadLibraryEx(L"combase.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::WindowsCreateString) GetWindowsCreateString() {
+  static decltype(&::WindowsCreateString) const function =
+      reinterpret_cast<decltype(&::WindowsCreateString)>(
+          LoadComBaseFunction("WindowsCreateString"));
+  return function;
+}
+
+decltype(&::WindowsDeleteString) GetWindowsDeleteString() {
+  static decltype(&::WindowsDeleteString) const function =
+      reinterpret_cast<decltype(&::WindowsDeleteString)>(
+          LoadComBaseFunction("WindowsDeleteString"));
+  return function;
+}
+
+decltype(&::WindowsGetStringRawBuffer) GetWindowsGetStringRawBuffer() {
+  static decltype(&::WindowsGetStringRawBuffer) const function =
+      reinterpret_cast<decltype(&::WindowsGetStringRawBuffer)>(
+          LoadComBaseFunction("WindowsGetStringRawBuffer"));
+  return function;
+}
+
+HRESULT WindowsCreateString(const wchar_t* src,
+                            uint32_t len,
+                            HSTRING* out_hstr) {
+  decltype(&::WindowsCreateString) create_string_func =
+      GetWindowsCreateString();
+  if (!create_string_func)
+    return E_FAIL;
+  return create_string_func(src, len, out_hstr);
+}
+
+HRESULT WindowsDeleteString(HSTRING hstr) {
+  decltype(&::WindowsDeleteString) delete_string_func =
+      GetWindowsDeleteString();
+  if (!delete_string_func)
+    return E_FAIL;
+  return delete_string_func(hstr);
+}
+
+const wchar_t* WindowsGetStringRawBuffer(HSTRING hstr, uint32_t* out_len) {
+  decltype(&::WindowsGetStringRawBuffer) get_string_raw_buffer_func =
+      GetWindowsGetStringRawBuffer();
+  if (!get_string_raw_buffer_func) {
+    *out_len = 0;
+    return nullptr;
+  }
+  return get_string_raw_buffer_func(hstr, out_len);
+}
+
+}  // namespace
+
 namespace internal {
 
 // static
 void ScopedHStringTraits::Free(HSTRING hstr) {
-  ::WindowsDeleteString(hstr);
+  base::WindowsDeleteString(hstr);
 }
 
 }  // namespace internal
 
 namespace win {
 
-ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {}
+ScopedHString::ScopedHString(HSTRING hstr) : ScopedGeneric(hstr) {
+  DCHECK(g_load_succeeded);
+}
 
 // static
 ScopedHString ScopedHString::Create(WStringPiece str) {
+  DCHECK(g_load_succeeded);
   HSTRING hstr;
-  HRESULT hr = ::WindowsCreateString(str.data(),
-                                     checked_cast<UINT32>(str.length()), &hstr);
+  HRESULT hr = base::WindowsCreateString(
+      str.data(), checked_cast<UINT32>(str.length()), &hstr);
   if (SUCCEEDED(hr))
     return ScopedHString(hstr);
 
@@ -57,9 +121,21 @@ ScopedHString ScopedHString::Create(StringPiece str) {
 }
 
 // static
+bool ScopedHString::ResolveCoreWinRTStringDelayload() {
+  // TODO(finnur): Add AssertIOAllowed once crbug.com/770193 is fixed.
+
+  static const bool load_succeeded = []() {
+    bool success = GetWindowsCreateString() && GetWindowsDeleteString() &&
+                   GetWindowsGetStringRawBuffer();
+    g_load_succeeded = success;
+    return success;
+  }();
+  return load_succeeded;
+}
+
 WStringPiece ScopedHString::Get() const {
   UINT32 length = 0;
-  const wchar_t* buffer = ::WindowsGetStringRawBuffer(get(), &length);
+  const wchar_t* buffer = base::WindowsGetStringRawBuffer(get(), &length);
   return WStringPiece(buffer, length);
 }
 
diff --git a/base/win/scoped_hstring.h b/base/win/scoped_hstring.h
index 95bc98bc2cf09..4ba6e23d08272 100644
--- a/base/win/scoped_hstring.h
+++ b/base/win/scoped_hstring.h
@@ -27,7 +27,21 @@ struct BASE_EXPORT ScopedHStringTraits {
 
 namespace win {
 
-// ScopedHString is a wrapper around an HSTRING.
+// ScopedHString is a wrapper around an HSTRING. Note that it requires certain
+// functions that are only available on Windows 8 and later, and that these
+// functions need to be delayloaded to avoid breaking Chrome on Windows 7.
+//
+// Callers MUST check the return value of ResolveCoreWinRTStringDelayLoad()
+// *before* using ScopedHString.
+//
+// One-time Initialization for ScopedHString:
+//
+//   bool success = ScopedHString::ResolveCoreWinRTStringDelayload();
+//   if (success) {
+//     // ScopeHString can be used.
+//   } else {
+//     // Handle error.
+//   }
 //
 // Example use:
 //
@@ -48,6 +62,9 @@ class BASE_EXPORT ScopedHString
   static ScopedHString Create(WStringPiece str);
   static ScopedHString Create(StringPiece str);
 
+  // Loads all required HSTRING functions, available from Win8 and onwards.
+  [[nodiscard]] static bool ResolveCoreWinRTStringDelayload();
+
   // Returns a view into the memory buffer managed by the instance. The returned
   // StringPiece is only valid during the lifetime of this ScopedHString
   // instance.
diff --git a/base/win/scoped_winrt_initializer.cc b/base/win/scoped_winrt_initializer.cc
index 4c93dcfabf658..85f83dab8192b 100644
--- a/base/win/scoped_winrt_initializer.cc
+++ b/base/win/scoped_winrt_initializer.cc
@@ -5,14 +5,61 @@
 #include "base/win/scoped_winrt_initializer.h"
 
 #include <roapi.h>
+#include <windows.h>
+
+#include <ostream>
 
 #include "base/check_op.h"
+#include "base/threading/scoped_thread_priority.h"
 #include "base/win/com_init_util.h"
+#include "base/win/core_winrt_util.h"
 
 namespace base::win {
 
+namespace {
+
+FARPROC LoadComBaseFunction(const char* function_name) {
+  static HMODULE const handle = []() {
+    // Mitigate the issues caused by loading DLLs on a background thread
+    // (http://crbug/973868).
+    SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+    return ::LoadLibraryEx(L"combase.dll", nullptr,
+                           LOAD_LIBRARY_SEARCH_SYSTEM32);
+  }();
+  return handle ? ::GetProcAddress(handle, function_name) : nullptr;
+}
+
+decltype(&::RoInitialize) GetRoInitializeFunction() {
+  static decltype(&::RoInitialize) const function =
+      reinterpret_cast<decltype(&::RoInitialize)>(
+          LoadComBaseFunction("RoInitialize"));
+  return function;
+}
+
+decltype(&::RoUninitialize) GetRoUninitializeFunction() {
+  static decltype(&::RoUninitialize) const function =
+      reinterpret_cast<decltype(&::RoUninitialize)>(
+          LoadComBaseFunction("RoUninitialize"));
+  return function;
+}
+
+HRESULT CallRoInitialize(RO_INIT_TYPE init_type) {
+  auto ro_initialize_func = GetRoInitializeFunction();
+  if (!ro_initialize_func)
+    return E_FAIL;
+  return ro_initialize_func(init_type);
+}
+
+void CallRoUninitialize() {
+  auto ro_uninitialize_func = GetRoUninitializeFunction();
+  if (ro_uninitialize_func)
+    ro_uninitialize_func();
+}
+
+}  // namespace
+
 ScopedWinrtInitializer::ScopedWinrtInitializer()
-    : hr_(::RoInitialize(RO_INIT_MULTITHREADED)) {
+    : hr_(CallRoInitialize(RO_INIT_MULTITHREADED)) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 #if DCHECK_IS_ON()
   if (SUCCEEDED(hr_))
@@ -25,7 +72,7 @@ ScopedWinrtInitializer::ScopedWinrtInitializer()
 ScopedWinrtInitializer::~ScopedWinrtInitializer() {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   if (SUCCEEDED(hr_))
-    ::RoUninitialize();
+    CallRoUninitialize();
 }
 
 bool ScopedWinrtInitializer::Succeeded() const {
diff --git a/base/win/win_util.cc b/base/win/win_util.cc
index 0d81e7c0a268e..b65c2426fb443 100644
--- a/base/win/win_util.cc
+++ b/base/win/win_util.cc
@@ -38,6 +38,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/files/file_path.h"
 #include "base/logging.h"
 #include "base/metrics/histogram_functions.h"
@@ -66,6 +67,21 @@ namespace base {
 namespace win {
 
 namespace {
+	
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+	
+bool ShouldUseDirectWrite() {
+  // Considering that there are seemingly some decent DirectWrite implementations
+  // out there for XP, we will no longer discriminate by OS version.
+  if (!::LoadLibraryA("dwrite.dll")) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch(kDisableDirectWrite);
+}
 
 // Sets the value of |property_key| to |property_value| in |property_store|.
 bool SetPropVariantValueForPropertyStore(
@@ -95,10 +111,40 @@ void __cdecl ForceCrashOnSigAbort(int) {
   *((volatile int*)nullptr) = 0x1337;
 }
 
-// Returns the current platform role. We use the PowerDeterminePlatformRoleEx
+// Returns the current platform role. We use the PowerDeterminePlatformRole
 // API for that.
 POWER_PLATFORM_ROLE GetPlatformRole() {
-  return PowerDeterminePlatformRoleEx(POWER_PLATFORM_ROLE_V2);
+	return PowerDeterminePlatformRole();
+}
+
+// Because we used to support versions earlier than 8.1, we dynamically load
+// this function from user32.dll, so it won't fail to load in runtime.
+// TODO(https://crbug.com/1408307): Call SetProcessDpiAwareness directly.
+bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
+  if (!IsUser32AndGdi32Available())
+    return false;
+
+  static const auto set_process_dpi_awareness_func =
+      reinterpret_cast<decltype(&::SetProcessDpiAwareness)>(
+          GetUser32FunctionPointer("SetProcessDpiAwarenessInternal"));
+  if (set_process_dpi_awareness_func) {
+    HRESULT hr = set_process_dpi_awareness_func(value);
+    if (SUCCEEDED(hr))
+      return true;
+    DLOG_IF(ERROR, hr == E_ACCESSDENIED)
+        << "Access denied error from SetProcessDpiAwarenessInternal. "
+           "Function called twice, or manifest was used.";
+    NOTREACHED()
+        << "SetProcessDpiAwarenessInternal failed with unexpected error: "
+        << hr;
+    return false;
+  }
+
+  DCHECK_LT(GetVersion(), Version::WIN8_1) << "SetProcessDpiAwarenessInternal "
+                                              "should be available on all "
+                                              "platforms >= Windows 8.1";
+
+  return false;
 }
 
 // Enable V2 per-monitor high-DPI support for the process. This will cause
@@ -238,10 +284,16 @@ bool IsWindows10OrGreaterTabletMode(HWND hwnd) {
            IsDeviceUsedAsATablet(/*reason=*/nullptr);
   }
 
+  if (!ResolveCoreWinRTDelayload() ||
+      !ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
+
   ScopedHString view_settings_guid = ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UIViewSettings);
   Microsoft::WRL::ComPtr<IUIViewSettingsInterop> view_settings_interop;
-  HRESULT hr = ::RoGetActivationFactory(view_settings_guid.get(),
+  HRESULT hr = win::RoGetActivationFactory(view_settings_guid.get(),
                                         IID_PPV_ARGS(&view_settings_interop));
   if (FAILED(hr))
     return false;
@@ -606,8 +658,17 @@ bool IsJoinedToAzureAD() {
 bool IsUser32AndGdi32Available() {
   static auto is_user32_and_gdi32_available = []() {
     // If win32k syscalls aren't disabled, then user32 and gdi32 are available.
+	if (!ShouldUseDirectWrite())
+        return true;
+	  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+		  
+    if(!get_process_mitigation_policy)
+		return true;
+		  
     PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
+    if (get_process_mitigation_policy(GetCurrentProcess(),
                                      ProcessSystemCallDisablePolicy, &policy,
                                      sizeof(policy))) {
       return policy.DisallowWin32kSystemCalls == 0;
@@ -673,7 +734,7 @@ void DisableFlicks(HWND hwnd) {
 }
 
 void EnableHighDPISupport() {
-  if (!IsUser32AndGdi32Available())
+  if (!IsUser32AndGdi32Available() || GetVersion() < Version::VISTA)
     return;
 
   // Enable per-monitor V2 if it is available (Win10 1703 or later).
@@ -682,7 +743,7 @@ void EnableHighDPISupport() {
 
   // Fall back to per-monitor DPI for older versions of Win10.
   PROCESS_DPI_AWARENESS process_dpi_awareness = PROCESS_PER_MONITOR_DPI_AWARE;
-  if (!::SetProcessDpiAwareness(process_dpi_awareness)) {
+  if (!SetProcessDpiAwarenessWrapper(process_dpi_awareness)) {
     // For windows versions where SetProcessDpiAwareness fails, try its
     // predecessor.
     BOOL result = ::SetProcessDPIAware();
diff --git a/base/win/winrt_storage_util_unittest.cc b/base/win/winrt_storage_util_unittest.cc
index 5c54819e4b85a..8f3f64f29011a 100644
--- a/base/win/winrt_storage_util_unittest.cc
+++ b/base/win/winrt_storage_util_unittest.cc
@@ -21,6 +21,10 @@ namespace win {
 TEST(WinrtStorageUtilTest, CreateBufferFromData) {
   ScopedCOMInitializer com_initializer(ScopedCOMInitializer::kMTA);
 
+  if (!ResolveCoreWinRTDelayload()) {
+    return;
+  }
+
   const std::vector<uint8_t> data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
   Microsoft::WRL::ComPtr<ABI::Windows::Storage::Streams::IBuffer> buffer;
   ASSERT_HRESULT_SUCCEEDED(
diff --git a/build/config/win/BUILD.gn b/build/config/win/BUILD.gn
index ddcc94a2d5468..ec923348a1409 100644
--- a/build/config/win/BUILD.gn
+++ b/build/config/win/BUILD.gn
@@ -43,6 +43,10 @@ declare_args() {
   #  and with this switch, clang emits it like this:
   #    foo/bar.cc:12:34: error: something went wrong
   use_clang_diagnostics_format = false
+  
+ 
+  # Indicates whether to use /pdbpagesize:8192 to allow PDBs larger than 4 GiB.
+  use_large_pdbs = false
 }
 
 # This is included by reference in the //build/config/compiler config that
@@ -127,7 +131,9 @@ config("compiler") {
     # microarchitecture. MSVC only supports a subset of architectures, and the
     # next step after SSE2 will be AVX.
     if (current_cpu == "x86" || current_cpu == "x64") {
-      cflags += [ "-msse3" ]
+        if (target_cpu == "x64") {
+          cflags += [ "-msse3" ]
+        }
     }
 
     # Enable ANSI escape codes if something emulating them is around (cmd.exe
@@ -168,7 +174,9 @@ config("compiler") {
     # Don't look for libpaths in %LIB%, similar to /X in cflags above.
     ldflags += [ "/lldignoreenv" ]
   }
-
+  if (use_large_pdbs) {
+    # This allows PDBs up to 8 GiB in size. This requires lld-link.exe or
+    # link.exe from VS 2022 or later.
   # Some binaries create PDBs larger than 4 GiB. Increasing the PDB page size
   # to 8 KiB allows 8 GiB PDBs. The larger page size also allows larger block maps
   # which is a PDB limit that was hit in https://crbug.com/1406510. The page size
@@ -182,6 +190,12 @@ config("compiler") {
     ldflags += [ "/pdbpagesize:16384" ]
   } else {
     ldflags += [ "/pdbpagesize:8192" ]
+
+    if (!defined(configs)) {
+      configs = []
+    }
+    configs += [ ":pdb_larger_than_4gb" ]
+  }
   }
 
   if (!is_debug && !is_component_build) {
@@ -243,7 +257,7 @@ config("runtime_library") {
     "_ATL_NO_OPENGL",
     "_WINDOWS",
     "CERT_CHAIN_PARA_HAS_EXTRA_FIELDS",
-    "PSAPI_VERSION=2",
+    "PSAPI_VERSION=1",
     "WIN32",
     "_SECURE_ATL",
   ]
@@ -688,3 +702,15 @@ config("lean_and_mean") {
 config("nominmax") {
   defines = [ "NOMINMAX" ]
 }
+
+# Some binaries create PDBs larger than 4 GiB. Increasing the PDB page size
+# to 8 KiB allows 8 GiB PDBs. The larger page size also allows larger block maps
+# which is a PDB limit that was hit in https://crbug.com/1406510. The page size
+# can easily be increased in the future to allow even larger PDBs or larger
+# block maps.
+config("pdb_larger_than_4gb") {
+  if (!defined(ldflags)) {
+    ldflags = []
+  }
+  ldflags += [ "/pdbpagesize:8192" ]
+}
diff --git a/chrome/app/chromium_strings.grd b/chrome/app/chromium_strings.grd
index e548a4ea7d1cb..668c6ecc8187a 100644
--- a/chrome/app/chromium_strings.grd
+++ b/chrome/app/chromium_strings.grd
@@ -24,7 +24,7 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
     <output filename="chromium_strings_de.pak" type="data_package" lang="de" />
     <output filename="chromium_strings_el.pak" type="data_package" lang="el" />
     <output filename="chromium_strings_en-GB.pak" type="data_package" lang="en-GB" />
-    <output filename="chromium_strings_en-US.pak" type="data_package" lang="en" />
+    <output filename="chromium_strings_en-US.pak" type="data_package" lang="en-GB" />
     <output filename="chromium_strings_es.pak" type="data_package" lang="es" />
     <output filename="chromium_strings_es-419.pak" type="data_package" lang="es-419" />
     <output filename="chromium_strings_et.pak" type="data_package" lang="et" />
@@ -278,7 +278,7 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
 
       <!--
         Even though Google Chrome for Testing is a separate brand, there is
-        no separate file for it. Instead, we use the same file as Chromium, with
+        no separate file for it. Instead, we use the same file as Supermium, with
         a few select overrides for the most prominent end-user strings.
 
         Rationale: https://goo.gle/chrome-for-testing#bookmark=id.n1rat320av91
@@ -294,30 +294,30 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
         </then>
         <else>
           <message name="IDS_PRODUCT_NAME" desc="The Chrome application name" translateable="false">
-            Chromium
+            Supermium
           </message>
           <message name="IDS_SHORT_PRODUCT_NAME" desc="The Chrome application short name." translateable="false">
-            Chromium
+            Supermium
           </message>
         </else>
       </if>
       <if expr="is_win">
-        <message name="IDS_SXS_SHORTCUT_NAME" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_SXS_SHORTCUT_NAME" desc="Unused in Supermium builds" translateable="false">
         </message>
-        <message name="IDS_SHORTCUT_NAME_BETA" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_SHORTCUT_NAME_BETA" desc="Unused in Supermium builds" translateable="false">
         </message>
-        <message name="IDS_SHORTCUT_NAME_DEV" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_SHORTCUT_NAME_DEV" desc="Unused in Supermium builds" translateable="false">
         </message>
         <message name="IDS_PRODUCT_DESCRIPTION" desc="Browser description">
-          Chromium is a web browser that runs webpages and applications with lightning speed. It's fast, stable, and easy to use. Browse the web more safely with malware and phishing protection built into Chromium.
+          Supermium is a web browser that runs webpages and applications with lightning speed. It's fast, stable, and easy to use. Browse the web more safely with malware and phishing protection built into Supermium.
         </message>
         <message name="IDS_WELCOME_TO_CHROME" desc="Welcoming text announced via screen readers the first time Chrome is launched at the conclusion of installation.">
-          Welcome to Chromium; new browser window opened
+          Welcome to Supermium; new browser window opened
         </message>
       </if>
       <if expr="is_macosx or is_linux">
         <message name="IDS_FIRST_RUN_DIALOG_WINDOW_TITLE" desc="Window title of First Run dialog on Mac and Linux, displayed in title bar">
-          Welcome to Chromium
+          Welcome to Supermium
         </message>
       </if>
       <if expr="chromeos_ash">
@@ -331,8 +331,8 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
           ChromiumOS
         </message>
       </if>
-      <message name="IDS_PRODUCT_LOGO_ENTERPRISE_ALT_TEXT" desc="Alt text for the Chromium Enterprise logo image." formatter_data="android_java">
-        Chromium Enterprise logo
+      <message name="IDS_PRODUCT_LOGO_ENTERPRISE_ALT_TEXT" desc="Alt text for the Supermium Enterprise logo image." formatter_data="android_java">
+        Supermium Enterprise logo
       </message>
       <if expr="is_win">
         <message name="IDS_SHORTCUT_NEW_WINDOW" desc="The text label of the New window shortcut context menu entry as of Windows 8">
@@ -346,34 +346,34 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
       </if>
       <if expr="not is_macosx and not chromeos_ash">
         <message name="IDS_TASK_MANAGER_TITLE" desc="The title of the Task Manager window">
-          Task Manager - Chromium
+          Task Manager - Supermium
         </message>
       </if>
       <message name="IDS_SESSION_CRASHED_VIEW_UMA_OPTIN" desc="Text besides the checkbox to let users optin to UMA in the restore from previous crash bubble.">
-        Help make Chromium better by sending crash reports and <ph name="UMA_LINK">$1<ex>usage statistics</ex></ph> to Google
+        Help make Supermium better by sending crash reports and <ph name="UMA_LINK">$1<ex>usage statistics</ex></ph> to Google
       </message>
       <if expr="not chromeos_ash">
         <!-- Browser Window Title Format -->
         <message name="IDS_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for titles displayed in tabs and popup windows">
-          <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Chromium
+          <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Supermium
         </message>
       </if>
       <if expr="chromeos_ash">
         <!-- Browser Window Title Format -->
         <message name="IDS_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for titles displayed in tabbed browser windows">
-          Chromium - <ph name="PAGE_TITLE">$1<ex>Google</ex></ph>
+          Supermium - <ph name="PAGE_TITLE">$1<ex>Google</ex></ph>
         </message>
       </if>
       <if expr="not chromeos_ash and not is_macosx">
         <!-- Captive Portal Browser Window Title Format -->
         <message name="IDS_CAPTIVE_PORTAL_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for titles displayed in captive portal popup windows">
-          <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Network Sign-in - Chromium
+          <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Network Sign-in - Supermium
         </message>
       </if>
       <if expr="chromeos_ash">
         <!-- Captive Portal Browser Window Title Format -->
         <message name="IDS_CAPTIVE_PORTAL_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for titles displayed in captive portal popup windows">
-          Chromium - Network Sign-in - <ph name="PAGE_TITLE">$1<ex>Google</ex></ph>
+          Supermium - Network Sign-in - <ph name="PAGE_TITLE">$1<ex>Google</ex></ph>
         </message>
       </if>
       <if expr="is_macosx">
@@ -385,16 +385,16 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
       <!-- Accessible window title format - includes the channel, and the same
            on all browser platforms rather than different on ChromeOS. -->
       <message name="IDS_ACCESSIBLE_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for the accessible name of a tabbed browser window">
-        <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Chromium
+        <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Supermium
       </message>
       <message name="IDS_ACCESSIBLE_BETA_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for the accessible name of a tabbed browser window for the beta channel version of the browser">
-        <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Chromium Beta
+        <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Supermium Beta
       </message>
       <message name="IDS_ACCESSIBLE_DEV_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for the accessible name of a tabbed browser window for the developer (dev) channel version of the browser">
-        <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Chromium Dev
+        <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Supermium Dev
       </message>
       <message name="IDS_ACCESSIBLE_CANARY_BROWSER_WINDOW_TITLE_FORMAT" desc="The format for the accessible name of a tabbed browser window for the canary (nightly build) channel version of the browser">
-        <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Chromium Canary
+        <ph name="PAGE_TITLE">$1<ex>Google</ex></ph> - Supermium Canary
       </message>
       <if expr="_is_chrome_for_testing_branded">
         <then>
@@ -407,22 +407,22 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
         </then>
         <else>
           <message name="IDS_ABOUT_VERSION_COMPANY_NAME" desc="Company name on the about pages">
-            The Chromium Authors
+            The Supermium Authors
           </message>
           <message name="IDS_ABOUT_VERSION_COPYRIGHT" desc="Copyright information on the about pages">
-            Copyright <ph name="YEAR">{0,date,y}<ex>2016</ex></ph> The Chromium Authors. All rights reserved.
+            Copyright <ph name="YEAR">{0,date,y}<ex>2016</ex></ph> The Supermium Authors. All rights reserved.
           </message>
         </else>
       </if>
       <if expr="chromeos_ash">
-        <message name="IDS_ABOUT_CROS_VERSION_LICENSE" desc="Additional text displayed beneath the Chromium open source URLs for ChromeOS.">
+        <message name="IDS_ABOUT_CROS_VERSION_LICENSE" desc="Additional text displayed beneath the Supermium open source URLs for ChromeOS.">
           ChromiumOS is made possible by additional <ph name="BEGIN_LINK_CROS_OSS">&lt;a target="_blank" href="$1"&gt;</ph>open source software<ph name="END_LINK_CROS_OSS">&lt;/a&gt;</ph>.
         </message>
-        <message name="IDS_ABOUT_CROS_WITH_LINUX_VERSION_LICENSE" desc="Additional text displayed beneath the Chromium open source URLs for ChromeOS when Crostini is installed.">
+        <message name="IDS_ABOUT_CROS_WITH_LINUX_VERSION_LICENSE" desc="Additional text displayed beneath the Supermium open source URLs for ChromeOS when Crostini is installed.">
           ChromiumOS is made possible by additional <ph name="BEGIN_LINK_CROS_OSS">&lt;a target="_blank" href="$1"&gt;</ph>open source software<ph name="END_LINK_CROS_OSS">&lt;/a&gt;</ph>, as is <ph name="BEGIN_LINK_LINUX_OSS">&lt;a target="_blank" href="$2"&gt;</ph>Linux development environment<ph name="END_LINK_LINUX_OSS">&lt;/a&gt;</ph>.
         </message>
         <message name="IDS_ABOUT_SAFETY_INFORMATION" desc="The safety label in the About box." translateable="false">
-          Not used in Chromium. Placeholder to keep resource maps in sync.
+          Not used in Supermium. Placeholder to keep resource maps in sync.
         </message>
       </if>
       <if expr="_is_chrome_for_testing_branded">
@@ -433,89 +433,89 @@ If you update this file, be sure also to update google_chrome_strings.grd. -->
         </then>
         <else>
           <message name="IDS_ABOUT_TERMS_OF_SERVICE" desc="The terms of service label in the About box." translateable="false">
-            Not used in Chromium. Placeholder to keep resource maps in sync.
+            Not used in Supermium. Placeholder to keep resource maps in sync.
           </message>
         </else>
       </if>
       <if expr="is_macosx">
         <message name="IDS_MAC_10_13_OBSOLETE" desc="A message displayed on an at-launch infobar and About (Help) page warning the user that the OS version they are using will soon be or is already unsupported.">
-          To get future Chromium updates, you'll need macOS 10.15 or later. This computer is using macOS 10.13.
+          To get future Supermium updates, you'll need macOS 10.15 or later. This computer is using macOS 10.13.
         </message>
         <message name="IDS_MAC_10_14_OBSOLETE" desc="A message displayed on an at-launch infobar and About (Help) page warning the user that the OS version they are using will soon be or is already unsupported.">
-          To get future Chromium updates, you'll need macOS 10.15 or later. This computer is using macOS 10.14.
+          To get future Supermium updates, you'll need macOS 10.15 or later. This computer is using macOS 10.14.
         </message>
       </if>
       <if expr="is_win">
         <message name="IDS_WIN_XP_VISTA_OBSOLETE" desc="A message displayed on an at-launch infobar and about:help warning the user that the computer they are using is no longer supported.">
-          Chromium may not function correctly because it is no longer supported on Windows XP or Windows Vista
+          Supermium may not function correctly because it is no longer supported on Windows XP or Windows Vista
         </message>
       </if>
       <if expr="is_win">
         <message name="IDS_WIN_7_OBSOLETE" desc="A message displayed on an at-launch infobar and about:help warning the user that the computer they are using will soon be or is already unsupported.">
-                    To get future Chromium updates, you'll need Windows 10 or later. This computer is using Windows 7.
+                    To get future Supermium updates, you'll need Windows 10 or later. This computer is using Windows 7.
         </message>
       </if>
       <if expr="is_win">
         <message name="IDS_WIN_8_OBSOLETE" desc="A message displayed on an at-launch infobar and about:help warning the user that the computer they are using will soon be or is already unsupported.">
-                    To get future Chromium updates, you'll need Windows 10 or later. This computer is using Windows 8.
+                    To get future Supermium updates, you'll need Windows 10 or later. This computer is using Windows 8.
         </message>
       </if>
       <if expr="is_win">
         <message name="IDS_WIN_8_1_OBSOLETE" desc="A message displayed on an at-launch infobar and about:help warning the user that the computer they are using will soon be or is already unsupported.">
-                    To get future Chromium updates, you'll need Windows 10 or later. This computer is using Windows 8.1.
+                    To get future Supermium updates, you'll need Windows 10 or later. This computer is using Windows 8.1.
         </message>
       </if>
       <if expr="is_linux">
         <message name="IDS_LINUX_OBSOLETE" desc="A message displayed on an at-launch infobar and about:help warning the user that the OS version they are using is no longer supported.">
-          Chromium may not function correctly because it is no longer supported on this Linux distribution
+          Supermium may not function correctly because it is no longer supported on this Linux distribution
         </message>
       </if>
       <message name="IDS_ACCNAME_APP" desc="The accessible name for the app menu." translateable="false">
-        Chromium
+        Supermium
       </message>
       <!-- Hung Browser Detector -->
       <if expr="is_win">
         <message name="IDS_BROWSER_HUNGBROWSER_MESSAGE" desc="Content of the dialog box shown when the browser is hung">
-          Chromium is unresponsive. Relaunch now?
+          Supermium is unresponsive. Relaunch now?
         </message>
       </if>
       <!-- Sharing messages -->
       <message name="IDS_BROWSER_SHARING_CLICK_TO_CALL_DIALOG_HELP_TEXT_NO_DEVICES" desc="The label to be shown as a help text of the dialog when user click on a phone number, if there are no phones to choose from.">
-        To send a number from here to your Android phone, sign in to Chromium on both devices.
+        To send a number from here to your Android phone, sign in to Supermium on both devices.
       </message>
       <message name="IDS_BROWSER_SHARING_CLICK_TO_CALL_DIALOG_HELP_TEXT_NO_DEVICES_ORIGIN" desc="The label to be shown as a help text of the dialog when user click on a phone number, if there are no phones to choose from.">
-        To send a number from <ph name="ORIGIN">$1<ex>www.google.com</ex></ph> to your Android phone, sign in to Chromium on both devices.
+        To send a number from <ph name="ORIGIN">$1<ex>www.google.com</ex></ph> to your Android phone, sign in to Supermium on both devices.
       </message>
       <message name="IDS_BROWSER_SHARING_ERROR_DIALOG_TEXT_DEVICE_NOT_FOUND" desc="The text to be shown on the dialog when an error occurred because the device is not synced.">
-        Make sure you are signed in to Chromium on your <ph name="TARGET_DEVICE_NAME">$1<ex>Pixel XL</ex></ph> and then try sending again.
+        Make sure you are signed in to Supermium on your <ph name="TARGET_DEVICE_NAME">$1<ex>Pixel XL</ex></ph> and then try sending again.
       </message>
       <!-- Uninstall messages -->
       <if expr="is_win">
         <message name="IDS_UNINSTALL_CLOSE_APP" desc="Message to user when uninstall detects other app instance running">
-          Please close all Chromium windows and try again.
+          Please close all Supermium windows and try again.
         </message>
         <message name="IDS_UNINSTALL_VERIFY" desc="Message to confirm user wants to uninstall">
-          Are you sure you want to uninstall Chromium?
+          Are you sure you want to uninstall Supermium?
         </message>
-        <message name="IDS_UNINSTALL_CHROME" desc="The title of the Chromium uninstall dialog.">
-          Uninstall Chromium
+        <message name="IDS_UNINSTALL_CHROME" desc="The title of the Supermium uninstall dialog.">
+          Uninstall Supermium
         </message>
       </if>
       <message name="IDS_FR_CUSTOMIZE_DEFAULT_BROWSER" desc="Default browser checkbox label">
-        Make Chromium the default browser
+        Make Supermium the default browser
       </message>
       <if expr="use_titlecase">
         <message name="IDS_STATUS_TRAY_KEEP_CHROME_RUNNING_IN_BACKGROUND" desc="In Title Case: The checkbox in the status tray context menu that controls whether chrome keeps running in the background after the last window is closed">
-          Let Chromium Run in the Background
+          Let Supermium Run in the Background
         </message>
       </if>
       <if expr="not use_titlecase">
         <message name="IDS_STATUS_TRAY_KEEP_CHROME_RUNNING_IN_BACKGROUND" desc="The checkbox in the status tray context menu that controls whether chrome keeps running in the background after the last window is closed">
-          Let Chromium run in the background
+          Let Supermium run in the background
         </message>
       </if>
       <message name="IDS_CANT_WRITE_USER_DIRECTORY_SUMMARY" desc="Summary of problem displayed in dialog when we can't create a directory for this user.">
-Chromium cannot read and write to its data directory:
+Supermium cannot read and write to its data directory:
 
 <ph name="USER_DATA_DIRECTORY">$1<ex>C:\Documents and Settings\devint\Local Settings\Application Data\Google\Chrome</ex></ph>
       </message>
@@ -525,9 +525,9 @@ Chromium cannot read and write to its data directory:
         </message>
       </if>
       <message name="IDS_PROFILE_TOO_NEW_ERROR" desc="Error displayed on startup when the profile is from a newer version of the product and can not be read">
-Your profile can not be used because it is from a newer version of Chromium.
+Your profile can not be used because it is from a newer version of Supermium.
 
-Some features may be unavailable. Please specify a different profile directory or use a newer version of Chromium.
+Some features may be unavailable. Please specify a different profile directory or use a newer version of Supermium.
       </message>
       <message name="IDS_PREFERENCES_UNREADABLE_ERROR" desc="Error displayed on startup when user preferences file can not be read">
 Your preferences can not be read.
@@ -537,35 +537,35 @@ Some features may be unavailable and changes to preferences won't be saved.
       <message name="IDS_PREFERENCES_CORRUPT_ERROR" desc="Error displayed on startup when user preferences file can not be read">
 Your preferences file is corrupt or invalid.
 
-Chromium is unable to recover your settings.
+Supermium is unable to recover your settings.
       </message>
       <!-- Add account dialog -->
       <if expr="chromeos_ash">
         <message name="IDS_ACCOUNT_MANAGER_DIALOG_WELCOME_BODY_V2_WITH_GUEST_MODE" desc="Text body for the Welcome screen in ChromiumOS 'Add account' dialog.">
-If you want to use this account one-time only, you can use <ph name="GUEST_LINK_BEGIN">&lt;a id="guestModeLink" href="#"&gt;</ph>Guest mode<ph name="GUEST_LINK_END">&lt;/a&gt;</ph> in Chromium browser. If you want to add an account for someone else, <ph name="LINK_BEGIN">&lt;a target="_blank" id="newPersonLink" href="$1<ex>https://google.com/</ex>"&gt;</ph>add a new person<ph name="LINK_END">&lt;/a&gt;</ph> to your <ph name="DEVICE_TYPE">$2<ex>Chromebook</ex></ph>.
+If you want to use this account one-time only, you can use <ph name="GUEST_LINK_BEGIN">&lt;a id="guestModeLink" href="#"&gt;</ph>Guest mode<ph name="GUEST_LINK_END">&lt;/a&gt;</ph> in Supermium browser. If you want to add an account for someone else, <ph name="LINK_BEGIN">&lt;a target="_blank" id="newPersonLink" href="$1<ex>https://google.com/</ex>"&gt;</ph>add a new person<ph name="LINK_END">&lt;/a&gt;</ph> to your <ph name="DEVICE_TYPE">$2<ex>Chromebook</ex></ph>.
 
 Permissions you've already given to websites and apps may apply to this account. You can manage your Google Accounts in <ph name="SETTINGS_LINK_BEGIN">&lt;a id="osSettingsLink" href="$3<ex>https://google.com/</ex>"&gt;</ph>Settings<ph name="SETTINGS_LINK_END">&lt;/a&gt;</ph>.
         </message>
       </if>
       <!-- Crash Recovery Dialog -->
       <message name="IDS_CRASH_RECOVERY_TITLE" desc="Title of dialog shown when the browser crashes." translateable="false">
-        Chromium
+        Supermium
       </message>
       <if expr="is_win">
         <message name="IDS_CRASH_RECOVERY_CONTENT" desc="Text content telling the user the browser has crashed.">
-          Whoa! Chromium has crashed. Relaunch now?
+          Whoa! Supermium has crashed. Relaunch now?
         </message>
       </if>
       <!-- Password generation strings -->
       <message name="IDS_PASSWORD_GENERATION_PROMPT" desc="Autofill dropdown text describing password generation.">
-        Chromium will save this password in your Google Account. You wont have to remember it.
+        Supermium will save this password in your Google Account. You wont have to remember it.
       </message>
       <!-- Password manager onboarding strings -->
       <message name="IDS_PASSWORD_MANAGER_ONBOARDING_DETAILS_C" desc="The explanation text that is shown below the title in the password manager onboarding dialog.">
-        Chromium lets you know if your passwords are ever compromised
+        Supermium lets you know if your passwords are ever compromised
       </message>
       <message name="IDS_PASSWORD_MANAGER_TITLE_BRAND" desc="The product name used in the title of the password bubble." translateable="false">
-        Chromium
+        Supermium
       </message>
       <message name="IDS_PASSWORD_BUBBLES_PASSWORD_MANAGER_LINK_TEXT_SAVING_ON_DEVICE" desc="The text of the Google Password Manager links displayed on Password Manager bubbles footer when the credentials are stored only locally.">
         Password Manager
@@ -578,155 +578,155 @@ Permissions you've already given to websites and apps may apply to this account.
       </message>
       <if expr="is_macosx">
       <message name="IDS_PASSWORDS_AUTHENTICATION_PROMPT_PREFIX" desc="Text shown in the beginning of the OS-level user authentication prompt before performing a seneitive operation such as show passwords in plain text.">
-          Chromium is trying to <ph name="AUTHENTICATION_PURPOSE">$1<ex>show passwords</ex></ph>
+          Supermium is trying to <ph name="AUTHENTICATION_PURPOSE">$1<ex>show passwords</ex></ph>
         </message>
       </if>
       <if expr="is_win">
         <message name="IDS_PASSWORDS_PAGE_AUTHENTICATION_PROMPT" desc="Text for the dialog box that prompts the user for their OS account password before revealing plaintext passwords on the password page.">
-          Chromium is trying to show passwords. Type your Windows password to allow this.
+          Supermium is trying to show passwords. Type your Windows password to allow this.
         </message>
         <message name="IDS_PASSWORDS_PAGE_COPY_AUTHENTICATION_PROMPT" desc="Text for the dialog box that prompts the user for their OS account password before copying plaintext passwords into the clipboard.">
-          Chromium is trying to copy passwords. Type your Windows password to allow this.
+          Supermium is trying to copy passwords. Type your Windows password to allow this.
         </message>
         <message name="IDS_PASSWORDS_PAGE_EDIT_AUTHENTICATION_PROMPT" desc="Text for the dialog box that prompts the user for their OS account password before editing plaintext passwords on the password page.">
-          Chromium is trying to edit passwords. Type your Windows password to allow this.
+          Supermium is trying to edit passwords. Type your Windows password to allow this.
         </message>
         <message name="IDS_PASSWORDS_PAGE_EXPORT_AUTHENTICATION_PROMPT" desc="Text for the dialog box that prompts the user for their OS account password before exporting passwords to a file.">
-          Chromium wants to export your passwords. Type your Windows password to allow this.
+          Supermium wants to export your passwords. Type your Windows password to allow this.
         </message>
         <message name="IDS_PASSWORDS_PAGE_IMPORT_AUTHENTICATION_PROMPT" desc="Text for the dialog box that prompts the user for their OS account password before overriding passwords during Import.">
-          Chromium is trying to replace existing passwords. Type your Windows password to allow this.
+          Supermium is trying to replace existing passwords. Type your Windows password to allow this.
         </message>
         <message name="IDS_INSTALL_HIGHER_VERSION" desc="Error displayed when higher version already exists.">
-          This computer already has a more recent version of Chromium. If the software is not working, please uninstall Chromium and try again.
+          This computer already has a more recent version of Supermium. If the software is not working, please uninstall Supermium and try again.
         </message>
         <message name="IDS_INSTALL_FAILED" desc="Error displayed if installation fails due to some unknown error.">
-          Installation failed due to unspecified error. If Chromium is currently running, please close it and try again.
+          Installation failed due to unspecified error. If Supermium is currently running, please close it and try again.
         </message>
         <message name="IDS_SAME_VERSION_REPAIR_FAILED" desc="Error displayed if installation fails due to Chrome running.">
-          Can not install the same Chromium version that is currently running. Please close Chromium and try again.
+          Can not install the same Supermium version that is currently running. Please close Supermium and try again.
         </message>
         <message name="IDS_SETUP_PATCH_FAILED" desc="Error message when setup.exe fails to patch itself.">
-          Installation failed due to unspecified error. Please download Chromium again.
+          Installation failed due to unspecified error. Please download Supermium again.
         </message>
         <message name="IDS_INSTALL_OS_NOT_SUPPORTED" desc="Error displayed if OS is not supported">
-          Chromium requires Windows 10 or higher.
+          Supermium requires Windows 10 or higher.
         </message>
         <message name="IDS_INSTALL_OS_ERROR" desc="Error displayed when any Windows API call fails and we do not have more specific information.">
-          An operating system error occurred during installation. Please download Chromium again.
+          An operating system error occurred during installation. Please download Supermium again.
         </message>
         <message name="IDS_INSTALL_SINGLETON_ACQUISITION_FAILED" desc="Error displayed when the installer cannot run because another installer is already running.">
-          Another operation on Chromium is in progress. Please try again later.
+          Another operation on Supermium is in progress. Please try again later.
         </message>
         <message name="IDS_INSTALL_TEMP_DIR_FAILED" desc="Error displayed when we fail to create temporary directory during installation.">
           The installer couldn't create a temporary directory. Please check for free disk space and permission to install software.
         </message>
         <message name="IDS_INSTALL_UNCOMPRESSION_FAILED" desc="Error when when we can not uncompress installation archive.">
-          The installer failed to uncompress archive. Please download Chromium again.
+          The installer failed to uncompress archive. Please download Supermium again.
         </message>
         <message name="IDS_INSTALL_INVALID_ARCHIVE" desc="Error displayed when we can not open the installation archive.">
-          The installer archive is corrupted or invalid. Please download Chromium again.
+          The installer archive is corrupted or invalid. Please download Supermium again.
         </message>
         <message name="IDS_INSTALL_INSUFFICIENT_RIGHTS" desc="Error displayed when a non admin user tries to attempt system level install/uninstall.">
           You do not have appropriate rights for system-level install. Try running the installer again as Administrator.
         </message>
         <message name="IDS_INSTALL_EXISTING_VERSION_LAUNCHED" desc="A message shown to users who try to install Chrome in their user profile directory when their computer already has Chrome installed for all users. In this case, the installer silently launches the existing version of Chrome for all users rather than installing a second version of Chrome.">
-          Chromium is already installed for all users on your computer.
+          Supermium is already installed for all users on your computer.
         </message>
       </if>
       <!-- Options Dialog -->
       <if expr="is_win">
-        <message name="IDS_SHORTCUT_TOOLTIP" desc="Text for the hover-on tooltip for the Chromium shortcuts.">
+        <message name="IDS_SHORTCUT_TOOLTIP" desc="Text for the hover-on tooltip for the Supermium shortcuts.">
           Access the Internet
         </message>
         <message name="IDS_UNINSTALL_DELETE_PROFILE" desc="Text to show user to ask whether to delete all the profile data also during uninstallation.">
           Also delete your browsing data?
         </message>
-        <message name="IDS_UNINSTALL_SET_DEFAULT_BROWSER" desc="Text to ask whether to set another browser as default when Chromium is uninstalled.">
+        <message name="IDS_UNINSTALL_SET_DEFAULT_BROWSER" desc="Text to ask whether to set another browser as default when Supermium is uninstalled.">
           Change default browser to:
         </message>
         <message name="IDS_UNINSTALL_BUTTON_TEXT" desc="Label for uninstall button on Uninstall confirmation dialog.">
           Uninstall
         </message>
       </if>
-      <message name="IDS_DEFAULT_BROWSER_INFOBAR_TEXT" desc="Text to show in an infobar when Chromium is not the current default browser.">
-        Chromium isn't your default browser
+      <message name="IDS_DEFAULT_BROWSER_INFOBAR_TEXT" desc="Text to show in an infobar when Supermium is not the current default browser.">
+        Supermium isn't your default browser
       </message>
       <if expr="is_win">
         <!-- Try Chrome Toast Dialog -->
         <message name="IDS_TRY_TOAST_HEADING" desc="Top line of the try-chrome-again dialog">
-          There is a new version of Chromium available.
+          There is a new version of Supermium available.
         </message>
         <message name="IDS_TRY_TOAST_HEADING2" desc="Top line of the try-chrome-again dialog">
-          There's a new version of Chromium available, and it's faster than ever.
+          There's a new version of Supermium available, and it's faster than ever.
         </message>
         <message name="IDS_TRY_TOAST_HEADING3" desc="Top line of the try-chrome-again dialog">
-          There's a new, safer version of Chromium available.
+          There's a new, safer version of Supermium available.
         </message>
         <message name="IDS_TRY_TOAST_HEADING4" desc="Top line of the try-chrome-again dialog">
-          Chromium has been updated, but you haven't used it for at least 30 days.
+          Supermium has been updated, but you haven't used it for at least 30 days.
         </message>
         <message name="IDS_TRY_TOAST_HEADING_SKYPE" desc="Top line of the try-chrome-again dialog">
-          Chromium lets you click a phone number on the web and call it with Skype!
+          Supermium lets you click a phone number on the web and call it with Skype!
         </message>
       </if>
 
       <!-- Download Bubble Items -->
       <message name="IDS_DOWNLOAD_BUBBLE_DANGEROUS_FILE"
                desc="Message shown to the user to validate the download of a dangerous file.">
-        Chromium blocked this file because this type of file is dangerous
+        Supermium blocked this file because this type of file is dangerous
       </message>
       <message name="IDS_DOWNLOAD_BUBBLE_MALICIOUS_URL_BLOCKED"
                desc="Message shown to the user to validate the download when the download url is classified to lead to malware by the safebrowsing database.">
-        Chromium blocked this file because it is dangerous
+        Supermium blocked this file because it is dangerous
       </message>
       <message name="IDS_DOWNLOAD_BUBBLE_SUBPAGE_SUMMARY_UNKNOWN_SOURCE"
                desc="Summary of dangerous warning for a file (like an extension) from an unknown source.">
-        Extensions, apps, and themes from unknown sources can harm your device. Chromium recommends only installing them from the <ph name="IDS_EXTENSION_WEB_STORE_TITLE">$1<ex>Chrome Web Store</ex></ph>
+        Extensions, apps, and themes from unknown sources can harm your device. Supermium recommends only installing them from the <ph name="IDS_EXTENSION_WEB_STORE_TITLE">$1<ex>Chrome Web Store</ex></ph>
       </message>
       <message name="IDS_DOWNLOAD_BUBBLE_SUBPAGE_SUMMARY_MALWARE"
                desc="Subpage summary for malware warning for the user.">
-        Chromium blocked this file because it has malware
+        Supermium blocked this file because it has malware
       </message>
       <message name="IDS_DOWNLOAD_BUBBLE_SUBPAGE_SUMMARY_DEEP_SCANNING_PROMPT"
                        desc="Subpage summary of warning for Deep Scanning.">
-        Chromium recommends scanning this file because it may be dangerous
+        Supermium recommends scanning this file because it may be dangerous
       </message>
       <message name="IDS_DOWNLOAD_BUBBLE_SUBPAGE_SUMMARY_WARNING_BLOCKED_LEARN_MORE_LINK"
                desc="Text for the link to the help page about why Chromium blocks some downloaded files.">
-        Learn why Chromium blocks some downloads
+        Learn why Supermium blocks some downloads
       </message>
 
       <!-- Download Shelf Items -->
       <message name="IDS_DOWNLOAD_STATUS_CRX_INSTALL_RUNNING"
                desc="Message shown when a CRX has been downloaded and is being unpacked.">
-        Adding to Chromium...
+        Adding to Supermium...
       </message>
 
       <message name="IDS_PROMPT_DOWNLOAD_CHANGES_SETTINGS"
                desc="Message shown on the download shelf when the download is known to change settings in the browser in a malicious way.">
-        <ph name="FILE_NAME">$1<ex>bla.exe</ex></ph> may be dangerous, so Chromium has blocked it.
+        <ph name="FILE_NAME">$1<ex>bla.exe</ex></ph> may be dangerous, so Supermium has blocked it.
       </message>
 
       <message name="IDS_PROMPT_MALICIOUS_DOWNLOAD_URL"
          desc="Message shown to the user to validate the download when the download url is classified to lead to malware by the safebrowsing database.">
-        This file is dangerous, so Chromium has blocked it.
+        This file is dangerous, so Supermium has blocked it.
       </message>
       <message name="IDS_PROMPT_MALICIOUS_DOWNLOAD_CONTENT"
          desc="Message shown to the user to validate the download when the download content is classified to lead to malware by safebrowsing.">
-        <ph name="FILE_NAME">$1<ex>malware.exe</ex></ph> is dangerous, so Chromium has blocked it.
+        <ph name="FILE_NAME">$1<ex>malware.exe</ex></ph> is dangerous, so Supermium has blocked it.
       </message>
       <message name="IDS_BLOCK_REASON_DANGEROUS_DOWNLOAD"
          desc="Message shown to the user on chrome://downloads page to explain that this download is blocked because it is malware.">
-        This file is dangerous, so Chromium has blocked it.
+        This file is dangerous, so Supermium has blocked it.
       </message>
       <message name="IDS_BLOCK_REASON_UNWANTED_DOWNLOAD"
          desc="Message shown to the user on chrome://downloads page to explain that this download is blocked because it is unwanted sofware.">
-        This file may be dangerous, so Chromium has blocked it.
+        This file may be dangerous, so Supermium has blocked it.
       </message>
       <message name="IDS_BLOCK_REASON_PROMPT_FOR_SCANNING"
          desc="Message shown to the user on chrome://downloads page to explain that this download is recommended to be scanned.">
-        Chromium recommends scanning this file because it may be dangerous.
+        Supermium recommends scanning this file because it may be dangerous.
       </message>
 
       <!-- chrome://downloads page dangerous file description strings -->
@@ -758,31 +758,31 @@ Permissions you've already given to websites and apps may apply to this account.
       <!-- Abandon in-progress downloads confirmation dialog -->
       <if expr="not is_macosx">
         <message name="IDS_ABANDON_DOWNLOAD_DIALOG_BROWSER_MESSAGE" desc="Message on a dialog shown when the user closes the browser while one or more downloads are in progress. This string is shown on Windows, ChromeOS, and Linux, which all use 'Exit' to refer to closing a browser.">
-          Exit Chromium anyway?
+          Exit Supermium anyway?
         </message>
       </if>
       <if expr="is_macosx">
         <message name="IDS_ABANDON_DOWNLOAD_DIALOG_BROWSER_MESSAGE" desc="Mac OSX Only: Message on a dialog shown when the user closes the browser while one or more downloads are in progress. This string is shown on Mac OSX only, which uses 'Quit' to refer to closing a browser.">
-          Quit Chromium anyway?
+          Quit Supermium anyway?
         </message>
       </if>
 
       <!-- Quit all apps confirmation dialog -->
       <if expr="is_macosx">
         <message name="IDS_QUIT_WITH_APPS_TITLE" desc="Title for a notification explaining that Chrome is running in the background.">
-          Chromium is in background mode.
+          Supermium is in background mode.
         </message>
       </if>
 
       <!-- Google API keys info bar -->
       <message name="IDS_MISSING_GOOGLE_API_KEYS" desc="Message shown when Google API keys are missing. This message is followed by a 'Learn more' link.">
-        Google API keys are missing. Some functionality of Chromium will be disabled.
+        Google API keys are missing. Some functionality of Supermium will be disabled.
       </message>
 
       <if expr="enable_extensions">
         <!-- Extension installed bubble -->
         <message name="IDS_EXTENSION_INSTALLED_HEADING" desc="Title of the extension-installed bubble. Instructs that the extension was installed.">
-          <ph name="EXTENSION_NAME">$1<ex>Gmail Checker</ex></ph> has been added to Chromium
+          <ph name="EXTENSION_NAME">$1<ex>Gmail Checker</ex></ph> has been added to Supermium
         </message>
 
         <!-- Extension uninstall prompt -->
@@ -792,65 +792,65 @@ Permissions you've already given to websites and apps may apply to this account.
 
         <!-- Extension alerts. -->
         <message name="IDS_EXTENSION_ALERT_ITEM_BLOCKLISTED_MALWARE" desc="A statement that an extension has been newly blocklisted for malware.">
-          Chromium found that "<ph name="EXTENSION_NAME">$1<ex>Gmail Checker</ex></ph>" contains malware
+          Supermium found that "<ph name="EXTENSION_NAME">$1<ex>Gmail Checker</ex></ph>" contains malware
         </message>
         <message name="IDS_EXTENSIONS_ALERT_ITEM_BLOCKLISTED_MALWARE_TITLE" desc="A statement that multiple extension/apps have been newly blocklisted for malware.">
-          Chromium found that these items contain malware:
+          Supermium found that these items contain malware:
         </message>
       </if>
 
       <!-- Extension Safety Check Detail Page strings -->
       <message name="IDS_SAFETY_CHECK_EXTENSIONS_MALWARE" desc="The text explaining the reason for disabling extension. The extension in question contains malware.">
-        This extension contains malware and is unsafe. Remove it from Chromium so it can no longer see and change your data on sites you visit, including your personal info.
+        This extension contains malware and is unsafe. Remove it from Supermium so it can no longer see and change your data on sites you visit, including your personal info.
       </message>
       <message name="IDS_SAFETY_CHECK_EXTENSIONS_POLICY_VIOLATION" desc="The text explaining the reason for disabling extension. The extension in question violates Chrome Web Store policy.">
-        This extension violates the Chrome Web Store policy, and might be unsafe. Remove it from Chromium so it can no longer see and change your data on sites you visit, including your personal info.
+        This extension violates the Chrome Web Store policy, and might be unsafe. Remove it from Supermium so it can no longer see and change your data on sites you visit, including your personal info.
       </message>
       <message name="IDS_SAFETY_CHECK_EXTENSIONS_UNPUBLISHED" desc="The text explaining the reason for disabling extension. The extension in question was unpublished by the developer.">
-        This extension was unpublished by its developer, and might be unsafe. Remove it from Chromium so it can no longer see and change your data on sites you visit, including your personal info.
+        This extension was unpublished by its developer, and might be unsafe. Remove it from Supermium so it can no longer see and change your data on sites you visit, including your personal info.
       </message>
       <message name="IDS_EXTENSIONS_SAFETY_CHECK_PRIMARY_LABEL" desc="Alerts the user that the extension should be reviewed.">
-        Chromium recommends you review this extension
+        Supermium recommends you review this extension
       </message>
 
       <!-- chrome://settings/extensions page -->
       <message name="IDS_EXTENSIONS_ITEM_SHOW_ACCESS_REQUESTS_IN_TOOLBAR" desc="The label on the toggle to allow the extension to show site access requests in the toolbar.">
-        Allow extension to show access requests in the Chromium toolbar
+        Allow extension to show access requests in the Supermium toolbar
       </message>
-      <message name="IDS_EXTENSIONS_INCOGNITO_WARNING" desc="Warns the user that Chromium cannot prevent extensions from recording history in Incognito mode. Displayed in extensions management UI after an extension is selected to be run in Incognito mode.">
-        Warning: Chromium cannot prevent extensions from recording your browsing history. To disable this extension in Incognito mode, unselect this option.
+      <message name="IDS_EXTENSIONS_INCOGNITO_WARNING" desc="Warns the user that Supermium cannot prevent extensions from recording history in Incognito mode. Displayed in extensions management UI after an extension is selected to be run in Incognito mode.">
+        Warning: Supermium cannot prevent extensions from recording your browsing history. To disable this extension in Incognito mode, unselect this option.
       </message>
       <message name="IDS_EXTENSIONS_UNINSTALL" desc="The link for uninstalling extensions.">
-        Remove from Chromium
+        Remove from Supermium
       </message>
       <message name="IDS_EXTENSIONS_SHORTCUT_SCOPE_IN_CHROME" desc="The label to indicate that a shortcut will be triggerable only from within the Chrome application.">
-        In Chromium
+        In Supermium
       </message>
 
       <if expr="enable_extensions">
         <message name="IDS_EXTENSIONS_MULTIPLE_UNSUPPORTED_DISABLED_BODY" desc="Body of the dialog shown when multiple unsupported extensions have been disabled.">
-          To make Chromium safer, we disabled some extensions that aren't listed in the <ph name="IDS_EXTENSION_WEB_STORE_TITLE">$1<ex>Chrome Web Store</ex></ph> and may have been added without your knowledge.
+          To make Supermium safer, we disabled some extensions that aren't listed in the <ph name="IDS_EXTENSION_WEB_STORE_TITLE">$1<ex>Chrome Web Store</ex></ph> and may have been added without your knowledge.
         </message>
         <message name="IDS_EXTENSIONS_SINGLE_UNSUPPORTED_DISABLED_BODY" desc="Body of the dialog shown when a single unsupported extension has been disabled.">
-          To make Chromium safer, we disabled the following extension that isn't listed in the <ph name="IDS_EXTENSION_WEB_STORE_TITLE">$1<ex>Chrome Web Store</ex></ph> and may have been added without your knowledge.
+          To make Supermium safer, we disabled the following extension that isn't listed in the <ph name="IDS_EXTENSION_WEB_STORE_TITLE">$1<ex>Chrome Web Store</ex></ph> and may have been added without your knowledge.
         </message>
       </if>
 
       <!-- Main Chrome menu -->
       <message name="IDS_APPMENU_TOOLTIP" desc="The tooltip to show for the browser menu">
-        Customize and control Chromium
+        Customize and control Supermium
       </message>
 
       <message name="IDS_APPMENU_TOOLTIP_UPDATE_AVAILABLE" desc="The tooltip to show for the browser menu when an update is available">
-        Customize and control Chromium. Update is available.
+        Customize and control Supermium. Update is available.
       </message>
 
       <message name="IDS_APPMENU_TOOLTIP_ALERT" desc="The tooltip to show for the browser menu when a non-update alert is displayed">
-        Customize and control Chromium. Something needs your attention - click for details.
+        Customize and control Supermium. Something needs your attention - click for details.
       </message>
 
       <message name="IDS_OPEN_IN_CHROME" desc="The text label of the Open in Chrome menu item for the Hosted App app menu">
-        &amp;Open in Chromium
+        &amp;Open in Supermium
       </message>
 
       <if expr="use_titlecase and not chromeos_ash">
@@ -862,12 +862,12 @@ Permissions you've already given to websites and apps may apply to this account.
           </then>
           <else>
             <message name="IDS_ABOUT" desc="In Title Case: The text label of the About Chrome menu item">
-              About &amp;Chromium
+              About &amp;Supermium
             </message>
           </else>
         </if>
         <message name="IDS_RELAUNCH_TO_UPDATE" desc="In Title Case: The text label of the relaunch to update Chrome menu item">
-          Relaunch to Update &amp;Chromium
+          Relaunch to Update &amp;Supermium
         </message>
       </if>
       <if expr="not use_titlecase and not chromeos_ash">
@@ -879,17 +879,17 @@ Permissions you've already given to websites and apps may apply to this account.
           </then>
           <else>
             <message name="IDS_ABOUT" desc="The text label of the About Chrome menu item">
-              About &amp;Chromium
+              About &amp;Supermium
             </message>
           </else>
         </if>
         <message name="IDS_RELAUNCH_TO_UPDATE" desc="The text label of the relaunch to update Chrome menu item">
-          Relaunch to update &amp;Chromium
+          Relaunch to update &amp;Supermium
         </message>
       </if>
       <if expr="chromeos_ash">
         <message name="IDS_ABOUT" desc="The text label of the About Chrome menu item">
-          About &amp;Chromium
+          About &amp;Supermium
         </message>
         <message name="IDS_RELAUNCH_TO_UPDATE" desc="The text label of the relaunch to update ChromeOS menu item">
           Relaunch to update &amp;ChromiumOS
@@ -898,19 +898,19 @@ Permissions you've already given to websites and apps may apply to this account.
 
       <if expr="is_win or is_macosx or is_linux">
         <message name="IDS_RELAUNCH_TO_UPDATE_ALT" desc="Alternate text label of the relaunch to update Chrome menu item" translateable="false">
-        Not used in Chromium. Placeholder to keep resource maps in sync.
+        Not used in Supermium. Placeholder to keep resource maps in sync.
         </message>
       </if>
 
       <if expr="is_macosx">
         <message name="IDS_APP_MENU_PRODUCT_NAME" desc="The application's short name, used for the Mac's application menu, activity monitor, etc. This should be less than 16 characters. Example: Chrome, not Google Chrome." translateable="false">
-          Chromium
+          Supermium
         </message>
         <message name="IDS_HELPER_NAME" desc="The helper application's name.  Should contain the Chrome application name (IDS_PRODUCT_NAME). Example: Google Chrome Helper.">
-          Chromium Helper
+          Supermium Helper
         </message>
         <message name="IDS_SHORT_HELPER_NAME" desc="The helper application's short name, used for the Mac's application menu, activity monitor, etc. Example: Chrome Helper, not Google Chrome Helper.">
-          Chromium Helper
+          Supermium Helper
         </message>
       </if>
 
@@ -920,34 +920,34 @@ Permissions you've already given to websites and apps may apply to this account.
 
       <!-- Chrome sign-in page -->
       <message name="IDS_CHROME_SIGNIN_TITLE" desc="Title on the about:chrome-signin page" translateable="false">
-        Chromium
+        Supermium
       </message>
 
       <!-- DICE sign-in promo strings -->
       <message name="IDS_PROFILES_DICE_SYNC_PROMO" desc="Text describing the benefits of turning on Sync.">
-        Sync and personalize Chromium across your devices
+        Sync and personalize Supermium across your devices
       </message>
 
       <!-- One click sign-in infobar -->
       <if expr="not chromeos_ash">
         <message name="IDS_SYNC_WRONG_EMAIL" desc="Message shown when sync setup failed due to the user entering the wrong email address for sign-in.">
-          You were signed in to Chromium as <ph name="USER_EMAIL_ADDRESS">$1<ex>foo@gmail.com</ex></ph>. Please use the same account to sign in again.
+          You were signed in to Supermium as <ph name="USER_EMAIL_ADDRESS">$1<ex>foo@gmail.com</ex></ph>. Please use the same account to sign in again.
         </message>
         <message name="IDS_SYNC_USED_PROFILE_ERROR" desc="An error message shown when user tries to sign in to a profile that is used by other user name before.">
-          Someone previously signed in to Chromium on this computer as <ph name="ACCOUNT_EMAIL_LAST">$1<ex>user@example.com</ex></ph>. Please create a new Chromium user to keep your information separate.
+          Someone previously signed in to Supermium on this computer as <ph name="ACCOUNT_EMAIL_LAST">$1<ex>user@example.com</ex></ph>. Please create a new Supermium user to keep your information separate.
         </message>
       </if>
 
       <!-- Enterprise sign-in dialog -->
       <if expr="toolkit_views">
         <message name="IDS_ENTERPRISE_SIGNIN_TITLE" desc="The title of the dialog to confirm linking the browser profile with the signed-in enterprise account">
-          Link your Chromium data to this account?
+          Link your Supermium data to this account?
         </message>
         <message name="IDS_ENTERPRISE_SIGNIN_EXPLANATION_WITHOUT_PROFILE_CREATION" desc="The warning message displayed to an enterprise user about to link their profile to their Google account. This message is followed by a 'Learn more' link.">
-          You are signing in with a managed account and giving its administrator control over your Chromium profile. Your Chromium data, such as your apps, bookmarks, history, passwords, and other settings will become permanently tied to <ph name="USER_NAME">$1<ex>pat@example.com</ex></ph>. You will be able to delete this data via the Google Accounts Dashboard, but you will not be able to associate this data with another account. <ph name="LEARN_MORE">$2<ex>Learn more</ex></ph>
+          You are signing in with a managed account and giving its administrator control over your Supermium profile. Your Supermium data, such as your apps, bookmarks, history, passwords, and other settings will become permanently tied to <ph name="USER_NAME">$1<ex>pat@example.com</ex></ph>. You will be able to delete this data via the Google Accounts Dashboard, but you will not be able to associate this data with another account. <ph name="LEARN_MORE">$2<ex>Learn more</ex></ph>
         </message>
         <message name="IDS_ENTERPRISE_SIGNIN_EXPLANATION_WITH_PROFILE_CREATION" desc="The warning message displayed to an enterprise user about to link their profile to their Google account. Additionally notifies the user that they can create a new profile instead. This message is followed by a 'Learn more' link.">
-          You are signing in with a managed account and giving its administrator control over your Chromium profile. Your Chromium data, such as your apps, bookmarks, history, passwords, and other settings will become permanently tied to <ph name="USER_NAME">$1<ex>pat@example.com</ex></ph>. You will be able to delete this data via the Google Accounts Dashboard, but you will not be able to associate this data with another account. You can optionally create a new profile to keep your existing Chromium data separate. <ph name="LEARN_MORE">$2<ex>Learn more</ex></ph>
+          You are signing in with a managed account and giving its administrator control over your Supermium profile. Your Supermium data, such as your apps, bookmarks, history, passwords, and other settings will become permanently tied to <ph name="USER_NAME">$1<ex>pat@example.com</ex></ph>. You will be able to delete this data via the Google Accounts Dashboard, but you will not be able to associate this data with another account. You can optionally create a new profile to keep your existing Supermium data separate. <ph name="LEARN_MORE">$2<ex>Learn more</ex></ph>
         </message>
         <message name="IDS_ENTERPRISE_SIGNIN_WORK_PROFILE_TITLE" desc="The title of the dialog to confirm adding a new work profile with the signed-in enterprise account">
           Add Work Profile to this browser
@@ -959,11 +959,11 @@ Permissions you've already given to websites and apps may apply to this account.
           This work profile is completely separate from your personal profile.
         </message>
         <message name="IDS_ENTERPRISE_SIGNIN_WORK_PROFILE_EXPLANATION" desc="The warning message displayed to an enterprise user about to link their profile to their Google account. This message is followed by a 'Learn more' link.">
-          Any Chromium data that is generated during the use of this profile (such as the creation of bookmarks, history, passwords, and other settings) can be removed by the work profile administrator. <ph name="LEARN_MORE">$1<ex>Learn more</ex></ph>
+          Any Supermium data that is generated during the use of this profile (such as the creation of bookmarks, history, passwords, and other settings) can be removed by the work profile administrator. <ph name="LEARN_MORE">$1<ex>Learn more</ex></ph>
         </message>
         <!-- New one-click sign-in dialog contents for SAML support -->
         <message name="IDS_ONE_CLICK_SIGNIN_DIALOG_TITLE_NEW" desc="The title of the modal dialog window that opens when the user chooses to use one click sign-in.">
-          You're signed in to Chromium!
+          You're signed in to Supermium!
         </message>
         <message name="IDS_ONE_CLICK_SIGNIN_DIALOG_MESSAGE_NEW" desc="The message of the one click sign-in dialog.">
           You're signed in as <ph name="USER_EMAIL_ADDRESS">$1<ex>foo@gmail.com</ex></ph>. Now you can access your bookmarks, history, and other settings on all your signed in devices.
@@ -973,10 +973,10 @@ Permissions you've already given to websites and apps may apply to this account.
       <!-- about:browser-switch strings -->
       <if expr="toolkit_views and not chromeos_lacros and not chromeos_ash">
         <message name="IDS_ABOUT_BROWSER_SWITCH_DESCRIPTION_UNKNOWN_BROWSER" desc="Description shown while waiting for an alternative browser to open, when the browser name is not auto-detected">
-          Your system administrator has configured Chromium to open an alternative browser to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
+          Your system administrator has configured Supermium to open an alternative browser to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
         </message>
         <message name="IDS_ABOUT_BROWSER_SWITCH_DESCRIPTION_KNOWN_BROWSER" desc="Description shown while waiting for an alternative browser to open, when the browser name is auto-detected">
-          Your system administrator has configured Chromium to open <ph name="ALTERNATIVE_BROWSER_NAME">$2<ex>Internet Explorer</ex></ph> to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
+          Your system administrator has configured Supermium to open <ph name="ALTERNATIVE_BROWSER_NAME">$2<ex>Internet Explorer</ex></ph> to access <ph name="TARGET_URL_HOSTNAME">$1<ex>example.com</ex></ph>.
         </message>
       </if>
 
@@ -989,7 +989,7 @@ Permissions you've already given to websites and apps may apply to this account.
         </then>
         <else>
           <message name="IDS_NTP_CUSTOMIZE_BUTTON_LABEL" desc="Label for button on the New Tab Page that opens dialog to customize Chromium browser.">
-            Customize Chromium
+            Customize Supermium
           </message>
         </else>
       </if>
@@ -997,42 +997,42 @@ Permissions you've already given to websites and apps may apply to this account.
       <!-- Signin Email Confirmation tab modal dialog -->
       <if expr="not chromeos_ash">
         <message name="IDS_SIGNIN_EMAIL_CONFIRMATION_TITLE" desc="Title of the signin email confirmation tab modal dialog.">
-          <ph name="USER_EMAIL_ADDRESS">$1<ex>foo@gmail.com</ex></ph> was previously using Chromium
+          <ph name="USER_EMAIL_ADDRESS">$1<ex>foo@gmail.com</ex></ph> was previously using Supermium
         </message>
       </if>
 
       <if expr="not chromeos_ash and not is_android and not chromeos_lacros">
         <!-- Dice Web Signin Interception Bubble-->
         <message name="IDS_SIGNIN_DICE_WEB_INTERCEPT_CREATE_BUBBLE_TITLE" desc="Title of the web signin interception bubble">
-          Continue in a new Chromium profile?
+          Continue in a new Supermium profile?
         </message>
         <message name="IDS_SIGNIN_DICE_WEB_INTERCEPT_SWITCH_BUBBLE_TITLE" desc="Title for the profile switch interception bubble">
-          Switch to existing Chromium profile?
+          Switch to existing Supermium profile?
         </message>
         <message name="IDS_SIGNIN_DICE_WEB_INTERCEPT_SWITCH_BUBBLE_DESC" desc="Description for the profile switch interception bubble">
-          A Chromium profile with this account already exists
+          A Supermium profile with this account already exists
         </message>
         <message name="IDS_SIGNIN_DICE_WEB_INTERCEPT_CONSUMER_BUBBLE_DESC" desc="Body of the web signin interception bubble">
-          <ph name="EXISTING_USER">$1<ex>Elisa</ex></ph> is already signed in to this Chromium profile. To keep your browsing separate, Chromium can create your own profile for you.
+          <ph name="EXISTING_USER">$1<ex>Elisa</ex></ph> is already signed in to this Supermium profile. To keep your browsing separate, Supermium can create your own profile for you.
         </message>
           <message name="IDS_SIGNIN_DICE_WEB_INTERCEPT_CONSUMER_BUBBLE_DESC_MANAGED_DEVICE" desc="Body of the web signin interception bubble on a managed device">
-          <ph name="EXISTING_USER">$1<ex>Elisa</ex></ph> is already signed in to this Chromium profile. This will create a new Chromium profile for <ph name="USER_EMAIL_ADDRESS">$2<ex>foo@gmail.com</ex></ph>
+          <ph name="EXISTING_USER">$1<ex>Elisa</ex></ph> is already signed in to this Supermium profile. This will create a new Supermium profile for <ph name="USER_EMAIL_ADDRESS">$2<ex>foo@gmail.com</ex></ph>
         </message>
         <message name="IDS_SIGNIN_DICE_WEB_INTERCEPT_ENTERPRISE_BUBBLE_DESC_MANAGED_DEVICE" desc="Body of the web signin interception bubble when the new account is personal and the existing account is managed on a managed device">
-          This will create a new Chromium profile for <ph name="USER_EMAIL_ADDRESS">$1<ex>foo@gmail.com</ex></ph>
+          This will create a new Supermium profile for <ph name="USER_EMAIL_ADDRESS">$1<ex>foo@gmail.com</ex></ph>
         </message>
         <message name="IDS_SIGNIN_DICE_WEB_INTERCEPT_CONSUMER_BUBBLE_DESC_V2" desc="Body of the web signin interception bubble. It is shown when the user signs in on the web while they already have another account present in the current profile.">
-          Another account is already signed in. To keep your browsing separate, Chromium can create your own profile for you.
+          Another account is already signed in. To keep your browsing separate, Supermium can create your own profile for you.
         </message>
       </if>
 
       <if expr="not chromeos_ash and not is_android">
         <!-- Profile Customization Web UI -->
         <message name="IDS_PROFILE_CUSTOMIZATION_TEXT" desc="Text of the profile customization bubble">
-          Customize your new Chromium profile
+          Customize your new Supermium profile
         </message>
         <message name="IDS_PROFILE_CUSTOMIZATION_TITLE_V2" desc="Title of the profile customization dialog">
-          Customize your Chromium profile
+          Customize your Supermium profile
         </message>
       </if>
 
@@ -1055,21 +1055,21 @@ Permissions you've already given to websites and apps may apply to this account.
       <!-- App list -->
       <if expr="chromeos_ash">
         <message name="IDS_APP_LIST_EXTENSIONS_UNINSTALL" desc="Title text for the context menu item of a non-platform-app app list item that removes the app.">
-          Remove from Chromium...
+          Remove from Supermium...
         </message>
       </if>
 
       <!-- App shortcuts -->
-      <message name="IDS_APP_SHORTCUTS_SUBDIR_NAME" desc="Name for the Chromium Apps Start Menu folder name.">
-        Chromium Apps
+      <message name="IDS_APP_SHORTCUTS_SUBDIR_NAME" desc="Name for the Supermium Apps Start Menu folder name.">
+        Supermium Apps
       </message>
       <message name="IDS_APP_SHORTCUTS_SUBDIR_NAME_CANARY" desc="Name for the Chrome Apps Start Menu folder name.">
-        Chromium Apps
+        Supermium Apps
       </message>
       <if expr="is_win">
-        <message name="IDS_APP_SHORTCUTS_SUBDIR_NAME_BETA" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_APP_SHORTCUTS_SUBDIR_NAME_BETA" desc="Unused in Supermium builds" translateable="false">
         </message>
-        <message name="IDS_APP_SHORTCUTS_SUBDIR_NAME_DEV" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_APP_SHORTCUTS_SUBDIR_NAME_DEV" desc="Unused in Supermium builds" translateable="false">
         </message>
       </if>
 
@@ -1082,44 +1082,44 @@ Permissions you've already given to websites and apps may apply to this account.
 
       <!-- MediaStream capture status tray icon -->
       <message name="IDS_MEDIA_STREAM_STATUS_TRAY_TEXT_AUDIO_AND_VIDEO" desc="Tool tip for the capture status tray icon when microphone and camera are being used">
-        Chromium is using your camera and microphone.
+        Supermium is using your camera and microphone.
       </message>
       <message name="IDS_MEDIA_STREAM_STATUS_TRAY_TEXT_AUDIO_ONLY" desc="Tool tip for the capture status tray icon when microphone is being used">
-        Chromium is using your microphone.
+        Supermium is using your microphone.
       </message>
       <message name="IDS_MEDIA_STREAM_STATUS_TRAY_TEXT_VIDEO_ONLY" desc="Tool tip for the capture status tray icon when camera is being used">
-        Chromium is using your camera.
+        Supermium is using your camera.
       </message>
 
       <if expr="not is_android">
         <!-- WebHID system tray icon -->
         <message name="IDS_WEBHID_SYSTEM_TRAY_ICON_TITLE" desc="Title for the WebHID system tray icon">
             {NUM_DEVICES, plural,
-              =0 {1 HID device was being accessed by one or more Chromium extensions}
-              =1 {1 HID device is being accessed by one or more Chromium extensions}
-            other {# HID devices are being accessed by one or more Chromium extensions}}
+              =0 {1 HID device was being accessed by one or more Supermium extensions}
+              =1 {1 HID device is being accessed by one or more Supermium extensions}
+            other {# HID devices are being accessed by one or more Supermium extensions}}
         </message>
 
         <!-- WebUSB system tray icon -->
          <message name="IDS_WEBUSB_SYSTEM_TRAY_ICON_TITLE" desc="Title for the WebUSB system tray icon">
             {NUM_DEVICES, plural,
-              =0 {1 USB device was being accessed by one or more Chromium extensions}
-              =1 {1 USB device is being accessed by one or more Chromium extensions}
-            other {# USB devices are being accessed by one or more Chromium extensions}}
+              =0 {1 USB device was being accessed by one or more Supermium extensions}
+              =1 {1 USB device is being accessed by one or more Supermium extensions}
+            other {# USB devices are being accessed by one or more Supermium extensions}}
         </message>
       </if>
 
       <!-- ProcessSingleton -->
       <if expr="is_posix">
         <message name="IDS_PROFILE_IN_USE_POSIX" desc="Message shown when the browser cannot start because the profile is in use on a different host.">
-          The profile appears to be in use by another Chromium process (<ph name="PROCESS_ID">$1<ex>12345</ex></ph>) on another computer (<ph name="HOST_NAME">$2<ex>example.com</ex></ph>). Chromium has locked the profile so that it doesn't get corrupted. If you are sure no other processes are using this profile, you can unlock the profile and relaunch Chromium.
+          The profile appears to be in use by another Supermium process (<ph name="PROCESS_ID">$1<ex>12345</ex></ph>) on another computer (<ph name="HOST_NAME">$2<ex>example.com</ex></ph>). Supermium has locked the profile so that it doesn't get corrupted. If you are sure no other processes are using this profile, you can unlock the profile and relaunch Supermium.
         </message>
       </if>
 
       <!-- Mac First-run dialog messages -->
       <if expr="is_macosx">
         <message name="IDS_FIRSTRUN_DLG_MAC_SET_DEFAULT_BROWSER_LABEL" desc="Label for checkbox that sets the default browser">
-          Set Chromium as your default browser
+          Set Supermium as your default browser
         </message>
       </if>
 
@@ -1127,40 +1127,40 @@ Permissions you've already given to websites and apps may apply to this account.
       <if expr="not is_android and not chromeos_ash">
         <!-- User pod remove sync warning text -->
         <message name="IDS_LOGIN_POD_USER_REMOVE_WARNING_SYNC" desc="Main text shown as a warning when attempting to remove an user.">
-          This person's browsing data will be deleted from this device. To recover the data, sign in to Chromium as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
+          This person's browsing data will be deleted from this device. To recover the data, sign in to Supermium as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
         </message>
 
         <!-- Tutorial -->
         <message name="IDS_USER_MANAGER_TUTORIAL_SLIDE_INTRO_TITLE" desc="Title of the tutorial introduction slide">
-          Chromium just got better
+          Supermium just got better
         </message>
         <message name="IDS_USER_MANAGER_TUTORIAL_SLIDE_INTRO_TEXT" desc="Main text of the tutorial introduction slide">
-          Now it's easier to use Chromium with your Google Account and on shared computers.
+          Now it's easier to use Supermium with your Google Account and on shared computers.
         </message>
         <message name="IDS_USER_MANAGER_TUTORIAL_SLIDE_YOUR_CHROME_TITLE" desc="Title of the slide about personalizing the browser">
-          This is your Chromium
+          This is your Supermium
         </message>
         <message name="IDS_USER_MANAGER_TUTORIAL_SLIDE_YOUR_CHROME_TEXT" desc="Main text of the slide about personalizing the browser">
-          Your web, bookmarks, and other Chromium stuff live here.
+          Your web, bookmarks, and other Supermium stuff live here.
         </message>
         <message name="IDS_USER_MANAGER_TUTORIAL_SLIDE_GUEST_TEXT" desc="Main text of the guest user slide">
-          Guests can use Chromium without leaving anything behind.
+          Guests can use Supermium without leaving anything behind.
         </message>
         <message name="IDS_USER_MANAGER_TUTORIAL_SLIDE_FRIENDS_TEXT" desc="Main text of the friends and family slide">
-          If you share a computer, friends and family can browse separately and set up Chromium just the way they want.
+          If you share a computer, friends and family can browse separately and set up Supermium just the way they want.
         </message>
         <message name="IDS_USER_MANAGER_TUTORIAL_SLIDE_OUTRO_TEXT" desc="Main text of the tutorial completion slide">
-          Click your name to open Chromium and start browsing.
+          Click your name to open Supermium and start browsing.
         </message>
         <message name="IDS_USER_MANAGER_TUTORIAL_SLIDE_OUTRO_ADD_USER" desc="Text of the add a new user button">
-          Add yourself to Chromium
+          Add yourself to Supermium
         </message>
       </if>
 
       <if expr="not is_android">
         <!-- Password Manager Tutorial Strings -->
         <message name="IDS_TUTORIAL_PASSWORD_MANAGER_OPEN_APP_MENU" desc="The description of the 'open add menu' step in password manager tutorial">
-          Click the Chromium menu
+          Click the Supermium menu
         </message>
         <message name="IDS_TUTORIAL_PASSWORD_MANAGER_CLICK_PASSWORD_MANAGER" desc="The description of the 'click password manager' step in password manager tutorial">
           Click Password Manager
@@ -1175,72 +1175,72 @@ Permissions you've already given to websites and apps may apply to this account.
 
       <!-- Settings API bubble -->
       <message name="IDS_EXTENSIONS_SETTINGS_API_FIRST_LINE_START_PAGES_SPECIFIC" desc="Text displayed in the Settings API bubble as first line when an extension has changed the start pages, and we are pointing to its icon.">
-        This extension has changed what page is shown when you start Chromium.
+        This extension has changed what page is shown when you start Supermium.
       </message>
       <message name="IDS_EXTENSIONS_SETTINGS_API_FIRST_LINE_START_PAGES" desc="Text displayed in the Settings API bubble as first line when an extension has changed the start pages, and we are not pointing to its icon.">
-        The extension "<ph name="EXTENSION_NAME">$1<ex>AdBlock</ex></ph>" has changed what page is shown when you start Chromium.
+        The extension "<ph name="EXTENSION_NAME">$1<ex>AdBlock</ex></ph>" has changed what page is shown when you start Supermium.
       </message>
       <message name="IDS_EXTENSIONS_SETTINGS_API_SECOND_LINE_START_PAGES" desc="Second line in the Settings API bubble. Only shown if the secondary change by the extension was just the start pages. The triple single quotes are needed to preserve the space before and after the sentence which is needed when the language (Chrome is being translated to) uses space as word separator. Please preserve them, unless the language being translated to does not use space as word separator.">
-        ''' It also controls what page is shown when you start Chromium. '''
+        ''' It also controls what page is shown when you start Supermium. '''
       </message>
       <message name="IDS_EXTENSIONS_SETTINGS_API_SECOND_LINE_START_AND_HOME" desc="Second line in the Settings API bubble. Only shown if the secondary change by the extension was both the start page and the home page. See IDS_EXTENSIONS_SETTINGS_API_SECOND_LINE_START_PAGES for reason for triple quotes.">
-        ''' It also controls what page is shown when you start Chromium or click the Home button. '''
+        ''' It also controls what page is shown when you start Supermium or click the Home button. '''
       </message>
       <message name="IDS_EXTENSIONS_SETTINGS_API_SECOND_LINE_START_AND_SEARCH" desc="Second line in the Settings API bubble. Only shown if the secondary change by the extension was both the start page and the search engine. See IDS_EXTENSIONS_SETTINGS_API_SECOND_LINE_START_PAGES for reason for triple quotes.">
-        ''' It also controls what page is shown when you start Chromium or search from the Omnibox. '''
+        ''' It also controls what page is shown when you start Supermium or search from the Omnibox. '''
       </message>
 
       <!-- Webstore strings -->
       <message name="IDS_WEBSTORE_APP_DESCRIPTION" desc="Description for the WebStore app.">
-        Discover great apps, games, extensions and themes for Chromium.
+        Discover great apps, games, extensions and themes for Supermium.
       </message>
 
       <!-- Windows firewall rule strings. -->
       <if expr="is_win">
         <message name="IDS_INBOUND_MDNS_RULE_NAME" desc="The name of the firewall rule allowing inbound mDNS traffic.">
-          Chromium (mDNS-In)
+          Supermium (mDNS-In)
         </message>
-        <message name="IDS_INBOUND_MDNS_RULE_NAME_BETA" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_INBOUND_MDNS_RULE_NAME_BETA" desc="Unused in Supermium builds" translateable="false">
         </message>
-        <message name="IDS_INBOUND_MDNS_RULE_NAME_CANARY" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_INBOUND_MDNS_RULE_NAME_CANARY" desc="Unused in Supermium builds" translateable="false">
         </message>
-        <message name="IDS_INBOUND_MDNS_RULE_NAME_DEV" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_INBOUND_MDNS_RULE_NAME_DEV" desc="Unused in Supermium builds" translateable="false">
         </message>
         <message name="IDS_INBOUND_MDNS_RULE_DESCRIPTION" desc="The description of the firewall rule allowing inbound mDNS traffic.">
-          Inbound rule for Chromium to allow mDNS traffic.
+          Inbound rule for Supermium to allow mDNS traffic.
         </message>
-        <message name="IDS_INBOUND_MDNS_RULE_DESCRIPTION_BETA" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_INBOUND_MDNS_RULE_DESCRIPTION_BETA" desc="Unused in Supermium builds" translateable="false">
         </message>
-        <message name="IDS_INBOUND_MDNS_RULE_DESCRIPTION_CANARY" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_INBOUND_MDNS_RULE_DESCRIPTION_CANARY" desc="Unused in Supermium builds" translateable="false">
         </message>
-        <message name="IDS_INBOUND_MDNS_RULE_DESCRIPTION_DEV" desc="Unused in Chromium builds" translateable="false">
+        <message name="IDS_INBOUND_MDNS_RULE_DESCRIPTION_DEV" desc="Unused in Supermium builds" translateable="false">
         </message>
       </if>
 
       <if expr="not is_android">
-        <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Chromium.">
-          If an image doesnt have a useful description, Chromium will try to provide one for you. To create descriptions, images are sent to Google. You can turn this off in settings at any time.
+        <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Supermium.">
+          If an image doesnt have a useful description, Supermium will try to provide one for you. To create descriptions, images are sent to Google. You can turn this off in settings at any time.
         </message>
-        <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT_ONCE" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Chromium just once.">
-          If an image doesnt have a useful description, Chromium will try to provide one for you. To create descriptions, images are sent to Google.
+        <message name="IDS_CONTENT_CONTEXT_ACCESSIBILITY_LABELS_BUBBLE_TEXT_ONCE" desc="The text of a bubble that confirms users allows integrating the accessibility labels service of Google to Supermium just once.">
+          If an image doesnt have a useful description, Supermium will try to provide one for you. To create descriptions, images are sent to Google.
         </message>
         <message name="IDS_CONTENT_CONTEXT_SPELLING_BUBBLE_TEXT" desc="The text of a bubble that confirms users allows integrating the spelling service of Google to Chrome.">
           This uses the same spell checker that's used in Google search. Text you type in the browser is sent to Google. You can always change this behavior in settings.
         </message>
         <if expr="not use_titlecase">
           <message name="IDS_CONTENT_CONTEXT_OPENLINKNEWTAB_INAPP" desc="The name of the command to open a link in a newly created browser tab when the user is in an app window">
-            Open link in new Chromium &amp;tab
+            Open link in new Supermium &amp;tab
           </message>
           <message name="IDS_CONTENT_CONTEXT_OPENLINKOFFTHERECORD_INAPP" desc="The name of the command to open a link in an Incognito browser window when the user is in an app window">
-            Open link in Chromium inco&amp;gnito window
+            Open link in Supermium inco&amp;gnito window
           </message>
         </if>
         <if expr="use_titlecase">
           <message name="IDS_CONTENT_CONTEXT_OPENLINKNEWTAB_INAPP" desc="In Title Case: The name of the command to open a link in a newly created browser tab when the user is in an app window">
-            Open Link in New Chromium &amp;tab
+            Open Link in New Supermium &amp;tab
           </message>
           <message name="IDS_CONTENT_CONTEXT_OPENLINKOFFTHERECORD_INAPP" desc="In Title Case: The name of the command to open a link in an Incognito browser window when the user is in an app window">
-            Open Link in Chromium Inco&amp;gnito Window
+            Open Link in Supermium Inco&amp;gnito Window
           </message>
         </if>
       </if>
@@ -1248,13 +1248,13 @@ Permissions you've already given to websites and apps may apply to this account.
       <!-- Update Recommended dialog -->
       <if expr="not chromeos_ash">
         <message name="IDS_UPDATE_RECOMMENDED_DIALOG_TITLE" desc="The window title for the Update Recommended dialog.">
-          Relaunch Chromium
+          Relaunch Supermium
         </message>
         <message name="IDS_UPDATE_RECOMMENDED" desc="The main text of the Update Recommended dialog with a count of open Incognito windows.">
           {COUNT, plural,
-          =0 {A new update for Chromium is available and will be applied as soon as you relaunch.}
-          =1 {A new update for Chromium is available and will be applied as soon as you relaunch. Your Incognito window won't reopen.}
-          other {A new update for Chromium is available and will be applied as soon as you relaunch. Your # Incognito windows won't reopen.}}
+          =0 {A new update for Supermium is available and will be applied as soon as you relaunch.}
+          =1 {A new update for Supermium is available and will be applied as soon as you relaunch. Your Incognito window won't reopen.}
+          other {A new update for Supermium is available and will be applied as soon as you relaunch. Your # Incognito windows won't reopen.}}
         </message>
         <message name="IDS_RELAUNCH_AND_UPDATE" desc="The button in the Update Recommended dialog which updates and relaunches Chrome.">
           Relaunch
@@ -1274,61 +1274,61 @@ Permissions you've already given to websites and apps may apply to this account.
 
       <if expr="is_win or is_macosx or is_linux">
         <message name="IDS_UPDATE_RECOMMENDED_DIALOG_TITLE_ALT" desc="Alternate window title for the Update Recommended dialog." translateable="false">
-          Not used in Chromium. Placeholder to keep resource maps in sync.
+          Not used in Supermium. Placeholder to keep resource maps in sync.
         </message>
         <message name="IDS_UPDATE_RECOMMENDED_ALT" desc="Alternate main text of the Update Recommended dialog with a count of open Incognito windows." translateable="false">
-          Not used in Chromium. Placeholder to keep resource maps in sync.
+          Not used in Supermium. Placeholder to keep resource maps in sync.
         </message>
       </if>
 
       <!-- Update bubble -->
       <message name="IDS_REINSTALL_APP" desc="Text for the button the user clicks to reinstall the app.">
-        Reinstall Chromium
+        Reinstall Supermium
       </message>
       <if expr="use_titlecase">
         <message name="IDS_UPGRADE_BUBBLE_MENU_ITEM" desc="In Title Case: Text for the Chrome menu option replacing Update required.">
-          Chromium is Out of Date
+          Supermium is Out of Date
         </message>
       </if>
       <if expr="not use_titlecase">
         <message name="IDS_UPGRADE_BUBBLE_MENU_ITEM" desc="Text for the Chrome menu option replacing Update required.">
-          Chromium is out of date
+          Supermium is out of date
         </message>
       </if>
       <message name="IDS_UPGRADE_BUBBLE_TITLE" desc="Text for the title of the upgrade bubble view.">
-        Can't update Chromium
+        Can't update Supermium
       </message>
       <message name="IDS_UPGRADE_BUBBLE_TEXT" desc="Text for the upgrade bubble view full description.">
-        Chromium couldn't update to the latest version, so you're missing out on new features and security fixes.
+        Supermium couldn't update to the latest version, so you're missing out on new features and security fixes.
       </message>
 
       <!-- User menu errors -->
       <message name="IDS_SYNC_ERROR_USER_MENU_UPGRADE_BUTTON" desc="Button in the header of desktop user menu that prompts the user to update Chrome to fix the out-of-date Chrome client error.">
-        Update Chromium
+        Update Supermium
       </message>
 
       <!-- Sync errors. Android uses native UI to handle Sync settings -->
       <if expr="not is_android">
         <message name="IDS_SYNC_UPGRADE_CLIENT" desc="Message indicating client needs to be upgraded to the latest version.">
-          Update Chromium to start sync
+          Update Supermium to start sync
         </message>
         <message name="IDS_SYNC_UPGRADE_CLIENT_BUTTON" desc="Button indicating client needs to be upgraded to the latest version.">
-          Update Chromium
+          Update Supermium
         </message>
       </if>
 
       <!-- Upgrade recovery bubble -->
       <message name="IDS_RECOVERY_BUBBLE_TITLE" desc="Text for the title of the chrome recovery bubble view.">
-        Chromium is out of date
+        Supermium is out of date
       </message>
       <if expr="use_titlecase">
         <message name="IDS_RUN_RECOVERY" desc="In Title Case: Text for the button the user clicks to recover chromium and its updater.">
-          Update Chromium
+          Update Supermium
         </message>
       </if>
       <if expr="not use_titlecase">
         <message name="IDS_RUN_RECOVERY" desc="Text for the button the user clicks to recover chromium and its updater.">
-          Update Chromium
+          Update Supermium
         </message>
       </if>
       <message name="IDS_RECOVERY_BUBBLE_TEXT" desc="Text for the chrome recovery bubble view full description.">
@@ -1336,72 +1336,72 @@ Permissions you've already given to websites and apps may apply to this account.
       </message>
 
       <!-- Critical Notification bubble -->
-      <message name="IDS_CRITICAL_NOTIFICATION_TITLE" desc="The title for a bubble that appears when there is a critical update and Chromium must restart to install it. It counts down a timer and then Chromium automatically restarts.">
-        Chromium will restart in <ph name="REMAINING_TIME">$1<ex>1 minute, 7 seconds</ex></ph>
+      <message name="IDS_CRITICAL_NOTIFICATION_TITLE" desc="The title for a bubble that appears when there is a critical update and Supermium must restart to install it. It counts down a timer and then Supermium automatically restarts.">
+        Supermium will restart in <ph name="REMAINING_TIME">$1<ex>1 minute, 7 seconds</ex></ph>
       </message>
-      <message name="IDS_CRITICAL_NOTIFICATION_TITLE_ALTERNATE" desc="The title for a bubble that appears when there is a critical update and Chromium must restart to install it. The title was previously countng down to an automatic restart and now it has finished. Will only be seen if a web page stops the shutdown process.">
-        Please restart Chromium now
+      <message name="IDS_CRITICAL_NOTIFICATION_TITLE_ALTERNATE" desc="The title for a bubble that appears when there is a critical update and Supermium must restart to install it. The title was previously countng down to an automatic restart and now it has finished. Will only be seen if a web page stops the shutdown process.">
+        Please restart Supermium now
       </message>
-      <message name="IDS_CRITICAL_NOTIFICATION_TEXT" desc="Explanation text for the bubble that appears when there is a critical update and Chromium must restart to install it.">
-        A special security update for Chromium was just applied. Restart now and we'll restore your tabs.
+      <message name="IDS_CRITICAL_NOTIFICATION_TEXT" desc="Explanation text for the bubble that appears when there is a critical update and Supermium must restart to install it.">
+        A special security update for Supermium was just applied. Restart now and we'll restore your tabs.
       </message>
 
       <!-- Desktop Capture -->
       <message name="IDS_DESKTOP_MEDIA_PICKER_SOURCE_TYPE_TAB" desc="Text for the button on the window picker dialog, clicking which takes one to tab sharing">
-        Chromium Tab
+        Supermium Tab
       </message>
 
       <!-- Runtime permission strings -->
       <if expr="is_android">
         <message name="IDS_INFOBAR_MISSING_AR_CAMERA_PERMISSION_TEXT" desc="Text shown in an infobar when a website has requested access to augmented reality capabilities, but Chrome is missing the Android camera permission.">
-          Chromium needs permission to access your camera to create a 3D map of your surroundings
+          Supermium needs permission to access your camera to create a 3D map of your surroundings
         </message>
         <message name="IDS_INFOBAR_MISSING_CAMERA_PERMISSION_TEXT" desc="Text shown in an infobar when a website has requested access to the camera capabilities, but Chrome is missing the Android camera permission.">
-          Chromium needs permission to access your camera for this site
+          Supermium needs permission to access your camera for this site
         </message>
         <message name="IDS_INFOBAR_MISSING_MICROPHONE_PERMISSION_TEXT" desc="Text shown in an infobar when a website has requested access to the microphone capabilities, but Chrome is missing the Android microphone permission.">
-          Chromium needs permission to access your microphone for this site
+          Supermium needs permission to access your microphone for this site
         </message>
         <message name="IDS_INFOBAR_MISSING_MICROPHONE_CAMERA_PERMISSIONS_TEXT" desc="Text shown in an infobar when a website has requested access to the microphone and camera capabilities, but Chrome is missing the Android microphone and camera permissions.">
-          Chromium needs permission to access your camera and microphone for this site
+          Supermium needs permission to access your camera and microphone for this site
         </message>
         <message name="IDS_INFOBAR_MISSING_LOCATION_PERMISSION_TEXT" desc="Text shown in an infobar when a website has requested access to the location capabilities, but Chrome is missing the Android location permission.">
-          Chromium needs access to your location to share your location with this site
+          Supermium needs access to your location to share your location with this site
         </message>
         <message name="IDS_MISSING_STORAGE_PERMISSION_DOWNLOAD_EDUCATION_TEXT" desc="Text shown educating the user that Chrome is missing the Android storage permission, which is required to download files.">
-          Chromium needs storage access to download files
+          Supermium needs storage access to download files
         </message>
 
         <message name="IDS_MESSAGE_MISSING_AR_CAMERA_PERMISSION_TEXT" desc="Text shown in a prompt ui when a website has requested access to augmented reality capabilities, but Chrome is missing the Android camera permission.">
-          Chromium needs camera permission to create a 3D map of your surroundings
+          Supermium needs camera permission to create a 3D map of your surroundings
         </message>
         <message name="IDS_MESSAGE_MISSING_CAMERA_PERMISSION_TEXT" desc="Text shown in a prompt ui when a website has requested access to the camera capabilities, but Chrome is missing the Android camera permission.">
-          Chromium needs camera permission for this site
+          Supermium needs camera permission for this site
         </message>
         <message name="IDS_MESSAGE_MISSING_MICROPHONE_PERMISSION_TEXT" desc="Text shown in a prompt ui when a website has requested access to the microphone capabilities, but Chrome is missing the Android microphone permission.">
-          Chromium needs microphone permission for this site
+          Supermium needs microphone permission for this site
         </message>
         <message name="IDS_MESSAGE_MISSING_MICROPHONE_CAMERA_PERMISSIONS_TEXT" desc="Text shown in a prompt ui when a website has requested access to the microphone and camera capabilities, but Chrome is missing the Android microphone and camera permissions.">
-          Chromium needs camera and microphone permissions for this site
+          Supermium needs camera and microphone permissions for this site
         </message>
         <message name="IDS_MESSAGE_MISSING_LOCATION_PERMISSION_TEXT" desc="Text shown in a prompt ui when a website has requested access to the location capabilities, but Chrome is missing the Android location permission.">
-          Chromium needs location permission for this site
+          Supermium needs location permission for this site
         </message>
         <message name="IDS_MESSAGE_STORAGE_ACCESS_PERMISSION_TEXT" desc="Text shown educating the user that Chrome is missing the Android storage permission, which is required to download files.">
-          Chromium needs storage access permission to download files
+          Supermium needs storage access permission to download files
         </message>
       </if>
 
       <if  expr="is_macosx">
         <message name="IDS_RUNTIME_PERMISSION_OS_REASON_TEXT" desc="Text provided to the macOS permission dialog, explaining why Chrome needs to access a protected resource (e.g., camera, microphone).">
-          Once Chromium has access, websites will be able to ask you for access.
+          Once Supermium has access, websites will be able to ask you for access.
         </message>
       </if>
 
       <!-- OOBE -->
       <if expr="chromeos_ash">
         <message name="IDS_INSTALLING_UPDATE" desc="Label shown on the updates installation screen during OOBE">
-          Please wait while Chromium installs the latest system updates.
+          Please wait while Supermium installs the latest system updates.
         </message>
         <message name="IDS_EULA_SCREEN_ACCESSIBLE_TITLE" desc="Title to be spoken on opening the OOBE EULA screen">
           ChromiumOS terms
@@ -1410,15 +1410,15 @@ Permissions you've already given to websites and apps may apply to this account.
 
       <!-- Welcome page (chrome://welcome) strings -->
       <if expr="not chromeos_ash and not is_android">
-        <message name="IDS_WELCOME_HEADER" desc="A message which will appear as the header on the Welcome UI if the user has never run Chromium before.">
-          Welcome to Chromium
+        <message name="IDS_WELCOME_HEADER" desc="A message which will appear as the header on the Welcome UI if the user has never run Supermium before.">
+          Welcome to Supermium
         </message>
       </if>
 
       <!-- Native notifications for Windows 10 -->
       <if expr="is_win">
         <message name="IDS_WIN_NOTIFICATION_SETTINGS_CONTEXT_MENU_ITEM_NAME" desc="The name of the button in Windows Notification Center which leads to Chrome notification settings.">
-          Go to Chromium notification settings
+          Go to Supermium notification settings
         </message>
       </if>
       <!-- Relaunch notification bubble and dialog. -->
@@ -1426,116 +1426,116 @@ Permissions you've already given to websites and apps may apply to this account.
         <if expr="not chromeos_ash">
           <message name="IDS_RELAUNCH_RECOMMENDED_TITLE" desc="The title of a dialog that tells users that a browser relaunch is recommended for an update available for some number of days.">
             {0, plural,
-              =0 {A Chromium update is available}
-              =1 {A Chromium update is available}
-              other {A Chromium update has been available for # days}}
+              =0 {A Supermium update is available}
+              =1 {A Supermium update is available}
+              other {A Supermium update has been available for # days}}
           </message>
           <message name="IDS_RELAUNCH_RECOMMENDED_BODY" desc="The body text of a dialog that tells users that a browser relaunch is recommended for an update with Incognito counter.">
              {COUNT, plural,
-              =0 {Your administrator asks that you relaunch Chromium to apply this update}
-              =1 {Your administrator asks that you relaunch Chromium to apply this update. Your Incognito window won't reopen.}
-              other {Your administrator asks that you relaunch Chromium to apply this update. Your # Incognito windows won't reopen.}}
+              =0 {Your administrator asks that you relaunch Supermium to apply this update}
+              =1 {Your administrator asks that you relaunch Supermium to apply this update. Your Incognito window won't reopen.}
+              other {Your administrator asks that you relaunch Supermium to apply this update. Your # Incognito windows won't reopen.}}
           </message>
           <message name="IDS_RELAUNCH_REQUIRED_TITLE_DAYS" desc="The title of a dialog that tells users the browser must be relaunched within two or more days.">
             {0, plural,
-              =1 {Relaunch Chromium within a day}
-              other {Relaunch Chromium within # days}}
+              =1 {Relaunch Supermium within a day}
+              other {Relaunch Supermium within # days}}
           </message>
           <message name="IDS_RELAUNCH_REQUIRED_TITLE_HOURS" desc="The title of a dialog that tells users the browser must be relaunched within one or more hours.">
             {0, plural,
-              =1 {Chromium will relaunch in an hour}
-              other {Chromium will relaunch in # hours}}
+              =1 {Supermium will relaunch in an hour}
+              other {Supermium will relaunch in # hours}}
           </message>
           <message name="IDS_RELAUNCH_REQUIRED_TITLE_MINUTES" desc="The title of a dialog that tells users the browser must be relaunched within one or more minutes.">
             {0, plural,
-              =1 {Chromium will relaunch in 1 minute}
-              other {Chromium will relaunch in # minutes}}
+              =1 {Supermium will relaunch in 1 minute}
+              other {Supermium will relaunch in # minutes}}
           </message>
           <message name="IDS_RELAUNCH_REQUIRED_TITLE_SECONDS" desc="The title of a dialog that tells users the browser must be relaunched within some number of seconds.">
             {0, plural,
-              =0 {Chromium will relaunch now}
-              =1 {Chromium will relaunch in 1 second}
-              other {Chromium will relaunch in # seconds}}
+              =0 {Supermium will relaunch now}
+              =1 {Supermium will relaunch in 1 second}
+              other {Supermium will relaunch in # seconds}}
           </message>
           <message name="IDS_RELAUNCH_REQUIRED_BODY" desc="The body text of a dialog that tells users the browser must be relaunched with Incognito counter.">
              {COUNT, plural,
-              =0 {Your administrator requires that you relaunch Chromium to apply an update}
-              =1 {Your administrator requires that you relaunch Chromium to apply an update. Your Incognito window won't reopen.}
-              other {Your administrator requires that you relaunch Chromium to apply an update. Your # Incognito windows won't reopen.}}
+              =0 {Your administrator requires that you relaunch Supermium to apply an update}
+              =1 {Your administrator requires that you relaunch Supermium to apply an update. Your Incognito window won't reopen.}
+              other {Your administrator requires that you relaunch Supermium to apply an update. Your # Incognito windows won't reopen.}}
           </message>
         </if>
       </if>
-      <!-- Chromium launch blocking dialog. -->
+      <!-- Supermium launch blocking dialog. -->
       <if expr="not is_android and not chromeos_ash">
-         <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_TOOLTIP" desc="The information message of Chromium launch blocking dialog for machine level user cloud policy enrollment.">
-          Launching Chromium...
+         <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_TOOLTIP" desc="The information message of Supermium launch blocking dialog for machine level user cloud policy enrollment.">
+          Launching Supermium...
         </message>
-        <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_ERROR" desc="The error message of Chromium launch blocking dialog when machine level user cloud policy enrollment failed.">
-          Couldn't launch Chromium. Try again.
+        <message name="IDS_ENTERPRISE_STARTUP_CLOUD_POLICY_ENROLLMENT_ERROR" desc="The error message of Supermium launch blocking dialog when machine level user cloud policy enrollment failed.">
+          Couldn't launch Supermium. Try again.
         </message>
-        <message name="IDS_ENTERPRISE_STARTUP_RELAUNCH_BUTTON" desc="The text of relaunch button of Chromium launch blocking dialog.">
-          Relaunch Chromium
+        <message name="IDS_ENTERPRISE_STARTUP_RELAUNCH_BUTTON" desc="The text of relaunch button of Supermium launch blocking dialog.">
+          Relaunch Supermium
         </message>
       </if>
       <message name="IDS_DESKTOP_MEDIA_PICKER_TITLE_WEB_CONTENTS_ONLY" desc="Title for the window picker dialog shown when desktop capture of a tab is requested by an app.">
-        Share a Chromium tab
+        Share a Supermium tab
       </message>
       <!-- Idle timeout bubble. -->
       <if expr="toolkit_views">
         <message name="IDS_IDLE_BUBBLE_TITLE_CLOSE" desc="Title of a bubble that informs the user that Chrome closed automatically, because they were away from the computer for X minutes.">
-          Chromium was automatically closed
+          Supermium was automatically closed
         </message>
         <message name="IDS_IDLE_BUBBLE_BODY_CLOSE_AND_CLEAR" desc="Body of a bubble that informs the user that Chromium closed + cleared data automatically, because they were away from the computer for X minutes.">
-          Your organization closes Chromium when it isn't used for <ph name="TIMEOUT_DURATION">$1<ex>30 minutes</ex></ph>. Browsing data was deleted. This could include history, autofill, and downloads.
+          Your organization closes Supermium when it isn't used for <ph name="TIMEOUT_DURATION">$1<ex>30 minutes</ex></ph>. Browsing data was deleted. This could include history, autofill, and downloads.
         </message>
         <message name="IDS_IDLE_BUBBLE_BODY_CLEAR" desc="Body of a bubble that informs the user that Chromium cleared data automatically, because they were away from the computer for X minutes.">
-          Your organization deletes Chromium data when it isn't used for <ph name="TIMEOUT_DURATION">$1<ex>30 minutes</ex></ph>. This could include history, autofill, and downloads.
+          Your organization deletes Supermium data when it isn't used for <ph name="TIMEOUT_DURATION">$1<ex>30 minutes</ex></ph>. This could include history, autofill, and downloads.
         </message>
         <message name="IDS_IDLE_BUBBLE_BODY_CLOSE" desc="Body of a bubble that informs the user that Chromium closed automatically, because they were away from the computer for X minutes.">
-          Your organization closes Chromium when it isn't used for <ph name="TIMEOUT_DURATION">$1<ex>30 minutes</ex></ph>.
+          Your organization closes Supermium when it isn't used for <ph name="TIMEOUT_DURATION">$1<ex>30 minutes</ex></ph>.
         </message>
       </if>
       <!-- Idle timeout dialog. -->
       <if expr="not is_android and not is_chromeos">
         <message name="IDS_IDLE_TIMEOUT_CLOSE_TITLE" desc="Title of the Idle Timeout dialog, warning the user that their windows are about to close.">
-          Chromium will soon close
+          Supermium will soon close
         </message>
         <message name="IDS_IDLE_TIMEOUT_CLEAR_TITLE" desc="Title of the Idle Timeout dialog, warning the user that their browsing data will be lost soon.">
-          Chromium will soon delete browsing data
+          Supermium will soon delete browsing data
         </message>
         <message name="IDS_IDLE_TIMEOUT_CLOSE_AND_CLEAR_TITLE" desc="Title of the Idle Timeout dialog, warning the user that their windows are about to close and their browsing data will be lost.">
-          Chromium will soon close and delete data
+          Supermium will soon close and delete data
         </message>
-        <message name="IDS_IDLE_TIMEOUT_CLOSE_BODY" desc="First sentence in the Idle Timeout dialog, warning the user that Chromium is going to close automatically.">
+        <message name="IDS_IDLE_TIMEOUT_CLOSE_BODY" desc="First sentence in the Idle Timeout dialog, warning the user that Supermium is going to close automatically.">
           {COUNT, plural,
-          =1 {Your organization automatically closes Chromium when it isn't used for 1 minute.}
-          other {Your organization automatically closes Chromium when it isn't used for # minutes.}}
+          =1 {Your organization automatically closes Supermium when it isn't used for 1 minute.}
+          other {Your organization automatically closes Supermium when it isn't used for # minutes.}}
         </message>
-        <message name="IDS_IDLE_TIMEOUT_CLEAR_BODY" desc="First sentence in the Idle Timeout dialog, warning the user that Chromium is going to clear data automatically.">
+        <message name="IDS_IDLE_TIMEOUT_CLEAR_BODY" desc="First sentence in the Idle Timeout dialog, warning the user that Supermium is going to clear data automatically.">
           {COUNT, plural,
-          =1 {Your organization automatically deletes browsing data when Chromium isn't used for 1 minute. This could include history, autofill, and downloads. Your tabs will stay open.}
-          other {Your organization automatically deletes browsing data when Chromium isn't used for # minutes. This could include history, autofill, and downloads. Your tabs will stay open.}}
+          =1 {Your organization automatically deletes browsing data when Supermium isn't used for 1 minute. This could include history, autofill, and downloads. Your tabs will stay open.}
+          other {Your organization automatically deletes browsing data when Supermium isn't used for # minutes. This could include history, autofill, and downloads. Your tabs will stay open.}}
         </message>
-        <message name="IDS_IDLE_TIMEOUT_CLOSE_AND_CLEAR_BODY" desc="First sentence in the Idle Timeout dialog, warning the user that Chromium is going to close and clear data automatically.">
+        <message name="IDS_IDLE_TIMEOUT_CLOSE_AND_CLEAR_BODY" desc="First sentence in the Idle Timeout dialog, warning the user that Supermium is going to close and clear data automatically.">
           {COUNT, plural,
-          =1 {Your organization automatically closes Chromium when it isn't used for 1 minute. Browsing data is deleted. This could include history, autofill, and downloads.}
-          other {Your organization automatically closes Chromium when it isn't used for # minutes. Browsing data is deleted. This could include history, autofill, and downloads.}}
+          =1 {Your organization automatically closes Supermium when it isn't used for 1 minute. Browsing data is deleted. This could include history, autofill, and downloads.}
+          other {Your organization automatically closes Supermium when it isn't used for # minutes. Browsing data is deleted. This could include history, autofill, and downloads.}}
         </message>
         <message name="IDS_IDLE_DISMISS_BUTTON" desc="Button label in the Idle Timeout dialog, this button dismisses the dialog and prevents browsers from closing automatically.">
-          Continue using Chromium
+          Continue using Supermium
         </message>
       </if>
       <!-- User happiness tracking survey UI -->
       <if expr="not is_android">
         <message name="IDS_HATS_BUBBLE_TITLE" translateable="false" desc="The title of Happiness Tracking Survey's invitation banner, it invites users to take a survey">
-          Help us improve Chromium
+          Help us improve Supermium
         </message>
       </if>
 
       <!-- Chrome parent extension/app install blocking dialog. -->
       <if expr="enable_extensions and enable_supervised_users">
         <message name="IDS_EXTENSION_PERMISSIONS_BLOCKED_BY_PARENT_PROMPT_MESSAGE" desc="Text for the dialog indicating that a parent has blocked extensions and apps.">
-         Your parent has turned off "Permissions for sites, apps and extensions" for Chromium
+         Your parent has turned off "Permissions for sites, apps and extensions" for Supermium
         </message>
       </if>
 
@@ -1543,75 +1543,75 @@ Permissions you've already given to websites and apps may apply to this account.
         <!-- Profile Picker -->
         <if expr="chromeos_lacros">
           <message name="IDS_PROFILE_PICKER_MAIN_VIEW_SUBTITLE_LACROS" desc="Profile picker main view subtitle">
-            With Chromium profiles you can separate all of your Chromium stuff. This makes it easier to split between work and fun.
+            With Supermium profiles you can separate all of your Supermium stuff. This makes it easier to split between work and fun.
           </message>
           <message name="IDS_PROFILE_PICKER_PROFILE_CREATION_FLOW_PROFILE_TYPE_CHOICE_SUBTITLE_LACROS" desc="Profile picker profile type choice subtitle">
-            To access your Chromium browser stuff across all your devices, sign in, then turn on sync
+            To access your Supermium browser stuff across all your devices, sign in, then turn on sync
           </message>
           <message name="IDS_PROFILE_PICKER_PROFILE_CREATION_FLOW_ACCOUNT_SELECTION_LACROS_SUBTITLE" desc="Profile picker, account selection screen subtitle">
-            Sign in to Chromium
+            Sign in to Supermium
           </message>
           <message name="IDS_PROFILE_PICKER_PROFILE_CREATION_FLOW_ACCOUNT_SELECTION_LACROS_SUBTITLE_WITH_GUEST" desc="Profile picker, account selection screen subtitle">
-            Sign in to Chromium. If you want to sign in an account one-time only, you can <ph name="GUEST_LINK_BEGIN">&lt;a id="guestModeLink" href="#"&gt;</ph>use the device as guest<ph name="GUEST_LINK_END">&lt;/a&gt;</ph>.
+            Sign in to Supermium. If you want to sign in an account one-time only, you can <ph name="GUEST_LINK_BEGIN">&lt;a id="guestModeLink" href="#"&gt;</ph>use the device as guest<ph name="GUEST_LINK_END">&lt;/a&gt;</ph>.
           </message>
         </if>
         <if expr="not chromeos_lacros">
           <message name="IDS_PROFILE_PICKER_MAIN_VIEW_TITLE" desc="Profile picker main view title">
-            Welcome to Chromium profiles
+            Welcome to Supermium profiles
           </message>
-          <message name="IDS_PROFILE_PICKER_MAIN_VIEW_TITLE_V2" desc="Title of a screen that lets the user choose which profile to use when browsing the web. *If the EN source doesn't translate well in your language, an alternative string 'Which Chromium profile would you like to use?' may be used instead">
-            Who's using Chromium?
+          <message name="IDS_PROFILE_PICKER_MAIN_VIEW_TITLE_V2" desc="Title of a screen that lets the user choose which profile to use when browsing the web. *If the EN source doesn't translate well in your language, an alternative string 'Which Supermium profile would you like to use?' may be used instead">
+            Who's using Supermium?
           </message>
           <message name="IDS_PROFILE_PICKER_MAIN_VIEW_SUBTITLE" desc="Profile picker main view subtitle">
-            With Chromium profiles you can separate all your Chromium stuff. Create profiles for friends and family, or split between work and fun.
+            With Supermium profiles you can separate all your Supermium stuff. Create profiles for friends and family, or split between work and fun.
           </message>
           <message name="IDS_PROFILE_PICKER_PROFILE_CREATION_FLOW_PROFILE_TYPE_CHOICE_SUBTITLE" desc="Profile picker profile type choice subtitle">
-            To access your Chromium stuff across all your devices, sign in, then turn on sync.
+            To access your Supermium stuff across all your devices, sign in, then turn on sync.
           </message>
         </if>
         <message name="IDS_PROFILE_PICKER_PROFILE_CREATION_FLOW_PROFILE_TYPE_CHOICE_TITLE" desc="Profile picker profile type choice title">
-          Set up your new Chromium profile
+          Set up your new Supermium profile
         </message>
         <message name="IDS_PROFILE_PICKER_IPH_FOR_PROFILES_TEXT" desc="Text of the IPH bubble for introducing profiles.">
-          Each profile holds its own Chromium info like bookmarks, history, passwords, and more
+          Each profile holds its own Supermium info like bookmarks, history, passwords, and more
         </message>
         <message name="IDS_PROFILE_PICKER_IPH_FOR_ADD_PROFILE_TEXT" desc="Text of the IPH bubble for adding new profiles.">
-          If you share a device, friends and family can browse separately and set up Chromium just the way they want
+          If you share a device, friends and family can browse separately and set up Supermium just the way they want
         </message>
         <message name="IDS_PROFILE_PICKER_PROFILE_SWITCH_TITLE" desc="Profile picker profile switch title">
-          Switch to existing Chromium profile?
+          Switch to existing Supermium profile?
         </message>
         <message name="IDS_PROFILE_PICKER_PROFILE_SWITCH_SUBTITLE" desc="Profile picker profile switch subtitle">
-          A Chromium profile with this account already exists on this device
+          A Supermium profile with this account already exists on this device
         </message>
 
         <!-- First Run Experience -->
         <if expr="chromeos_lacros">
-          <message name="IDS_PRIMARY_PROFILE_FIRST_RUN_TITLE" desc="Title of the landing screen in first run experience for the primary profile. The screen promotes Chromium sync.">
-            Welcome to Chromium, <ph name="ACCOUNT_FIRST_NAME">$1<ex>Jane</ex></ph>
+          <message name="IDS_PRIMARY_PROFILE_FIRST_RUN_TITLE" desc="Title of the landing screen in first run experience for the primary profile. The screen promotes Supermium sync.">
+            Welcome to Supermium, <ph name="ACCOUNT_FIRST_NAME">$1<ex>Jane</ex></ph>
           </message>
-          <message name="IDS_PRIMARY_PROFILE_FIRST_RUN_NO_NAME_TITLE" desc="Title of the screen shown when the user runs Chromium for the first time. A simple, generic welcome message.">
-            Welcome to Chromium
+          <message name="IDS_PRIMARY_PROFILE_FIRST_RUN_NO_NAME_TITLE" desc="Title of the screen shown when the user runs Supermium for the first time. A simple, generic welcome message.">
+            Welcome to Supermium
           </message>
-          <message name="IDS_PRIMARY_PROFILE_FIRST_RUN_SUBTITLE" desc="Subtitle of the landing screen in first run experience for the primary profile. The screen promotes Chromium sync.">
-            Get your Chromium browser stuff from <ph name="ACCOUNT_EMAIL">$1<ex>Jane.Doe@gmail.com</ex></ph>
+          <message name="IDS_PRIMARY_PROFILE_FIRST_RUN_SUBTITLE" desc="Subtitle of the landing screen in first run experience for the primary profile. The screen promotes Supermium sync.">
+            Get your Supermium browser stuff from <ph name="ACCOUNT_EMAIL">$1<ex>Jane.Doe@gmail.com</ex></ph>
           </message>
           <message name="IDS_PRIMARY_PROFILE_FIRST_RUN_SESSION_MANAGED_BY_DESCRIPTION" desc="Disclaimer on the landing screen in first run experience for the primary profile, informing that the session is managed by an administrator.">
-            Your account is managed by <ph name="MANAGER_NAME">$1<ex>example.com</ex></ph>. Your administrator can see and edit this Chromium browser profile and its data like bookmarks, history, and passwords.
+            Your account is managed by <ph name="MANAGER_NAME">$1<ex>example.com</ex></ph>. Your administrator can see and edit this Supermium browser profile and its data like bookmarks, history, and passwords.
           </message>
         </if>
         <if expr="not chromeos_lacros">
           <message name="IDS_FRE_SIGN_IN_TITLE_0"
-            desc="This string appears as a heading on a full-page screen that asks the user to sign in to Chromium with their Google Account. It appears when the user launches Chromium for the first time. When they sign in, they can personalize and customize Chromium and remember their settings in their Google Account. The tone should be inviting and alluring.">
-            Sign in to Chromium
+            desc="This string appears as a heading on a full-page screen that asks the user to sign in to Supermium with their Google Account. It appears when the user launches Supermium for the first time. When they sign in, they can personalize and customize Supermium and remember their settings in their Google Account. The tone should be inviting and alluring.">
+            Sign in to Supermium
           </message>
           <message name="IDS_FRE_SIGN_IN_TITLE_1"
-            desc="This string appears as a heading on a full-page screen that asks the user to sign in to Chromium with their Google Account. It appears when the user launches Chromium for the first time. When they sign in, they can personalize and customize Chromium and remember their settings in their Google Account. The tone should be inviting and alluring.">
-            Make Chromium your own
+            desc="This string appears as a heading on a full-page screen that asks the user to sign in to Supermium with their Google Account. It appears when the user launches Supermium for the first time. When they sign in, they can personalize and customize Supermium and remember their settings in their Google Account. The tone should be inviting and alluring.">
+            Make Supermium your own
           </message>
           <message name="IDS_FRE_SIGN_IN_TITLE_2"
-            desc="This string appears as a heading on a full-page screen that tells users the benefits of signing in to Chromium. It appears when the user launches Chromium for the first time. When they sign in, they can personalize and customize Chromium and remember their settings in their Google Account. The tone should be inviting and alluring.">
-            Do more with Chromium
+            desc="This string appears as a heading on a full-page screen that tells users the benefits of signing in to Supermium. It appears when the user launches Supermium for the first time. When they sign in, they can personalize and customize Supermium and remember their settings in their Google Account. The tone should be inviting and alluring.">
+            Do more with Supermium
           </message>
         </if>
 
@@ -1628,13 +1628,13 @@ Permissions you've already given to websites and apps may apply to this account.
 
         <!-- Profile switch IPH -->
         <message name="IDS_PROFILE_SWITCH_PROMO" desc="Text of the In-Product-Help bubble for profile switching.">
-          You can switch between Chromium profiles here
+          You can switch between Supermium profiles here
         </message>
         <message name="IDS_PROFILE_SWITCH_PROMO_SCREENREADER" desc="Text announced by screenreaders to explain how to switch between profiles.">
-          <ph name="SHORTCUT">$1<ex>CTRL+SHIFT+M</ex></ph> can switch between Chromium profiles
+          <ph name="SHORTCUT">$1<ex>CTRL+SHIFT+M</ex></ph> can switch between Supermium profiles
         </message>
         <message name="IDS_PASSWORD_MANAGER_IPH_BODY_WEB_APP_PROFILE_SWITCH" desc="Body of the in Product Help for profile switching shown in the password manager web app.">
-          You can switch to see passwords from another Chromium profile
+          You can switch to see passwords from another Supermium profile
         </message>
       </if>
 
@@ -1647,20 +1647,20 @@ Permissions you've already given to websites and apps may apply to this account.
 
       <!-- ChromeLabs bubble -->
       <message name="IDS_CHROMELABS_RELAUNCH_FOOTER_MESSAGE" desc="Text that shows in the footer of the Chrome Labs bubble when relaunch is needed for changes to take effect.">
-        Your changes will take effect the next time you relaunch Chromium.
+        Your changes will take effect the next time you relaunch Supermium.
       </message>
 
       <!-- Device Chooser Prompt -->
       <message name="IDS_BLUETOOTH_DEVICE_CHOOSER_AUTHORIZE_BLUETOOTH" desc="Text shown in the Chooser when browser does not have Bluetooth permission. The '&#10;' is a newline character to force the desired line wrapping.">
-        Chromium needs Bluetooth access to continue &#10; pairing. <ph name="IDS_BLUETOOTH_DEVICE_CHOOSER_AUTHORIZE_BLUETOOTH_LINK">$1<ex>Open Preferences</ex></ph>
+        Supermium needs Bluetooth access to continue &#10; pairing. <ph name="IDS_BLUETOOTH_DEVICE_CHOOSER_AUTHORIZE_BLUETOOTH_LINK">$1<ex>Open Preferences</ex></ph>
       </message>
 
       <!-- Tailored Security -->
       <message name="IDS_TAILORED_SECURITY_UNCONSENTED_PROMOTION_NOTIFICATION_TITLE" desc="Title of notification prompting the user to enable Enhanced Safe Browsing after they have enabled account-level protections.">
-        Get Chromium's strongest security
+        Get Supermium's strongest security
       </message>
       <message name="IDS_TAILORED_SECURITY_UNCONSENTED_PROMOTION_MESSAGE_TITLE" desc="Title shown in the message shown when a user changes their account-level tailored security setting encouraging them to enable Enhanced Safe Browsing">
-        Get Chromium's strongest security
+        Get Supermium's strongest security
       </message>
       <message name="IDS_TAILORED_SECURITY_UNCONSENTED_PROMOTION_MESSAGE_DESCRIPTION" desc="Description shown in the message shown when a user changes their account-level tailored security setting encouraging them to enable Enhanced Safe Browsing">
         Enhanced protection does more to block phishing and malware
@@ -1674,49 +1674,49 @@ Permissions you've already given to websites and apps may apply to this account.
 
       <!-- Privacy Sandbox Dialog strings -->
       <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_SUBTITLE" desc="A subtitle on the consent page. Consider this a tagline for the Privacy Sandbox project.* exploring conveys that this is a work in progress. * new features include settings that the user can turn on/off and also backend features that change the way Chrome works for everyone * allow sites to deliver: Privacy Sandbox is proposed by Google as a collaborative effort with the browser industry. Were building and testing functionality that will live in the Chrome browser. In order to land the full promise of Privacy Sandbox, websites and advertisers need to adopt the new APIs / functionality that were developing. So allow sites makes it clear to the user that were building something for the ecosystem. Typically a Google product builds something for the user, and thats true in this case, but its bigger than that. * same browsing experience using less of your info: Another definition of the promise of Privacy Sandbox. Third-party cookies are going away. In this new world, the user will have essentially the same browsing experience but its more private because it doesnt expose so much of the users info.">
-        Chromium is exploring new features that allow sites to deliver the same browsing experience using less of your info
+        Supermium is exploring new features that allow sites to deliver the same browsing experience using less of your info
       </message>
       <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_BODY_DESCRIPTION_2" desc="A paragraph beneath the More control over the ads you see subtitle. * see and remove topics of interests: we want to stress the element of control * estimate topics: Topics of interest include things like Live comedy and Rock music. Chrome estimates these interests based on the sites users visit. Its an estimation, and we dont want to suggest that we know with certainty the users interests. Avoid words like guess, establish, define, etc. (in place of estimate). * recent browsing history: Later in the UI, we define this as a record of sites youve visited using Chrome on this device. By recent, we mean the last 3 weeks (also defined later in the UI).">
-        You can see and remove topics of interest sites use to show you ads. Chromium estimates your interests based on your recent browsing history.
+        You can see and remove topics of interest sites use to show you ads. Supermium estimates your interests based on your recent browsing history.
       </message>
       <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_LABEL" desc="Learn more link * Unfolds content within the page * The text that appears describes 2 ways in which a site can target ads: the Topics API and the FLEDGE API. You can see what those are at www.privacysanbox.com or theyre described for the users benefit in other text. * ad personalization can mean different things in different contexts. Here, were using it as a simple noun. In other words, its not the name of a control but a descriptive term used to describe the personalization of ads in the Chrome browser. This ad personalization shouldnt be confused with the setting in the Google Account called Ad personalization.">
-        Learn more about ad personalization in Chromium
+        Learn more about ad personalization in Supermium
       </message>
-      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_1_HEADER" desc="TOPICS API A sub title that describes the first of 2 ways a site can get info from Chromium in order to target ads to the user. Topics of interest include things like Live comedy and Rock music. Chromium estimates these interests based on the sites users visit. * Your: we need to convey a sense of ownership, even if the user didnt explicitly choose the interests were talking about. Without the your, it could sound like Chromium is simply building a generic library of interests. * estimated: Its an estimation, and we dont want to suggest that we know with certainty the users interests. Avoid words like guess, establish, define, etc. (in place of estimate). * by Chromium: This is new behavior for a browser (Chromium) to take an active role in processing user data for the purposes of showing ads. Its important to convey Chromium, the actor in this case.">
-        Your interests as estimated by Chromium
+      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_1_HEADER" desc="TOPICS API A sub title that describes the first of 2 ways a site can get info from Supermium in order to target ads to the user. Topics of interest include things like Live comedy and Rock music. Supermium estimates these interests based on the sites users visit. * Your: we need to convey a sense of ownership, even if the user didnt explicitly choose the interests were talking about. Without the your, it could sound like Supermium is simply building a generic library of interests. * estimated: Its an estimation, and we dont want to suggest that we know with certainty the users interests. Avoid words like guess, establish, define, etc. (in place of estimate). * by Supermium: This is new behavior for a browser (Supermium) to take an active role in processing user data for the purposes of showing ads. Its important to convey Supermium, the actor in this case.">
+        Your interests as estimated by Supermium
       </message>
-      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_1_BULLET_POINT_1" desc="TOPICS API Bullet 1 of 3 that appear beneath the Your interests as estimated by Chromium subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * What data is used: is bold and serves as a label to help people skimming the page. * Your browsing history: The users browsing history is available beneath the History menu at Chromiums top level. The Topics API estimates topics of interest based on sites in the users browsing history that are participating in the trials.">
-        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>What data is used:<ph name="END_BOLD">&lt;/b&gt;</ph> Your browsing history, a record of sites youve visited using Chromium on this device.
+      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_1_BULLET_POINT_1" desc="TOPICS API Bullet 1 of 3 that appear beneath the Your interests as estimated by Supermium subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * What data is used: is bold and serves as a label to help people skimming the page. * Your browsing history: The users browsing history is available beneath the History menu at Supermiums top level. The Topics API estimates topics of interest based on sites in the users browsing history that are participating in the trials.">
+        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>What data is used:<ph name="END_BOLD">&lt;/b&gt;</ph> Your browsing history, a record of sites youve visited using Supermium on this device.
       </message>
-      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_1_BULLET_POINT_2" desc="TOPICS API Bullet 2 of 3 that appear beneath the Your interests as estimated by Chromium subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * How we use this data: is bold and serves as a label to help people skimming the page. * estimate your interests: Topics of interest include things like Live comedy and Rock music. Chromium estimates these interests based on the sites users visit. Its an estimation, and we dont want to suggest that we know with certainty the users interests. Avoid words like guess, establish, define, etc. (in place of estimate).">
-        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>How we use this data:<ph name="END_BOLD">&lt;/b&gt;</ph> Chromium can estimate your interests. Later, a site you visit can ask Chromium to see your interests in order to personalize the ads you see.
+      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_1_BULLET_POINT_2" desc="TOPICS API Bullet 2 of 3 that appear beneath the Your interests as estimated by Supermium subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * How we use this data: is bold and serves as a label to help people skimming the page. * estimate your interests: Topics of interest include things like Live comedy and Rock music. Supermium estimates these interests based on the sites users visit. Its an estimation, and we dont want to suggest that we know with certainty the users interests. Avoid words like guess, establish, define, etc. (in place of estimate).">
+        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>How we use this data:<ph name="END_BOLD">&lt;/b&gt;</ph> Supermium can estimate your interests. Later, a site you visit can ask Supermium to see your interests in order to personalize the ads you see.
       </message>
-      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_1_BULLET_POINT_3" desc="TOPICS API Bullet 3 of 3 that appear beneath the Your interests as estimated by Chromium subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * How you can manage your data: is bold and serves as a label to help people skimming the page. * To protect your privacy: Today, most data is kept for long periods of time. This new Topics API doesnt retain estimated topics for more than 3 weeks. The only reason for this feature is to protect the users privacy. * auto: isnt strictly necessary, but it conveys that this feature is an ongoing part of the service. This isnt describing, for example, a one-time deletion. * older than 3 weeks: Were trying to convey a rolling delete. Imagine a user opens a browser for the very first time. As the user browses, Chromium will estimate up to 5 topics of interest in the first week. In the second week, Chromium will estimate up to 5 additional topics of interest. The same for the third week, for a total of 15 potential interests. In week 4, Chromium will automatically delete the 5 interests from week 1 so that there arent ever more than 15 topics associated with a user at any given time. * interests can refresh: If a user loves horror films and reads about them for months on end, the interest Horror movies might get deleted and refreshed in the same week, so that Horror movies doesnt ever disappear from the users list of interests. * Or you can: A user might love horror movies but cant stand the idea of seeing ads about horror movies (because even the visuals will ruin the surprise of opening night). In this case, the user can remove Horror movies from the list of interests Chromium will consider. This removal remains in place indefinitely. Note that the user might still see ads about Horror movies from different ad networks or by other means than Chromiums Browser-based ad personalization setting.">
-        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>How you can manage your data:<ph name="END_BOLD">&lt;/b&gt;</ph> To protect your privacy, we auto-delete your interests that are older than 4 weeks. As you keep browsing, an interest might appear on the list again. Or you can remove interests you dont want Chromium to consider.
+      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_1_BULLET_POINT_3" desc="TOPICS API Bullet 3 of 3 that appear beneath the Your interests as estimated by Supermium subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * How you can manage your data: is bold and serves as a label to help people skimming the page. * To protect your privacy: Today, most data is kept for long periods of time. This new Topics API doesnt retain estimated topics for more than 3 weeks. The only reason for this feature is to protect the users privacy. * auto: isnt strictly necessary, but it conveys that this feature is an ongoing part of the service. This isnt describing, for example, a one-time deletion. * older than 3 weeks: Were trying to convey a rolling delete. Imagine a user opens a browser for the very first time. As the user browses, Supermium will estimate up to 5 topics of interest in the first week. In the second week, Supermium will estimate up to 5 additional topics of interest. The same for the third week, for a total of 15 potential interests. In week 4, Supermium will automatically delete the 5 interests from week 1 so that there arent ever more than 15 topics associated with a user at any given time. * interests can refresh: If a user loves horror films and reads about them for months on end, the interest Horror movies might get deleted and refreshed in the same week, so that Horror movies doesnt ever disappear from the users list of interests. * Or you can: A user might love horror movies but cant stand the idea of seeing ads about horror movies (because even the visuals will ruin the surprise of opening night). In this case, the user can remove Horror movies from the list of interests Supermium will consider. This removal remains in place indefinitely. Note that the user might still see ads about Horror movies from different ad networks or by other means than Supermiums Browser-based ad personalization setting.">
+        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>How you can manage your data:<ph name="END_BOLD">&lt;/b&gt;</ph> To protect your privacy, we auto-delete your interests that are older than 4 weeks. As you keep browsing, an interest might appear on the list again. Or you can remove interests you dont want Supermium to consider.
       </message>
-      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_2_BULLET_POINT_1" desc="FLEDGE APIBullet 1 of 3 that appear beneath the Sites you visit that define your interests subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * What data is used: is bold and serves as a label to help people skimming the page. * Your browsing history: The users browsing history is available beneath the History menu at Chromiums top level. This content taken in isolation is somewhat misleading. With FLEDGE, a site can store information in Chromium about the users visit to their site. For example, the site might store running_shoes_red_size_35 to indicate that the user showed interest in a particular shoe. Were OK with the simplification in this bullet because 1) we explain it in the next bullet and 2) we want the user to understand that at the top level, both Topics &amp; Fledge are based on the same thing and that is the users browsing history.">
-        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>What data is used:<ph name="END_BOLD">&lt;/b&gt;</ph> Your browsing history, a record of sites youve visited using Chromium on this device.
+      <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_2_BULLET_POINT_1" desc="FLEDGE APIBullet 1 of 3 that appear beneath the Sites you visit that define your interests subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * What data is used: is bold and serves as a label to help people skimming the page. * Your browsing history: The users browsing history is available beneath the History menu at Supermiums top level. This content taken in isolation is somewhat misleading. With FLEDGE, a site can store information in Supermium about the users visit to their site. For example, the site might store running_shoes_red_size_35 to indicate that the user showed interest in a particular shoe. Were OK with the simplification in this bullet because 1) we explain it in the next bullet and 2) we want the user to understand that at the top level, both Topics &amp; Fledge are based on the same thing and that is the users browsing history.">
+        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>What data is used:<ph name="END_BOLD">&lt;/b&gt;</ph> Your browsing history, a record of sites youve visited using Supermium on this device.
       </message>
       <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_LEARN_MORE_SECTION_2_BULLET_POINT_2" desc="FLEDGE API Bullet 2 of 3 that appear beneath the Sites you visit that define your interests subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * How we use this data: is bold and serves as a label to help people skimming the page.">
-        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>How we use this data:<ph name="END_BOLD">&lt;/b&gt;</ph> Sites can store information with Chromium about your interests. For example, if you visit a site to buy shoes for a marathon, the site might define your interest as running marathons. Later, if you visit a different site to register for a race, that site can show you an ad for running shoes based on your interests.
+        <ph name="BEGIN_BOLD">&lt;b&gt;</ph>How we use this data:<ph name="END_BOLD">&lt;/b&gt;</ph> Sites can store information with Supermium about your interests. For example, if you visit a site to buy shoes for a marathon, the site might define your interest as running marathons. Later, if you visit a different site to register for a race, that site can show you an ad for running shoes based on your interests.
       </message>
       <message name="IDS_PRIVACY_SANDBOX_DIALOG_CONSENT_BOTTOM_SUMMARY" desc="A conclusion paragraph for the entire page. It sits beneath the More control over the ads you see subtitle but its no more associated with that topic than Limit sharing between sites. * You can change your mind: When writing a consent moment, we have a legal obligation to inform the user how they can revoke their consent or opt out. A friendlier way to say this is change your mind. * in Chrome settings: The URL is chrome://settings/privacySandbox. We dont make it a live link because we need the users to stay in this moment until they make a choice. * The trials run alongside: The trials happen in addition to todays current system based on third-party cookies. In other words, even by accepting in this consent moment, the users core experience doesnt change much. This is an experiment, and we need the user to understand as much. ">
-        You can change your mind at any time in Chromium settings. The trials run alongside the current way ads get served, so you wont see changes right away.
+        You can change your mind at any time in Supermium settings. The trials run alongside the current way ads get served, so you wont see changes right away.
       </message>
       <message name="IDS_PRIVACY_SANDBOX_DIALOG_NOTICE_SUBTITLE" desc="A subtitle on the consent page. Consider this a tagline for the Privacy Sandbox project.* exploring conveys that this is a work in progress. * new features include settings that the user can turn on/off and also backend features that change the way Chrome works for everyone * allow sites to deliver: Privacy Sandbox is proposed by Google as a collaborative effort with the browser industry. Were building and testing functionality that will live in the Chrome browser. In order to land the full promise of Privacy Sandbox, websites and advertisers need to adopt the new APIs / functionality that were developing. So allow sites makes it clear to the user that were building something for the ecosystem. Typically a Google product builds something for the user, and thats true in this case, but its bigger than that. * same browsing experience using less of your info: Another definition of the promise of Privacy Sandbox. Third-party cookies are going away. In this new world, the user will have essentially the same browsing experience but its more private because it doesnt expose so much of the users info.">
-        Chromium is exploring new features that allow sites to deliver the same browsing experience using less of your info
+        Supermium is exploring new features that allow sites to deliver the same browsing experience using less of your info
       </message>
       <message name="IDS_PRIVACY_SANDBOX_DIALOG_NOTICE_BODY_DESCRIPTION_2" desc="A paragraph beneath the More control over the ads you see subtitle.* During the trials: The trials happens in addition to todays current system based on third-party cookies. In other words, even by agreeing to or remaining in a trial,, the users core experience doesnt change much. This is an experiment, and we need the user to understand as much. * see and remove topics of interests: we want to stress the element of control * estimate topics: Topics of interest include things like Live comedy and Rock music. Chrome estimates these interests based on the sites users visit. Its an estimation, and we dont want to suggest that we know with certainty the users interests. Avoid words like guess, establish, define, etc. (in place of estimate). * recent browsing history: Later in the UI, we define this as a record of sites youve visited using Chrome on this device. By recent, we mean the last 3 weeks (also defined later in the UI).">
-        During the trials, you can see and remove topics of interest sites use to show you ads. Chromium estimates your interests based on your recent browsing history.
+        During the trials, you can see and remove topics of interest sites use to show you ads. Supermium estimates your interests based on your recent browsing history.
       </message>
       <message name="IDS_PRIVACY_SANDBOX_DIALOG_NOTICE_BOTTOM_SUMMARY" desc="A conclusion paragraph for the entire page. It sits beneath the More control over the ads you see subtitle but its no more associated with that topic than Limit sharing between sites. * in Chrome settings: The URL is chrome://settings/privacySandbox. We dont make it a live link because we need the users to stay in this moment until they make a choice.">
-        You can learn more about these features in Chromium settings.
+        You can learn more about these features in Supermium settings.
       </message>
 
       <!-- ChromiumUpdater Strings -->
       <if expr="is_win">
         <message name="IDS_FRIENDLY_COMPANY_NAME" desc="Company name" translateable="false">
-          Chromium
+          Supermium
         </message>
         <message name="IDS_NO_UPDATE_RESPONSE" desc="Updater response for no updates when handling install result.">
           No update is available.
@@ -1725,7 +1725,7 @@ Permissions you've already given to websites and apps may apply to this account.
           Installation failed. Please try again.
         </message>
         <message name="IDS_INSTALLER_DISPLAY_NAME" desc="Name for the updater metainstaller.">
-          <ph name="COMPANY_NAME">$1<ex>Chromium</ex></ph> Installer
+          <ph name="COMPANY_NAME">$1<ex>Supermium</ex></ph> Installer
         </message>
         <message name="IDS_CLOSE_BUTTON" desc="Close button tooltip">
           Close
@@ -1764,13 +1764,13 @@ Permissions you've already given to websites and apps may apply to this account.
           Canceling...
         </message>
         <message name="IDS_TEXT_RESTART_BROWSER" desc="For when a browser must be restarted to complete the installation.">
-          Thanks for installing. You must restart your browser before using <ph name="BUNDLE_NAME">$1<ex>Chromium</ex></ph>.
+          Thanks for installing. You must restart your browser before using <ph name="BUNDLE_NAME">$1<ex>Supermium</ex></ph>.
         </message>
         <message name="IDS_TEXT_RESTART_ALL_BROWSERS" desc="For when all browsers must be restarted to complete the installation.">
-          Thanks for installing. You must restart all your browsers before using <ph name="BUNDLE_NAME">$1<ex>Chromium</ex></ph>.
+          Thanks for installing. You must restart all your browsers before using <ph name="BUNDLE_NAME">$1<ex>Supermium</ex></ph>.
         </message>
         <message name="IDS_TEXT_RESTART_COMPUTER" desc="For when the computer must be restarted to complete the installation.">
-          Thanks for installing. You must restart your computer before using <ph name="BUNDLE_NAME">$1<ex>Chromium</ex></ph>.
+          Thanks for installing. You must restart your computer before using <ph name="BUNDLE_NAME">$1<ex>Supermium</ex></ph>.
         </message>
         <message name="IDS_UPDATER_CLOSE" desc="For close button on the UI post install completion.">
           Close
@@ -1807,16 +1807,16 @@ Permissions you've already given to websites and apps may apply to this account.
       <if expr="not is_android">
         <if expr="use_titlecase">
           <message name="IDS_HIGH_EFFICIENCY_DIALOG_TITLE" desc="In Title Case: Title text for a dialog describing that the Memory Saver setting is enabled">
-            Memory Saver Made Chromium Faster
+            Memory Saver Made Supermium Faster
           </message>
         </if>
         <if expr="not use_titlecase">
           <message name="IDS_HIGH_EFFICIENCY_DIALOG_TITLE" desc="Title text for a dialog describing that the Memory Saver setting is enabled">
-            Memory Saver made Chromium faster
+            Memory Saver made Supermium faster
           </message>
         </if>
         <message name="IDS_HIGH_EFFICIENCY_DIALOG_BODY_V2" desc="Body text for a dialog describing that Memory Saver mode will use less memory.">
-          While this tab was inactive, memory was freed up to keep Chromium fast. You can choose to always exclude this site from being inactive.
+          While this tab was inactive, memory was freed up to keep Supermium fast. You can choose to always exclude this site from being inactive.
         </message>
       </if>
 
@@ -1824,15 +1824,15 @@ Permissions you've already given to websites and apps may apply to this account.
       <if expr="not is_android">
         <if expr="use_titlecase">
           <message name="IDS_HIGH_EFFICIENCY_MODE_PROMO_TITLE" desc="In Title Case: The title for the high efficiency mode in-product promo bubble">
-            Make Chromium Faster
+            Make Supermium Faster
           </message>
         </if>
         <if expr="not use_titlecase">
           <message name="IDS_HIGH_EFFICIENCY_MODE_PROMO_TITLE" desc="The title for the high efficiency mode in-product promo bubble">
-            Make Chromium faster
+            Make Supermium faster
           </message>
         </if>
       </if>
     </messages>
   </release>
-</grit>
+</grit>
\ No newline at end of file
diff --git a/chrome/app/resources/chromium_strings_fr.xtb b/chrome/app/resources/chromium_strings_fr.xtb
index 267d77634bb3f..22395b016a72e 100644
--- a/chrome/app/resources/chromium_strings_fr.xtb
+++ b/chrome/app/resources/chromium_strings_fr.xtb
@@ -1,4 +1,4 @@
-<?xml version="1.0" ?>
+<?xml version="1.0" ?>
 <!DOCTYPE translationbundle>
 <translationbundle lang="fr">
 <translation id="1026101648481255140">Reprendre l'installation</translation>
diff --git a/chrome/app/settings_chromium_strings.grdp b/chrome/app/settings_chromium_strings.grdp
index 16e19aab8f00a..22869a840f102 100644
--- a/chrome/app/settings_chromium_strings.grdp
+++ b/chrome/app/settings_chromium_strings.grdp
@@ -1,10 +1,10 @@
 <?xml version="1.0" encoding="utf-8"?>
-<!-- Settings-specific Chromium strings (included from chromium_strings.grd). -->
+<!-- Settings-specific Supermium strings (included from chromium_strings.grd). -->
 <grit-part>
   <!-- Shared across multiple page -->
   <if expr="not chromeos_ash">
     <message name="IDS_RELAUNCH_CONFIRMATION_DIALOG_TITLE" desc="The title of the modal dialog that we show when users click on relaunch and they have open Incognito windows. The dialog serves to warn the users about losing their Incognito windows if they proceed with the relaunch.">
-      Relaunch Chromium?
+      Relaunch Supermium?
     </message>
   </if>
   <!-- About Page -->
@@ -19,25 +19,25 @@
     </then>
     <else>
       <message name="IDS_SETTINGS_ABOUT_PROGRAM" desc="Menu title for the About Chromium page.">
-        About Chromium
+        About Supermium
       </message>
       <message name="IDS_SETTINGS_GET_HELP_USING_CHROME" desc="Text of the button which takes the user to the Chrome help page.">
-        Get help with Chromium
+        Get help with Supermium
       </message>
     </else>
   </if>
   <if expr="not chromeos_ash">
-    <message name="IDS_SETTINGS_UPGRADE_UPDATING" desc="Status label: Updating Chromium">
-      Updating Chromium
+    <message name="IDS_SETTINGS_UPGRADE_UPDATING" desc="Status label: Updating Supermium">
+      Updating Supermium
     </message>
-    <message name="IDS_SETTINGS_UPGRADE_UPDATING_PERCENT" desc="Status label: Updating Chromium (90%)">
-      Updating Chromium (<ph name="PROGRESS_PERCENT">$1<ex>90%</ex></ph>)
+    <message name="IDS_SETTINGS_UPGRADE_UPDATING_PERCENT" desc="Status label: Updating Supermium (90%)">
+      Updating Supermium (<ph name="PROGRESS_PERCENT">$1<ex>90%</ex></ph>)
     </message>
-    <message name="IDS_SETTINGS_UPGRADE_SUCCESSFUL_RELAUNCH" desc="Status label: Successfully updated Chromium">
-      Nearly up to date! Relaunch Chromium to finish updating.
+    <message name="IDS_SETTINGS_UPGRADE_SUCCESSFUL_RELAUNCH" desc="Status label: Successfully updated Supermium">
+      Nearly up to date! Relaunch Supermium to finish updating.
     </message>
-    <message name="IDS_SETTINGS_UPGRADE_UP_TO_DATE" desc="Status label: Already up to date (Chromium)">
-      Chromium is up to date
+    <message name="IDS_SETTINGS_UPGRADE_UP_TO_DATE" desc="Status label: Already up to date (Supermium)">
+      Supermium is up to date
     </message>
   </if>
   <if expr="chromeos_ash">
@@ -53,52 +53,52 @@
   </if>
 
   <!-- Autofill Page -->
-  <message name="IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED" desc="Label that will be used to show that a credit card comes from Google Pay and is saved locally. This should follow the casing of the 'Google Pay' and 'Chrome' brands. 'Copied to Chromium' is short for 'The credit card is copied to Chromium'. 'Google Pay' should not be translated as it is the product name.">
-    Google Pay (copied to Chromium)
+  <message name="IDS_SETTINGS_GOOGLE_PAYMENTS_CACHED" desc="Label that will be used to show that a credit card comes from Google Pay and is saved locally. This should follow the casing of the 'Google Pay' and 'Chrome' brands. 'Copied to Supermium' is short for 'The credit card is copied to Supermium'. 'Google Pay' should not be translated as it is the product name.">
+    Google Pay (copied to Supermium)
   </message>
   <message name="IDS_SETTINGS_CHECK_PASSWORDS_ERROR_OFFLINE" desc="Error message when the password check can't be completed because the user is offline.">
-    Chromium can't check your passwords. Try checking your internet connection.
+    Supermium can't check your passwords. Try checking your internet connection.
   </message>
   <message name="IDS_SETTINGS_CHECK_PASSWORDS_ERROR_SIGNED_OUT" desc="Error message when the password check can't be completed because the user is not signed in.">
-    Chromium can check your passwords when you sign in with your Google Account
+    Supermium can check your passwords when you sign in with your Google Account
   </message>
   <message name="IDS_SETTINGS_CHECK_PASSWORDS_ERROR_NO_PASSWORDS" desc="Error message when the password check can't be completed since no passwords could be checked.">
-    No saved passwords. Chromium can check your passwords when you save them.
+    No saved passwords. Supermium can check your passwords when you save them.
   </message>
   <message name="IDS_SETTINGS_CHECK_PASSWORDS_ERROR_QUOTA_LIMIT_GOOGLE_ACCOUNT" desc="Error message when the password check can't be completed since the user hit the quota limit, but the user is able to check their passwords in their Google account.">
-    Chromium can't check your passwords. Try again after 24 hours or <ph name="BEGIN_LINK">&lt;a href="$1" target="_blank"&gt;</ph>check passwords in your Google Account<ph name="END_LINK">&lt;/a&gt;</ph>.
+    Supermium can't check your passwords. Try again after 24 hours or <ph name="BEGIN_LINK">&lt;a href="$1" target="_blank"&gt;</ph>check passwords in your Google Account<ph name="END_LINK">&lt;/a&gt;</ph>.
   </message>
   <message name="IDS_SETTINGS_CHECK_PASSWORDS_ERROR_QUOTA_LIMIT" desc="Error message when the password check can't be completed since the user hit the quota limit.">
-    Chromium can't check your passwords. Try again after 24 hours.
+    Supermium can't check your passwords. Try again after 24 hours.
   </message>
   <message name="IDS_SETTINGS_CHECK_PASSWORDS_ERROR_GENERIC" desc="Error message when the password check can't be completed for an unspecified reason.">
-    Chromium can't check your passwords. Try again later.
+    Supermium can't check your passwords. Try again later.
   </message>
   <message name="IDS_SETTINGS_NO_COMPROMISED_CREDENTIALS_LABEL" desc="Label which is shown when there were no compromised passwords detected.">
-    Chromium will notify you when you sign in with a compromised password
+    Supermium will notify you when you sign in with a compromised password
   </message>
   <message name="IDS_SETTINGS_SIGNED_OUT_USER_LABEL" desc="Label which is shown at the top of the compromised password section if user is signed out.">
-    To check if your passwords are safe from data breaches and other security issues, <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;</ph>sign in to Chromium<ph name="END_LINK">&lt;/a&gt;</ph>.
+    To check if your passwords are safe from data breaches and other security issues, <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;</ph>sign in to Supermium<ph name="END_LINK">&lt;/a&gt;</ph>.
   </message>
   <message name="IDS_SETTINGS_SIGNED_OUT_USER_HAS_COMPROMISED_CREDENTIALS_LABEL" desc="Label which is shown at the bottom of the compromised password section if user is signed out and has compromised credentials.">
-    To check if your other passwords are safe from data breaches and other security issues, <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;</ph>sign in to Chromium<ph name="END_LINK">&lt;/a&gt;</ph>.
+    To check if your other passwords are safe from data breaches and other security issues, <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;</ph>sign in to Supermium<ph name="END_LINK">&lt;/a&gt;</ph>.
   </message>
   <message name="IDS_SETTINGS_WEAK_PASSWORDS_DESCRIPTION_GENERATION" desc="Information about why weak passwords are a security issue and what syncing user should do to fix the problem. Has a link.">
-    Weak passwords are easy to guess. Let Chromium <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;</ph>create and remember strong passwords for you<ph name="END_LINK">&lt;/a&gt;</ph>.
+    Weak passwords are easy to guess. Let Supermium <ph name="BEGIN_LINK">&lt;a target='_blank' href='$1'&gt;</ph>create and remember strong passwords for you<ph name="END_LINK">&lt;/a&gt;</ph>.
   </message>
-  <message name="IDS_SETTINGS_COMPROMISED_EDIT_DISCLAIMER_DESCRIPTION" desc="A description for the dialog which tells the user to edit password in Chromium if it was changed already.">
-    If so, please edit your saved password in Chromium so it matches your new password.
+  <message name="IDS_SETTINGS_COMPROMISED_EDIT_DISCLAIMER_DESCRIPTION" desc="A description for the dialog which tells the user to edit password in Supermium if it was changed already.">
+    If so, please edit your saved password in Supermium so it matches your new password.
   </message>
   <!-- Default Browser Page -->
   <if expr="not chromeos_ash">
     <message name="IDS_SETTINGS_DEFAULT_BROWSER_DEFAULT" desc="The text displayed when Chrome is the default browser">
-      Chromium is your default browser
+      Supermium is your default browser
     </message>
     <message name="IDS_SETTINGS_DEFAULT_BROWSER_MAKE_DEFAULT" desc="Default browser checkbox label">
-      Make Chromium the default browser
+      Make Supermium the default browser
     </message>
     <message name="IDS_SETTINGS_DEFAULT_BROWSER_ERROR" desc="The text displayed when Chrome cannot determine or set the default browser">
-      Chromium cannot determine or set the default browser
+      Supermium cannot determine or set the default browser
     </message>
     <if expr="_is_chrome_for_testing_branded">
       <then>
@@ -108,7 +108,7 @@
       </then>
       <else>
         <message name="IDS_SETTINGS_DEFAULT_BROWSER_SECONDARY" desc="The text displayed when Chromium is installed in side-by-side mode, which does not support setting as the default browser.">
-          This is a secondary installation of Chromium, and cannot be made your default browser.
+          This is a secondary installation of Supermium, and cannot be made your default browser.
         </message>
       </else>
     </if>
@@ -130,60 +130,60 @@
 
   <!-- Privacy Page -->
   <message name="IDS_SETTINGS_SPELLING_PREF_DESC" desc="Description of using a web serviced to help resolve spelling errors. It is important to convey that what the user types will be sent to Google.">
-    To fix spelling errors, Chromium sends the text you type in text fields to Google
+    To fix spelling errors, Supermium sends the text you type in text fields to Google
   </message>
   <message name="IDS_SETTINGS_RESTART_TO_APPLY_CHANGES" desc="Description in the snackbar to restart Chrome and apply changes.">
-    To apply your changes, relaunch Chromium
+    To apply your changes, relaunch Supermium
   </message>
 
   <if expr="not is_chromeos">
     <message name="IDS_SETTINGS_SIGNIN_ALLOWED" desc="The title of the preference to allow to sign-in to Chrome">
-    Allow Chromium sign-in
+    Allow Supermium sign-in
     </message>
     <message name="IDS_SETTINGS_SIGNIN_ALLOWED_DESC" desc="The description of the preference to allow to sign-in to Chrome">
-    By turning this off, you can sign in to Google sites like Gmail without signing in to Chromium
+    By turning this off, you can sign in to Google sites like Gmail without signing in to Supermium
     </message>
   </if>
 
   <!-- Site Settings -->
   <message name="IDS_SETTINGS_SITE_SETTINGS_PDFS_BLOCKED" desc="Label for the disabled option of the pdfs content setting.">
-    Open PDFs in Chromium
+    Open PDFs in Supermium
   </message>
   <if expr="not is_chromeos">
     <message name="IDS_SETTINGS_COOKIES_CLEAR_ON_EXIT_DESC" desc="Secondary text for the toggle that allows the user to automatically delete their cookies and site data when they close all browser windows. This sublabel clarifies that when the toggle is enabled the user will be signed out of Chrome each time they close all Chrome windows.">
-      When on, you'll also be signed out of Chromium
+      When on, you'll also be signed out of Supermium
     </message>
   </if>
 
     <!-- Site Settings - Site Data Page-->
   <message name="IDS_SETTINGS_SITE_DATA_PAGE_CLEAR_ON_EXIT_RADIO_SUBLABEL" desc="A description of the benefit/cost of choosing 'Sites can save content on your device. In short, a site will remember your preferences, shopping cart content, etc. during this browser session. But once you close all open windows, and then visit the site again, it's as if you're coming to the site for the first time.">
-    Sites will probably work as you expect but won't remember you after you close all Chromium windows
+    Sites will probably work as you expect but won't remember you after you close all Supermium windows
   </message>
   <message name="IDS_SETTINGS_SITE_DATA_PAGE_DELETE_ON_EXIT_EXCEPTIONS_SUB_HEADING" desc="2 of 3. A label within 'Customized behaviors' that allows for exceptions to the 'On-device site data' setting. This label and the list of sites that can appear beneath it is only relevant if the user has chosen to allow 'on-device site data' as the default value above.">
-    Always delete site data from your device when you close Chromium
+    Always delete site data from your device when you close Supermium
   </message>
 
   <!-- Privacy Guide -->
   <message name="IDS_SETTINGS_PRIVACY_GUIDE_PROMO_BODY" desc="Body text of a card in the settings page that explains what the 'Privacy Guide' feature is.">
-    Review key privacy and security controls in Chromium
+    Review key privacy and security controls in Supermium
   </message>
   <message name="IDS_SETTINGS_PRIVACY_GUIDE_SAFE_BROWSING_CARD_STANDARD_PROTECTION_FEATURE_DESCRIPTION2" desc="A part of the feature description of the standard protection section of the safe browsing card in the 'Privacy Guide'.">
-    Checks URLs with a list of unsafe sites stored in Chromium
+    Checks URLs with a list of unsafe sites stored in Supermium
   </message>
   <message name="IDS_SETTINGS_PRIVACY_GUIDE_SAFE_BROWSING_CARD_STANDARD_PROTECTION_PRIVACY_DESCRIPTION1" desc="A part of the privacy description of the standard protection section of the safe browsing card in the 'Privacy Guide'.">
-    If a site tries to steal your password, or when you download a harmful file, Chromium may also send URLs, including bits of page content, to Safe Browsing
+    If a site tries to steal your password, or when you download a harmful file, Supermium may also send URLs, including bits of page content, to Safe Browsing
   </message>
   <message name="IDS_SETTINGS_PRIVACY_GUIDE_COMPLETION_CARD_PRIVACY_SANDBOX_SUB_LABEL" desc="Text of the Privacy Sandbox sublabel in the completion card of the 'Privacy Guide'.">
-    Chromium is exploring new features that allow sites to deliver the same browsing experience using less of your data
+    Supermium is exploring new features that allow sites to deliver the same browsing experience using less of your data
   </message>
   <message name="IDS_SETTINGS_PRIVACY_GUIDE_COMPLETION_CARD_WAA_SUB_LABEL" desc="Text of the Web and App Activity sublabel in the completion card of the 'Privacy Guide'.">
-    Choose whether to include Chromium history for more personalized experiences in Google services
+    Choose whether to include Supermium history for more personalized experiences in Google services
   </message>
   <message name="IDS_SETTINGS_PRIVACY_GUIDE_MSBB_FEATURE_DESCRIPTION3" desc="A part of the feature description of 'make searches and browsing better' in the 'Privacy Guide'.">
     If you also save your bookmarks in your Google Account, you can track product prices in Chromium and get notified when the price drops
   </message>
   <message name="IDS_SETTINGS_PRIVACY_GUIDE_MSBB_PRIVACY_DESCRIPTION2" desc="A part of the privacy description of 'make searches and browsing better' in the 'Privacy Guide'.">
-    If you also share Chromium usage reports, those reports include the URLs you visit
+    If you also share Supermium usage reports, those reports include the URLs you visit
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SEARCH_SUGGESTIONS_PRIVACY_DESCRIPTION2" desc="A part of the privacy description of 'search suggestions' in the 'Privacy Guide'.">
     Depending on your settings, Chromium may also send cookies and your current URL
@@ -191,72 +191,72 @@
 
   <!-- Privacy Sandbox -->
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_LEARN_MORE_DIALOG_TOPICS_TITLE" desc="TOPICS API A sub title that describes the first of 2 ways a site can get info from Chrome in order to target ads to the user. Topics of interest include things like Live comedy and Rock music. Chrome estimates these interests based on the sites users visit. * Your: we need to convey a sense of ownership, even if the user didnt explicitly choose the interests were talking about. Without the your, it could sound like Chrome is simply building a generic library of interests. * estimated: Its an estimation, and we dont want to suggest that we know with certainty the users interests. Avoid words like guess, establish, define, etc. (in place of estimate). * by Chrome: This is new behavior for a browser (Chrome) to take an active role in processing user data for the purposes of showing ads. Its important to convey chrome, the actor in this case.">
-    Your interests as estimated by Chromium
+    Your interests as estimated by Supermium
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_LEARN_MORE_DIALOG_TOPICS_DATA_TYPES" desc="TOPICS API Bullet 1 of 3 that appear beneath the Your interests as estimated by Chrome subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * What data is used: is bold and serves as a label to help people skimming the page. * Your browsing history: The users browsing history is available beneath the History menu at Chromes top level. The Topics API estimates topics of interest based on sites in the users browsing history that are participating in the trials.">
-    Your browsing history, a record of sites you've visited using Chromium on this device.
+    Your browsing history, a record of sites you've visited using Supermium on this device.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_LEARN_MORE_DIALOG_TOPICS_DATA_USAGE" desc="TOPICS API Bullet 2 of 3 that appear beneath the Your interests as estimated by Chrome subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * How we use this data: is bold and serves as a label to help people skimming the page. * estimate your interests: Topics of interest include things like Live comedy and Rock music. Chrome estimates these interests based on the sites users visit. Its an estimation, and we dont want to suggest that we know with certainty the users interests. Avoid words like guess, establish, define, etc. (in place of estimate).">
-    Chromium can estimate your interests. Later, a site you visit can ask Chromium to see your interests in order to personalize the ads you see.
+    Supermium can estimate your interests. Later, a site you visit can ask Supermium to see your interests in order to personalize the ads you see.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_LEARN_MORE_DIALOG_TOPICS_DATA_MANAGEMENT" desc="TOPICS API Bullet 3 of 3 that appear beneath the Your interests as estimated by Chrome subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * How you can manage your data: is bold and serves as a label to help people skimming the page. * To protect your privacy: Today, most data is kept for long periods of time. This new Topics API doesnt retain estimated topics for more than 3 weeks. The only reason for this feature is to protect the users privacy. * auto: isnt strictly necessary, but it conveys that this feature is an ongoing part of the service. This isnt describing, for example, a one-time deletion. * older than 4 weeks: Were trying to convey a rolling delete. Imagine a user opens a browser for the very first time. As the user browses, Chrome will estimate up to 5 topics of interest in the first week. In the second week, Chrome will estimate up to 5 additional topics of interest. The same for the third week, for a total of 15 potential interests. In week 4, Chrome will automatically delete the 5 interests from week 1 so that there arent ever more than 15 topics associated with a user at any given time. * interests can refresh: If a user loves horror films and reads about them for months on end, the interest Horror movies might get deleted and refreshed in the same week, so that Horror movies doesnt ever disappear from the users list of interests. * Or you can: A user might love horror movies but cant stand the idea of seeing ads about horror movies (because even the visuals will ruin the surprise of opening night). In this case, the user can remove Horror movies from the list of interests Chrome will consider. This removal remains in place indefinitely. Note that the user might still see ads about Horror movies from different ad networks or by other means than Chromes Browser-based ad personalization setting.">
-    To protect your privacy, we auto-delete your interests that are older than 4 weeks. As you keep browsing, an interest might appear on the list again. Or you can remove interests you don't want Chromium to consider.
+    To protect your privacy, we auto-delete your interests that are older than 4 weeks. As you keep browsing, an interest might appear on the list again. Or you can remove interests you don't want Supermium to consider.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_LEARN_MORE_DIALOG_FLEDGE_DATA_TYPES" desc="FLEDGE API Bullet 1 of 3 that appear beneath the Sites you visit that define your interests subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * What data is used: is bold and serves as a label to help people skimming the page. * Your browsing history: The users browsing history is available beneath the History menu at Chromes top level. This content taken in isolation is somewhat misleading. With FLEDGE, a site can store information in Chrome about the users visit to their site. For example, the site might store running_shoes_red_size_35 to indicate that the user showed interest in a particular shoe. Were OK with the simplification in this bullet because 1) we explain it in the next bullet and 2) we want the user to understand that at the top level, both Topics &amp; Fledge are based on the same thing and that is the users browsing history.">
-    Your browsing history, a record of sites you've visited using Chromium on this device.
+    Your browsing history, a record of sites you've visited using Supermium on this device.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_LEARN_MORE_DIALOG_FLEDGE_DATA_USAGE" desc="FLEDGE API Bullet 2 of 3 that appear beneath the Sites you visit that define your interests subtitle. We break the description into the 3 pieces users most care about: 1) what data, 2) why this data, 3) what can I do about it? * How we use this data: is bold and serves as a label to help people skimming the page. With FLEDGE, a site can store information in Chrome about the users visit to their site. For example, the site might store running_shoes_red_size_35 to indicate that the user showed interest in a particular shoe. Were OK with the simplification in this bullet because 1) we explain it in the next bullet and 2) we want the user to understand that at the top level, both Topics &amp; Fledge are based on the same thing and that is the users browsing history. * Later:  is important to convey the passage of time. We dont want to convey how much time (it could be tiny). Whats important is that the user understands this is essentially a two-step process. They browse, and Chrome might estimate their interests as they do so. At a later point when they continue to visit a site, thats when the estimated interests might come into play.">
-    Sites can store information with Chromium about your interests. For example, if you visit a site to buy shoes for a marathon, the site might define your interest as running marathons. Later, if you visit a different site to register for a race, that site can show you an ad for running shoes based on your interests.
+    Sites can store information with Supermium about your interests. For example, if you visit a site to buy shoes for a marathon, the site might define your interest as running marathons. Later, if you visit a different site to register for a race, that site can show you an ad for running shoes based on your interests.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_PERSONALIZATION_DIALOG_DESCRIPTION" desc="A paragraph beneath the card title. Note that this paragraph is written so that it describes both the Topics API and the FLEDGE API. Some things are described slightly differently for this reason. Version 1 of 3 of this paragraph.  1) The first line is written with the assumption that the user a) has Privacy Sandbox trials turned on and b) has been randomly selected by Chrome to be in  an active experiment. As a result of both conditions, this user should have data on this page (a list of interests and a list of sites). 2) NOT THE CASE FOR THIS STRING: A different version of  this first line is written for the case that a user has the Privacy Sandbox trials turned on but they havent been randomly selected to be in a trial. 3) NOT THE CASE FOR THIS STRING: A different version of  this first line is written for the case that a user doesnt have the Privacy Sandbox trials turned on. * browsing history:  a record of sites youve visited using Chrome on this device. * affects the ads you see and the interests as estimated below: browsing history leads to Chrome establishing user interests leads to 1) the ads you see are different, and 2) the list of things on this page changes based on what Chrome establishes.* To protect your privacy: Today, most data is kept for long periods of time. This new Topics API doesnt retain estimated topics for more than 3 weeks. The only reason for this feature is to protect the users privacy. * auto: isnt strictly necessary, but it conveys that this feature is an ongoing part of the service. This isnt describing, for example, a one-time deletion. * rolling basis each month: Information associated with Topics and FLEDGE are deleted on a rolling basis at least once per month. Its simpler to talk about once per month rather than 3 weeks for Topics and 4 weeks for FLEDGE. * Interests can refresh: We intend for this line to cover both Topics and FLEDGE. Its slightly messy, because there is a suggestion that this line is more about Topics than FLEDGE (interests is more prominent in the Topics subtitle).">
-    Your browsing history affects the ads you see and the interests as estimated below. To protect your privacy, Chromium auto-deletes your interests on a rolling basis each month. Interests can refresh unless you remove them.
+    Your browsing history affects the ads you see and the interests as estimated below. To protect your privacy, Supermium auto-deletes your interests on a rolling basis each month. Interests can refresh unless you remove them.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_PERSONALIZATION_DIALOG_DESCRIPTION_TRIALS_OFF" desc="A paragraph beneath the card title. Note that this paragraph is written so that it describes both the Topics API and the FLEDGE API. Some things are described slightly differently for this reason. Version 2 of 3 of this paragraph.  1) NOT THE CASE FOR THIS STRING: A different version of this first line is written for the case that a user has Privacy Sandbox trials turned on AND that theyve been randomly selected for a trial. 2) The first line is written with the assumption that the user 1) has Privacy Sandbox trials turned on but 2) has NOT been randomly selected by Chrome to be in  an active experiment. This explains why the user doesnt have data shown on the page. 3) NOT THE CASE FOR THIS STRING: A different version of  this first line is written for the case that a user doesnt have the Privacy Sandbox trials turned on. * browsing history:  a record of sites youve visited using Chrome on this device. * affects the ads you see and the interests as estimated below: browsing history leads to Chrome establishing user interests leads to 1) the ads you see are different, and 2) the list of things on this page changes based on what Chrome establishes. * To protect your privacy: Today, most data is kept for long periods of time. This new Topics API doesnt retain estimated topics for more than 3 weeks. The only reason for this feature is to protect the users privacy. * auto: isnt strictly necessary, but it conveys that this feature is an ongoing part of the service. This isnt describing, for example, a one-time deletion. * rolling basis each month: Information associated with Topics and FLEDGE are deleted on a rolling basis at least once per month. Its simpler to talk about once per month rather than 3 weeks for Topics and 4 weeks for FLEDGE.* Interests can refresh: We intend for this line to cover both Topics and FLEDGE. Its slightly messy, because there is a suggestion that this line is more about Topics than FLEDGE (interests is more prominent in the Topics subtitle).">
-    When trials are on and if Chromium has randomly placed you in an active trial, your browsing history affects the ads you see and the interests as estimated below. To protect your privacy, Chromium deletes your interests on a rolling basis each month.
+    When trials are on and if Supermium has randomly placed you in an active trial, your browsing history affects the ads you see and the interests as estimated below. To protect your privacy, Supermium deletes your interests on a rolling basis each month.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_PERSONALIZATION_DIALOG_DESCRIPTION_LISTS_EMPTY" desc="A paragraph beneath the card title. Note that this paragraph is written so that it describes both the Topics API and the FLEDGE API. Some things are described slightly differently for this reason. Version 3 of 3 of this paragraph.  1) NOT THE CASE FOR THIS STRING: A different version of this first line is written for the case that a user has Privacy Sandbox trials turned on AND that theyve been randomly selected for a trial. 2) NOT THE CASE FOR THIS STRING: A different version of  this first line is written for the case that a user has the Privacy Sandbox trials turned on but they havent been randomly selected to be in a trial. 3) The first line is written with the assumption that the user a) doesnt have Privacy Sandbox trials turned on. b) Because of this, they cant be randomly selected for a trial. This explains why the user doesnt have data shown on the page. * browsing history:  a record of sites youve visited using Chrome on this device. * affects the ads you see and the interests as estimated below: browsing history leads to Chrome establishing user interests leads to 1) the ads you see are different, and 2) the list of things on this page changes based on what Chrome establishes. * To protect your privacy: Today, most data is kept for long periods of time. This new Topics API doesnt retain estimated topics for more than 3 weeks. The only reason for this feature is to protect the users privacy. * auto: isnt strictly necessary, but it conveys that this feature is an ongoing part of the service. This isnt describing, for example, a one-time deletion. * rolling basis each month: Information associated with Topics and FLEDGE are deleted on a rolling basis at least once per month. Its simpler to talk about once per month rather than 3 weeks for Topics and 4 weeks for FLEDGE. * Interests can refresh: We intend for this line to cover both Topics and FLEDGE. Its slightly messy, because there is a suggestion that this line is more about Topics than FLEDGE (interests is more prominent in the Topics subtitle).">
-    If Chromium has randomly placed you in an active trial, your browsing history affects the ads you see and the interests as estimated below. To protect your privacy, Chromium deletes your interests on a rolling basis each month. Interests refresh unless you remove them.
+    If Supermium has randomly placed you in an active trial, your browsing history affects the ads you see and the interests as estimated below. To protect your privacy, Supermium deletes your interests on a rolling basis each month. Interests refresh unless you remove them.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_PERSONALIZATION_DIALOG_TOPICS_TITLE" desc="Title of the browser-based interests section of the 'ad personalization' dialog.">
-    Your interests as estimated by Chromium
+    Your interests as estimated by Supermium
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_PERSONALIZATION_DIALOG_TOPICS_LEARN_MORE_1" desc="First learn more description of the browser-based interests section of the 'ad personalization' dialog.">
-    Chromium can estimate your interests based on your browsing history from the last few weeks. This info stays on your device.
+    Supermium can estimate your interests based on your browsing history from the last few weeks. This info stays on your device.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_PERSONALIZATION_DIALOG_TOPICS_LEARN_MORE_2" desc="Second learn more description of the browser-based interests section of the 'ad personalization' dialog.">
-    Later, a site you visit can ask Chromium to see your interests in order to personalize the ads you see. Chromium can share up to 3 interests.
+    Later, a site you visit can ask Supermium to see your interests in order to personalize the ads you see. Supermium can share up to 3 interests.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_PERSONALIZATION_DIALOG_TOPICS_LEARN_MORE_3" desc="Third learn more description of the browser-based interests section of the 'ad personalization' dialog.">
-    To protect your privacy, we auto-delete your interests that are older than 4 weeks. As you keep browsing, an interest might appear on the list again. And if Chromium gets it wrong or you don't want to see certain ads, you can remove an interest.
+    To protect your privacy, we auto-delete your interests that are older than 4 weeks. As you keep browsing, an interest might appear on the list again. And if Supermium gets it wrong or you don't want to see certain ads, you can remove an interest.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_PERSONALIZATION_DIALOG_FLEDGE_LEARN_MORE_1" desc="First learn more description of the website-based interests section of the 'ad personalization' dialog.">
-    It's common for sites you visit to remember things you're interested in, to personalize your experience. Sites can also store information with Chromium about your interests.
+    It's common for sites you visit to remember things you're interested in, to personalize your experience. Sites can also store information with Supermium about your interests.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_MEASUREMENT_DIALOG_DESCRIPTION" desc="A description of the Ad measurement API. * Ad measurement is the name of an API in this context. We dont use API with the user, but they need to know that there is something called A measurement and what it does. * sites you visit: call the API to get information. The actor is the site, not Chrome. * restricts cross-site tracking: Today, with 3rd-party cookies, ad measurement technologies can inadvertently (and intentionally) share considerable information from one site to another). This feature restricts that sharing in order to improve the users privacy.">
-    Ad measurement allows sites you visit to request information from Chromium that helps the site measure the performance of their ads. Ad measurement restricts cross-site tracking by transferring as little information as possible between sites.
+    Ad measurement allows sites you visit to request information from Supermium that helps the site measure the performance of their ads. Ad measurement restricts cross-site tracking by transferring as little information as possible between sites.
   </message>
   <message name="IDS_SETTINGS_PRIVACY_SANDBOX_AD_MEASUREMENT_DIALOG_DESCRIPTION_TRIALS_OFF" desc="A description of the Ad measurement API. * Ad measurement is the name of an API in this context. We dont use API with the user, but they need to know that there is something called A measurement and what it does. * sites you visit: call the API to get information. The actor is the site, not Chrome. * restricts cross-site tracking: Today, with 3rd-party cookies, ad measurement technologies can inadvertently (and intentionally) share considerable information from one site to another). This feature restricts that sharing in order to improve the users privacy.">
-    When trials are on, Ad measurement allows sites you visit to request information from Chromium that helps the site measure the performance of their ads. Ad measurement restricts cross-site tracking by transferring as little information as possible between sites.
+    When trials are on, Ad measurement allows sites you visit to request information from Supermium that helps the site measure the performance of their ads. Ad measurement restricts cross-site tracking by transferring as little information as possible between sites.
   </message>
 
   <!-- Safety check -->
   <message name="IDS_SETTINGS_SAFETY_CHECK_PARENT_PRIMARY_LABEL_BEFORE" desc="This text describes what the safety check is. (It's an area of the Settings page where users can quickly check whether their safety-related settings are fully protecting them.)">
-    Chromium can help keep you safe from data breaches, bad extensions, and more
+    Supermium can help keep you safe from data breaches, bad extensions, and more
   </message>
-  <message name="IDS_SETTINGS_SAFETY_CHECK_UPDATES_FAILED_OFFLINE" desc="This text describes that Chromium cannot check for updates because there currently is no internet connection.">
-    Chromium can't check for updates. Try checking your internet connection.
+  <message name="IDS_SETTINGS_SAFETY_CHECK_UPDATES_FAILED_OFFLINE" desc="This text describes that Supermium cannot check for updates because there currently is no internet connection.">
+    Supermium can't check for updates. Try checking your internet connection.
   </message>
-  <message name="IDS_SETTINGS_SAFETY_CHECK_UPDATES_FAILED" desc="This text describes that Chromium cannot update due to an unknown error.">
-    Chromium didn't update, something went wrong. <ph name="BEGIN_LINK">&lt;a target="_blank" href="$1"&gt;</ph>Fix Chromium update problems and failed updates.<ph name="END_LINK">&lt;/a&gt;</ph>
+  <message name="IDS_SETTINGS_SAFETY_CHECK_UPDATES_FAILED" desc="This text describes that Supermium cannot update due to an unknown error.">
+    Supermium didn't update, something went wrong. <ph name="BEGIN_LINK">&lt;a target="_blank" href="$1"&gt;</ph>Fix Supermium update problems and failed updates.<ph name="END_LINK">&lt;/a&gt;</ph>
   </message>
-  <message name="IDS_SETTINGS_SAFETY_CHECK_UPDATES_UNKNOWN" desc="This text displays the installed version of Chromium when it is not possible to check for updates on non-Chrome branded browsers.">
-    Chromium version <ph name="PRODUCT_VERSION">$1<ex>15.0.865.0</ex></ph> is installed
+  <message name="IDS_SETTINGS_SAFETY_CHECK_UPDATES_UNKNOWN" desc="This text displays the installed version of Supermium when it is not possible to check for updates on non-Chrome branded browsers.">
+    Supermium version <ph name="PRODUCT_VERSION">$1<ex>15.0.865.0</ex></ph> is installed
   </message>
   <message name="IDS_SETTINGS_SAFETY_CHECK_PASSWORDS_SIGNED_OUT" desc="This text points out that the password check can only run when the user is signed in.">
-    Chromium can't check your passwords because you're not signed in
+    Supermium can't check your passwords because you're not signed in
   </message>
   <message name="IDS_SETTINGS_SAFETY_CHECK_SAFE_BROWSING_DISABLED" desc="This text points out that Safe Browsing is disabled and that the user is not protected.">
-    Safe Browsing is off. Chromium recommends turning it on.
+    Safe Browsing is off. Supermium recommends turning it on.
   </message>
 
   <!-- Safe Browsing -->
@@ -275,54 +275,54 @@
 
   <!-- People Page -->
   <message name="IDS_SETTINGS_SYNC_DISCONNECT_DELETE_PROFILE_WARNING_WITH_COUNTS_SINGULAR" desc="Warning message displayed in the Sign out of Chrome dialog that indicates profile browsing data will be removed from the device.">
-    This will delete 1 item from this device. To retrieve your data later, sign in to Chromium as <ph name="USER_EMAIL">$1<ex>foo@example.com</ex></ph>.
+    This will delete 1 item from this device. To retrieve your data later, sign in to Supermium as <ph name="USER_EMAIL">$1<ex>foo@example.com</ex></ph>.
   </message>
   <message name="IDS_SETTINGS_SYNC_DISCONNECT_DELETE_PROFILE_WARNING_WITH_COUNTS_PLURAL" desc="Warning message displayed in the Sign out of Chrome dialog that indicates profile browsing data will be removed from the device.">
-    This will delete <ph name="ITEMS_COUNT">$1<ex>66</ex></ph> items from this device. To retrieve your data later, sign in to Chromium as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
+    This will delete <ph name="ITEMS_COUNT">$1<ex>66</ex></ph> items from this device. To retrieve your data later, sign in to Supermium as <ph name="USER_EMAIL">$2<ex>foo@example.com</ex></ph>.
   </message>
   <message name="IDS_SETTINGS_SYNC_DISCONNECT_DELETE_PROFILE_WARNING_WITHOUT_COUNTS" desc="Warning message displayed in the Sign out of Chrome dialog that indicates profile browsing data will be removed from the device.">
-    This will delete your browsing data from this device. To retrieve your data later, sign in to Chromium as <ph name="USER_EMAIL">$1<ex>foo@example.com</ex></ph>.
+    This will delete your browsing data from this device. To retrieve your data later, sign in to Supermium as <ph name="USER_EMAIL">$1<ex>foo@example.com</ex></ph>.
   </message>
 <if expr="not chromeos_ash">
   <message name="IDS_SETTINGS_CUSTOMIZE_YOUR_CHROME_PROFILE" desc="Label of the link that takes you to the page to customize your chrome profile.">
-    Customize your Chromium profile
+    Customize your Supermium profile
   </message>
   <message name="IDS_SETTING_NAME_YOUR_PROFILE" desc="Title of the edit local profile name section on the manage profile page.">
-    Name your Chromium profile
+    Name your Supermium profile
   </message>
 </if>
-  <message name="IDS_SETTINGS_PEOPLE_SIGN_IN_PROMPT_SECONDARY_WITH_ACCOUNT" desc="The secondary text displayed to prompt users to enable sync for an account that is alredy present in Chromium.">
-    Sync and personalize Chromium across your devices
+  <message name="IDS_SETTINGS_PEOPLE_SIGN_IN_PROMPT_SECONDARY_WITH_ACCOUNT" desc="The secondary text displayed to prompt users to enable sync for an account that is alredy present in Supermium.">
+    Sync and personalize Supermium across your devices
   </message>
 <if expr="chromeos_ash">
   <message name="IDS_SETTINGS_ACCOUNT_MANAGER_DESCRIPTION_V2" desc="Description of the Account Manager Settings page. Shown just below the title of the page.">
-    You can manage your signed-in Google Accounts. Your Google Accounts are used for Chromium browser, Play Store, Gmail, and more. If you want to add an account for someone else, like a family member, add a new person to your <ph name="DEVICE_TYPE">$1<ex>Chromebook</ex></ph> instead. <ph name="LINK_BEGIN">&lt;a&gt;</ph>Learn more<ph name="LINK_END">&lt;/a&gt;</ph>
+    You can manage your signed-in Google Accounts. Your Google Accounts are used for Supermium browser, Play Store, Gmail, and more. If you want to add an account for someone else, like a family member, add a new person to your <ph name="DEVICE_TYPE">$1<ex>Chromebook</ex></ph> instead. <ph name="LINK_BEGIN">&lt;a&gt;</ph>Learn more<ph name="LINK_END">&lt;/a&gt;</ph>
   </message>
 </if>
 
   <!-- Sync Page -->
   <message name="IDS_SETTINGS_SYNC_DATA_ENCRYPTED_TEXT" desc="Text alerting the user that synced data is encrypted.">
-    For added security, Chromium will encrypt your data.
+    For added security, Supermium will encrypt your data.
   </message>
   <message name="IDS_SETTINGS_SYNC_DISCONNECT_TITLE" desc="The title of the dialog to stop syncing and sign out.">
-    Sign out of Chromium?
+    Sign out of Supermium?
   </message>
   <message name="IDS_SETTINGS_SUGGEST_PREF_DESC" desc="The description of the checkbox to enable/disable sending omnibox input to the user's default search engine to get additional suggestions.">
-    When you type in the address bar or search box, Chromium sends what you type to your default search engine to get better suggestions. This is off in Incognito.
+    When you type in the address bar or search box, Supermium sends what you type to your default search engine to get better suggestions. This is off in Incognito.
   </message>
   <message name="IDS_SETTINGS_DRIVE_SUGGEST_PREF_DESC" desc="The description of the checkbox to enable/disable sending omnibox input to Google Drive to get suggestions for files.">
-    When you type in the address bar or search box, Chromium sends what you type to Google Drive to get item suggestions. This is off in Incognito.
+    When you type in the address bar or search box, Supermium sends what you type to Google Drive to get item suggestions. This is off in Incognito.
   </message>
-  <message name="IDS_SETTINGS_SYNC_SIGN_IN_PROMPT_WITH_NO_ACCOUNT" desc="The text displayed to prompt users to sign in to Chromium.">
-    Sign in to sync and personalize Chromium across your devices
+  <message name="IDS_SETTINGS_SYNC_SIGN_IN_PROMPT_WITH_NO_ACCOUNT" desc="The text displayed to prompt users to sign in to Supermium.">
+    Sign in to sync and personalize Supermium across your devices
   </message>
 
   <!-- Performance Page -->
   <message name="IDS_SETTINGS_PERFORMANCE_HIGH_EFFICIENCY_MODE_SETTING_DESCRIPTION" desc="Description for the memory saver mode setting">
-    When on, Chromium frees up memory from inactive tabs. This gives active tabs and other apps more computer resources and keeps Chromium fast. Your inactive tabs automatically become active again when you go back to them.
+    When on, Supermium frees up memory from inactive tabs. This gives active tabs and other apps more computer resources and keeps Supermium fast. Your inactive tabs automatically become active again when you go back to them.
   </message>
   <message name="IDS_SETTINGS_PERFORMANCE_BATTERY_SAVER_MODE_SETTING_DESCRIPTION" desc="Description for the energy saver mode setting">
-    When on, Chromium conserves battery power by limiting background activity and visual effects, such as smooth scrolling and video frame rates.
+    When on, Supermium conserves battery power by limiting background activity and visual effects, such as smooth scrolling and video frame rates.
   </message>
   <message name="IDS_SETTINGS_PERFORMANCE_PRELOAD_TOGGLE_SUMMARY" desc="Summary for the preload pages setting">
     When on, Chromium preloads pages which makes browsing and searching faster.
@@ -331,23 +331,23 @@
   <!-- Languages Page -->
   <if expr="is_win">
     <message name="IDS_SETTINGS_LANGUAGES_IS_DISPLAYED_IN_THIS_LANGUAGE" desc="The label for a language that is currently used as the UI display language.">
-      This language is used to display the Chromium UI
+      This language is used to display the Supermium UI
     </message>
     <message name="IDS_SETTINGS_LANGUAGES_DISPLAY_IN_THIS_LANGUAGE" desc="The label used for a button that changes the UI language.">
-      Display Chromium in this language
+      Display Supermium in this language
     </message>
   </if>
 
   <!-- System Page -->
   <if expr="not chromeos_ash">
     <message name="IDS_SETTINGS_SYSTEM_BACKGROUND_APPS_LABEL" desc="Label for the checkbox to allow apps to run in the background, when Chrome is closed.">
-      Continue running background apps when Chromium is closed
+      Continue running background apps when Supermium is closed
     </message>
   </if>
 
   <!-- Reset Page -->
   <message name="IDS_SETTINGS_RESET_PROFILE_FEEDBACK" desc="Feedback label in the Reset Profile Settings dialog">
-    Help make Chromium better by reporting the <ph name="BEGIN_LINK">&lt;a is="action-link" target="_blank"&gt;</ph>current settings<ph name="END_LINK">&lt;/a&gt;</ph>
+    Help make Supermium better by reporting the <ph name="BEGIN_LINK">&lt;a is="action-link" target="_blank"&gt;</ph>current settings<ph name="END_LINK">&lt;/a&gt;</ph>
   </message>
 
   <!-- Chrome Root Store -->
@@ -357,10 +357,9 @@
   <message name="IDS_SETTINGS_CHROME_CERTIFICATES_DESCRIPTION" desc="Secondary, continued explanation of how to manage SSL certificates and settings in Privacy options">
     Information about how Chromium manages its root certificates
   </message>
-
   <!-- Safety Hub -->
   <message name="IDS_SETTINGS_SAFETY_HUB_ENTRY_POINT_NOTHING_TO_DO" desc="This text describes what Safety Hub does (regularly checking whether Chromium settings are safe) and indicates whether the user should take action. This text is shown when Safety Hub has not identified any issues at this time. There is nothing to do for the user. As future checks of Safety Hub may identify issues, this state may change. This text is shown on a card in privacy settings next to a button that leads to Safety Hub.">
-    Chromium regularly checks to make sure your browser has the safest settings. We'll let you know if anything needs your review.
+    Supermium regularly checks to make sure your browser has the safest settings. We'll let you know if anything needs your review.
   </message>
   <message name="IDS_SETTINGS_SAFETY_HUB_ENTRY_POINT_HEADER" desc="Title of a row in Chrome's privacy settings (chrome://settings/privacy) explaining that Chrome recommends for the user to take action to improve their safety. Next to this text there is a button labeled 'Go to SafetyHub' that will take users to a dedicated page where users can take action.">
     Chromium found some safety recommendations for your review
diff --git a/chrome/app/theme/chromium/BRANDING b/chrome/app/theme/chromium/BRANDING
index f8363d5b294fe..2c43477b3f324 100644
--- a/chrome/app/theme/chromium/BRANDING
+++ b/chrome/app/theme/chromium/BRANDING
@@ -1,10 +1,10 @@
-COMPANY_FULLNAME=The Chromium Authors
-COMPANY_SHORTNAME=The Chromium Authors
-PRODUCT_FULLNAME=Chromium
-PRODUCT_SHORTNAME=Chromium
-PRODUCT_INSTALLER_FULLNAME=Chromium Installer
-PRODUCT_INSTALLER_SHORTNAME=Chromium Installer
-COPYRIGHT=Copyright @LASTCHANGE_YEAR@ The Chromium Authors. All rights reserved.
+COMPANY_FULLNAME=win32
+COMPANY_SHORTNAME=win32
+PRODUCT_FULLNAME=Supermium
+PRODUCT_SHORTNAME=Supermium
+PRODUCT_INSTALLER_FULLNAME=Supermium Installer
+PRODUCT_INSTALLER_SHORTNAME=Supermium Installer
+COPYRIGHT=Copyright @LASTCHANGE_YEAR@ Shane Fournier. All rights reserved.
 MAC_BUNDLE_ID=org.chromium.Chromium
 MAC_CREATOR_CODE=Cr24
 MAC_TEAM_ID=
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index 32e2e14cdb2d9..d345159155523 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -15,6 +15,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/feature_list.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
@@ -5646,6 +5647,20 @@ const FeatureEntry kFeatureEntries[] = {
                                     kForceDarkVariations,
                                     "ForceDarkVariations")},
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
+    {"force-dark-mode",
+	 flag_descriptions::kForceDarkModeFlagName, flag_descriptions::kForceDarkModeFlagDescription, kOsAll,
+	 FEATURE_VALUE_TYPE(base::features::kForceDarkModeFlag)},
+#if BUILDFLAG(IS_WIN)
+	{"disable-windows-10-custom-titlebar",
+	 flag_descriptions::kDisableWindows10CustomTitlebarName, flag_descriptions::kDisableWindows10CustomTitlebarDescription, kOsWin,
+	 SINGLE_VALUE_TYPE("disable-windows10-custom-titlebar")},
+	{"force-xp-theme",
+	 flag_descriptions::kForceXpThemeName, flag_descriptions::kForceXpThemeDescription, kOsWin,
+	 FEATURE_VALUE_TYPE(kForceXpTheme)},	 
+	{"force-gdi",
+	 flag_descriptions::kForceGdiName, flag_descriptions::kForceGdiDescription, kOsWin,
+	 SINGLE_VALUE_TYPE("disable-direct-write")},
+#endif
 #if BUILDFLAG(IS_ANDROID)
     {"enable-accessibility-page-zoom",
      flag_descriptions::kAccessibilityPageZoomName,
@@ -7271,10 +7286,6 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableWindowsGamingInputDataFetcherName,
      flag_descriptions::kEnableWindowsGamingInputDataFetcherDescription, kOsWin,
      FEATURE_VALUE_TYPE(features::kEnableWindowsGamingInputDataFetcher)},
-
-    {"windows11-mica-titlebar", flag_descriptions::kWindows11MicaTitlebarName,
-     flag_descriptions::kWindows11MicaTitlebarDescription, kOsWin,
-     FEATURE_VALUE_TYPE(kWindows11MicaTitlebar)},
 #endif
 
 #if BUILDFLAG(IS_ANDROID)
@@ -11253,6 +11264,12 @@ const FeatureEntry kFeatureEntries[] = {
      flag_descriptions::kEnableBuiltinHlsDescription, kOsAll,
      FEATURE_VALUE_TYPE(media::kBuiltInHlsPlayer)},
 #endif
+	{"ungoogled-supermium",
+	 flag_descriptions::kUngoogledSupermiumName, flag_descriptions::kUngoogledSupermiumDescription, 
+	 kOsAll, SINGLE_VALUE_TYPE("disable-windows10-custom-titlebar")},
+	{"disable-download-upload",
+	 flag_descriptions::kDisableDownloadUploadName, flag_descriptions::kDisableDownloadUploadDescription, 
+	 kOsAll, SINGLE_VALUE_TYPE("disable-windows10-custom-titlebar")},
 
 #if !BUILDFLAG(IS_CHROMEOS_ASH)
     {"profiles-reordering", flag_descriptions::kProfilesReorderingName,
diff --git a/chrome/browser/chrome_content_browser_client.cc b/chrome/browser/chrome_content_browser_client.cc
index 9b845c0e331c4..4f3afef7ec231 100644
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -4476,6 +4476,13 @@ std::string ChromeContentBrowserClient::GetDefaultDownloadName() {
   return l10n_util::GetStringUTF8(IDS_DEFAULT_DOWNLOAD_FILENAME);
 }
 
+base::FilePath ChromeContentBrowserClient::GetFontLookupTableCacheDir() {
+  base::FilePath user_data_dir;
+  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
+  DCHECK(!user_data_dir.empty());
+  return user_data_dir.Append(FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
   base::FilePath user_data_dir;
   base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
@@ -4893,7 +4900,7 @@ bool ChromeContentBrowserClient::PreSpawnChild(
     return true;
 
   sandbox::MitigationFlags mitigations = config->GetProcessMitigations();
-  mitigations |= sandbox::MITIGATION_FORCE_MS_SIGNED_BINS;
+  //mitigations |= sandbox::MITIGATION_FORCE_MS_SIGNED_BINS;
   sandbox::ResultCode result = config->SetProcessMitigations(mitigations);
   if (result != sandbox::SBOX_ALL_OK)
     return false;
diff --git a/chrome/browser/chrome_content_browser_client.h b/chrome/browser/chrome_content_browser_client.h
index db4ede8eb28c8..620168b95cc86 100644
--- a/chrome/browser/chrome_content_browser_client.h
+++ b/chrome/browser/chrome_content_browser_client.h
@@ -433,6 +433,7 @@ class ChromeContentBrowserClient : public content::ContentBrowserClient {
   void BrowserURLHandlerCreated(content::BrowserURLHandler* handler) override;
   base::FilePath GetDefaultDownloadDirectory() override;
   std::string GetDefaultDownloadName() override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   base::FilePath GetShaderDiskCacheDirectory() override;
   base::FilePath GetGrShaderDiskCacheDirectory() override;
   base::FilePath GetGraphiteDawnDiskCacheDirectory() override;
diff --git a/chrome/browser/device_reauth/win/authenticator_win.cc b/chrome/browser/device_reauth/win/authenticator_win.cc
index 1d9342a94ad70..c12ef488478df 100644
--- a/chrome/browser/device_reauth/win/authenticator_win.cc
+++ b/chrome/browser/device_reauth/win/authenticator_win.cc
@@ -45,6 +45,11 @@ using ABI::Windows::Security::Credentials::UI::
     UserConsentVerifierAvailability_NotConfiguredForUser;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 BiometricAuthenticationStatusWin ConvertUserConsentVerifierAvailability(
     UserConsentVerifierAvailability availability) {
   switch (availability) {
@@ -93,6 +98,11 @@ void GetBiometricAvailabilityFromWindows(
   // (http://crbug/973868).
   SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
 
+  if (!ResolveCoreWinRT()) {
+    ReportCantCheckAvailability(thread, std::move(callback));
+    return;
+  }
+
   ComPtr<IUserConsentVerifierStatics> factory;
   HRESULT hr = base::win::GetActivationFactory<
       IUserConsentVerifierStatics,
diff --git a/chrome/browser/download/chrome_download_manager_delegate.cc b/chrome/browser/download/chrome_download_manager_delegate.cc
index 27d85fc9bd95d..2f8a36dcfda41 100644
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -55,6 +55,7 @@
 #include "chrome/common/chrome_constants.h"
 #include "chrome/common/chrome_features.h"
 #include "chrome/common/chrome_paths.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/pdf_util.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/grit/generated_resources.h"
@@ -1564,7 +1565,10 @@ void ChromeDownloadManagerDelegate::OnDownloadTargetDetermined(
     DownloadItemModel model(item);
     model.DetermineAndSetShouldPreferOpeningInBrowser(
         target_info->target_path, target_info->is_filetype_handled_safely);
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableDownloadUpload) ||
+		base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kUngoogledSupermium))	{
     model.SetDangerLevel(target_info->danger_level);
+		}
   }
   if (ShouldBlockFile(item, target_info->danger_type)) {
     MaybeReportDangerousDownloadBlocked(
@@ -1643,6 +1647,10 @@ bool ChromeDownloadManagerDelegate::IsOpenInBrowserPreferreredForFile(
 bool ChromeDownloadManagerDelegate::ShouldBlockFile(
     download::DownloadItem* item,
     download::DownloadDangerType danger_type) const {
+  if (base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kDisableDownloadUpload) ||
+		base::CommandLine::ForCurrentProcess()->HasSwitch(switches::kUngoogledSupermium))	{
+	  return false;
+  }
   // Chrome-initiated background downloads should not be blocked.
   if (item && !item->RequireSafetyChecks()) {
     return false;
diff --git a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
index cfe13c30f9758..204edde196be8 100644
--- a/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
+++ b/chrome/browser/enterprise/platform_auth/cloud_ap_provider_win.cc
@@ -88,6 +88,11 @@ class WebAccountSupportFinder
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
     base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
 
+    if (!base::win::ResolveCoreWinRTDelayload())
+      return;  // Unsupported.
+    if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+      return;  // Unsupported.
+
     // Get the `WebAuthenticationCoreManager`.
     ComPtr<IWebAuthenticationCoreManagerStatics> auth_manager;
     HRESULT hresult = base::win::GetActivationFactory<
diff --git a/chrome/browser/flag-metadata.json b/chrome/browser/flag-metadata.json
index 60d6876953def..03db4e06e94b8 100644
--- a/chrome/browser/flag-metadata.json
+++ b/chrome/browser/flag-metadata.json
@@ -1775,6 +1775,11 @@
     "owners": [ "cros-networking@google.com" ],
     "expiry_milestone": 121
   },
+  {
+    "name": "disable-download-upload",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },  
   {
     "name": "disable-explicit-dma-fences",
     "owners": [ "chromeos-gfx@google.com" ],
@@ -1843,6 +1848,11 @@
     // workaround for some issues.
     "expiry_milestone": -1
   },
+  {
+    "name": "disable-windows-10-custom-titlebar",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "disallow-doc-written-script-loads",
     "owners": [ "//chrome/browser/data_saver/OWNERS" ],
@@ -4615,6 +4625,16 @@
     "owners": [ "chromeos-camera-eng@google.com" ],
     "expiry_milestone": 120
   },
+  {
+    "name": "force-dark-mode",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
+  {
+    "name": "force-gdi",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "force-gpu-main-thread-to-normal-priority-drdc",
     "owners": [ "vikassoni", "lehoangquyen" ],
@@ -4676,6 +4696,11 @@
     // have no access to commandline flags.
     "expiry_milestone": -1
   },
+  {
+    "name": "force-xp-theme",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "forced-colors",
     "owners": [ "almaher@microsoft.com" ],
@@ -8184,6 +8209,11 @@
     // Chrome OS.
     "expiry_milestone": -1
   },
+  {
+    "name": "ungoogled-supermium",
+    "owners": [ "win32", "supermium" ],
+    "expiry_milestone": -1
+  },
   {
     "name": "unsafely-treat-insecure-origin-as-secure",
     "owners": [ "security-dev" ],
diff --git a/chrome/browser/flag-never-expire-list.json b/chrome/browser/flag-never-expire-list.json
index 5319a2eecd5d5..773fb3d2bd0af 100644
--- a/chrome/browser/flag-never-expire-list.json
+++ b/chrome/browser/flag-never-expire-list.json
@@ -30,10 +30,12 @@
   "disable-accelerated-video-decode",
   "disable-accelerated-video-encode",
   "disable-buffer-bw-compression",
+  "disable-download-upload",
   "disable-explicit-dma-fences",
   "disable-javascript-harmony-shipping",
   "disable-webrtc-hw-decoding",
   "disable-webrtc-hw-encoding",
+  "disable-windows-10-custom-titlebar",
   "disallow-doc-written-script-loads",
   "enable-autofill-credit-card-upload",
   "enable-benchmarking",
@@ -77,12 +79,15 @@
   "extensions-on-chrome-urls",
   "external-navigation-debug-logs",
   "force-color-profile",
+  "force-dark-mode",
   "force-effective-connection-type",
+  "force-gdi",
   "force-show-update-menu-badge",
   "force-startup-signin-promo",
   "force-text-direction",
   "force-ui-direction",
   "force-update-menu-type",
+  "force-xp-theme",
   "fullscreen-promos-manager-skip-internal-limits",
   "fullscreen-viewport-adjustment-experiment",
   "gesture-properties-dbus-service",
@@ -125,6 +130,7 @@
   "ui-debug-tools",
   "ui-disable-partial-swap",
   "ui-slow-animations",
+  "ungoogled-supermium",
   "unsafely-treat-insecure-origin-as-secure",
   "update-menu-item-custom-summary",
   "use-android-staging-smds",
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index d33d6d04c130e..5295d5d72ff88 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -1093,6 +1093,10 @@ const char kDesktopPWAsWebBundlesName[] = "Desktop PWAs Web Bundles";
 const char kDesktopPWAsWebBundlesDescription[] =
     "Adds support for web bundles, making web apps able to be launched "
     "offline.";
+	
+const char kDisableDownloadUploadName[] = "Disable Safe Browsing for Downloads and Download Sample Uploads";
+const char kDisableDownloadUploadDescription[] = "Disables prompts about unsafe or uncommon downloads, and "
+												  "prevents samples of downloads from being sent to Google.";
 
 const char kEnableTLS13EarlyDataName[] = "TLS 1.3 Early Data";
 const char kEnableTLS13EarlyDataDescription[] =
@@ -1779,6 +1783,14 @@ const char kForceTextDirectionDescription[] =
 const char kForceDirectionLtr[] = "Left-to-right";
 const char kForceDirectionRtl[] = "Right-to-left";
 
+const char kForceGdiName[] = "Force GDI font rendering";
+const char kForceGdiDescription[] =
+    "Use GDI font rendering in place of DirectWrite font rendering on Windows.";
+
+const char kDisableWindows10CustomTitlebarName[] = "Force disabling of Windows 10 custom titlebar";
+const char kDisableWindows10CustomTitlebarDescription[] =
+    "Disable the \"Windows 10\" custom titlebar to take advantage of Aero Glass fixes for the operating system.";
+
 const char kForceUiDirectionName[] = "Force UI direction";
 const char kForceUiDirectionDescription[] =
     "Explicitly force the UI to left-to-right (LTR) or right-to-left (RTL) "
@@ -1935,6 +1947,10 @@ const char kHideIncognitoMediaMetadataName[] =
 const char kHideIncognitoMediaMetadataDescription[] =
     "When enabled, media metadata will be hidden from your OS' media player "
     "if you are in an Incognito session.";
+	
+const char kUngoogledSupermiumName[] = "\"Ungoogled\" Supermium Mode";
+const char kUngoogledSupermiumDescription[] = "A work in progress - this rolls all new privacy-protecting "
+											"features in Supermium into one option";
 
 const char kTabAudioMutingName[] = "Tab audio muting UI control";
 const char kTabAudioMutingDescription[] =
@@ -2802,6 +2818,16 @@ const char kVmPerBootShaderCacheDescription[] =
 const char kAutoWebContentsDarkModeName[] = "Auto Dark Mode for Web Contents";
 const char kAutoWebContentsDarkModeDescription[] =
     "Automatically render all web contents using a dark theme.";
+	
+const char kForceDarkModeFlagName[] = "Forced Dark Mode for UI";
+const char kForceDarkModeFlagDescription[] = 
+	"Enables dark mode for all UI elements (but not web contents - " 
+	"enable #enable-force-dark for darkening web contents).";
+	
+const char kForceXpThemeName[] = "Use Classic Theme";
+const char kForceXpThemeDescription[] =
+	"Use the classic Chrome theme designed to mimick \"Aero\" window controls. "
+	"Typically used when desktop composition is disabled or unavailable.";
 
 const char kForcedColorsName[] = "Forced Colors";
 const char kForcedColorsDescription[] =
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index 89d8ca8a55114..4dae6401ea729 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1591,6 +1591,18 @@ extern const char kParallelDownloadingDescription[];
 extern const char kPasswordGenerationExperimentName[];
 extern const char kPasswordGenerationExperimentDescription[];
 
+extern const char kDisableDownloadUploadName[];
+extern const char kDisableDownloadUploadDescription[];
+
+extern const char kUngoogledSupermiumName[];
+extern const char kUngoogledSupermiumDescription[];
+
+extern const char kForceGdiName[];
+extern const char kForceGdiDescription[];
+
+extern const char kDisableWindows10CustomTitlebarName[];
+extern const char kDisableWindows10CustomTitlebarDescription[];
+
 extern const char kBacklightOcrName[];
 extern const char kBacklightOcrDescription[];
 
@@ -1609,6 +1621,12 @@ extern const char kBookmarksRefreshDescription[];
 extern const char kAutoWebContentsDarkModeName[];
 extern const char kAutoWebContentsDarkModeDescription[];
 
+extern const char kForceDarkModeFlagName[];
+extern const char kForceDarkModeFlagDescription[];
+
+extern const char kForceXpThemeName[];
+extern const char kForceXpThemeDescription[];
+
 extern const char kForcedColorsName[];
 extern const char kForcedColorsDescription[];
 
diff --git a/chrome/browser/notifications/notification_platform_bridge_win.cc b/chrome/browser/notifications/notification_platform_bridge_win.cc
index 8b8e8e3c6195b..8a45dcc5babcb 100644
--- a/chrome/browser/notifications/notification_platform_bridge_win.cc
+++ b/chrome/browser/notifications/notification_platform_bridge_win.cc
@@ -708,7 +708,7 @@ class NotificationPlatformBridgeWinImpl
         InstallUtil::IsStartMenuShortcutWithActivatorGuidInstalled();
 
     int status = static_cast<int>(SetReadyCallbackStatus::kSuccess);
-    bool enabled = activator_registered && shortcut_installed;
+    bool enabled = base::win::ResolveCoreWinRTDelayload() && ScopedHString::ResolveCoreWinRTStringDelayload() && activator_registered && shortcut_installed;
 
     if (!enabled) {
       if (!shortcut_installed) {
@@ -719,6 +719,8 @@ class NotificationPlatformBridgeWinImpl
         status |= static_cast<int>(
             SetReadyCallbackStatus::kComServerMisconfiguration);
       }
+      if (!(base::win::ResolveCoreWinRTDelayload() && ScopedHString::ResolveCoreWinRTStringDelayload()))
+        status |= static_cast<int>(SetReadyCallbackStatus::kComNotInitialized);
     }
 
     LogSetReadyCallbackStatus(static_cast<SetReadyCallbackStatus>(status));
diff --git a/chrome/browser/notifications/win/notification_metrics.h b/chrome/browser/notifications/win/notification_metrics.h
index 8dfbaea83d66c..aab0938792430 100644
--- a/chrome/browser/notifications/win/notification_metrics.h
+++ b/chrome/browser/notifications/win/notification_metrics.h
@@ -137,8 +137,8 @@ enum class SetReadyCallbackStatus {
   kSuccess = 0,
   kShortcutMisconfiguration = 1 << 0,
   kComServerMisconfiguration = 1 << 1,
-  kComNotInitializedObsolete = 1 << 2,  // No longer possible w/ Win10+ only.
-  kMaxValue = kComNotInitializedObsolete,
+  kComNotInitialized = 1 << 2,
+  kMaxValue = kComNotInitialized,
 };
 
 // These values are persisted to logs. Entries should not be renumbered and
diff --git a/chrome/browser/obsolete_system/obsolete_system_win.cc b/chrome/browser/obsolete_system/obsolete_system_win.cc
index 689026a405de0..356efbd904b66 100644
--- a/chrome/browser/obsolete_system/obsolete_system_win.cc
+++ b/chrome/browser/obsolete_system/obsolete_system_win.cc
@@ -22,16 +22,12 @@ base::win::Version GetRealOSVersion() {
   return base::win::OSInfo::Kernel32Version();
 }
 
-bool IsObsoleteOsVersion() {
-  return GetRealOSVersion() < base::win::Version::WIN10;
-}
-
 }  // namespace
 
 namespace ObsoleteSystem {
 
 bool IsObsoleteNowOrSoon() {
-  return IsObsoleteOsVersion();
+  return false;
 }
 
 std::u16string LocalizedObsoleteString() {
@@ -52,7 +48,7 @@ bool IsEndOfTheLine() {
   // M109 was the last milestone to support Win 7/8/8.1, the last deprecated
   // Windows version. Future deprecations should update this to the last
   // milestone that supports the soon-to-be-deprecated Windows version.
-  return CHROME_VERSION_MAJOR >= 109;
+  return false;
 }
 
 const char* GetLinkURL() {
diff --git a/chrome/browser/sharing_hub/sharing_hub_features.cc b/chrome/browser/sharing_hub/sharing_hub_features.cc
index 57d5a500579aa..f9eeea2a3a7bc 100644
--- a/chrome/browser/sharing_hub/sharing_hub_features.cc
+++ b/chrome/browser/sharing_hub/sharing_hub_features.cc
@@ -69,7 +69,7 @@ bool HasPageAction(content::BrowserContext* context, bool is_popup_mode) {
 
 BASE_FEATURE(kDesktopScreenshots,
              "DesktopScreenshots",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+             base::FEATURE_ENABLED_BY_DEFAULT);
 
 #if !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_CHROMEOS)
 void RegisterProfilePrefs(PrefRegistrySimple* registry) {
diff --git a/chrome/browser/themes/theme_helper_win.cc b/chrome/browser/themes/theme_helper_win.cc
index 259668e16470f..aef2186c2dee7 100644
--- a/chrome/browser/themes/theme_helper_win.cc
+++ b/chrome/browser/themes/theme_helper_win.cc
@@ -8,6 +8,11 @@
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/win/titlebar_config.h"
 #include "chrome/grit/theme_resources.h"
+#include "base/win/windows_version.h"
+
+BASE_FEATURE(kForceXpTheme,
+             "ForceXpTheme",
+             base::FEATURE_DISABLED_BY_DEFAULT);
 
 int ThemeHelperWin::GetDefaultDisplayProperty(int id) const {
   if (id == ThemeProperties::SHOULD_FILL_BACKGROUND_TAB_COLOR) {
@@ -19,5 +24,10 @@ int ThemeHelperWin::GetDefaultDisplayProperty(int id) const {
 
 bool ThemeHelperWin::ShouldUseNativeFrame(
     const CustomThemeSupplier* theme_supplier) const {
-  return true;
+		// If it returns false, the XP fallback theme is used.
+		// And yes, Chromium has muddied the waters of what is considered "native".
+		// Aero Glass is "native", Mica is "native", and so is the Windows 10-style theme that is drawn
+		// by Chromium itself.
+		// Only the "original" Chromium theme that mimicks Aero is not considered native.
+  return (!HasCustomImage(IDR_THEME_FRAME, theme_supplier) && (base::win::GetVersion() >= base::win::Version::VISTA)) && !base::FeatureList::IsEnabled(kForceXpTheme);
 }
diff --git a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
index c6da605fb1f1e..0f5a06fe24912 100644
--- a/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
+++ b/chrome/browser/ui/color/win/native_chrome_color_mixer_win.cc
@@ -8,6 +8,7 @@
 #include "base/functional/bind.h"
 #include "base/no_destructor.h"
 #include "base/win/windows_version.h"
+#include "chrome/browser/themes/browser_theme_pack.h"
 #include "chrome/browser/themes/theme_properties.h"
 #include "chrome/browser/ui/color/chrome_color_id.h"
 #include "chrome/browser/win/titlebar_config.h"
@@ -45,6 +46,13 @@ class FrameColorHelper {
   static FrameColorHelper* Get();
 
  private:
+  // Returns whether there is a custom image provided for the given id.
+  bool HasCustomImage(int id, const ui::ColorProviderKey& key) const;
+
+  // Returns true if colors from DWM can be used, i.e. this is a native frame
+  // on Windows 8+.
+  bool DwmColorsAllowed(const ui::ColorProviderKey& key) const;
+
   // Returns the Tint for the given |id|. If there is no tint, the identity tint
   // {-1, -1, -1} is returned and won't tint the color on which it is used.
   color_utils::HSL GetTint(int id, const ui::ColorProviderKey& key) const;
@@ -89,16 +97,22 @@ void FrameColorHelper::AddNativeChromeColors(
     return absl::nullopt;
   };
 
-  // When we're custom-drawing the titlebar we want to use either the colors
-  // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
-  // custom-drawing the titlebar we want to match the color Windows actually
-  // uses because some things (like the incognito icon) use this color to
-  // decide whether they should draw in light or dark mode. Incognito colors
-  // should be the same as non-incognito in all cases here.
-
-  constexpr SkColor kSystemMicaLightFrameColor =
+  if (DwmColorsAllowed(key)) {
+    // When we're custom-drawing the titlebar we want to use either the colors
+    // we calculated in OnDwmKeyUpdated() or the default colors. When we're not
+    // custom-drawing the titlebar we want to match the color Windows actually
+    // uses because some things (like the incognito icon) use this color to
+    // decide whether they should draw in light or dark mode. Incognito colors
+    // should be the same as non-incognito in all cases here.
+
+    constexpr SkColor kSystemSolidLightFrameColor = SK_ColorWHITE;
+    constexpr SkColor kSystemSolidDarkInactiveFrameColor =
+        SkColorSetRGB(0x2B, 0x2B, 0x2B);
+		
+    constexpr SkColor kSystemMicaLightFrameColor =
       SkColorSetRGB(0xE8, 0xE8, 0xE8);
-  constexpr SkColor kSystemMicaDarkFrameColor = SkColorSetRGB(0x20, 0x20, 0x20);
+    constexpr SkColor kSystemMicaDarkFrameColor = SkColorSetRGB(0x20, 0x20, 0x20);
+
 
   // Dwm colors should always be applied if present for pervasive accent colors
   // pre-refresh. With refresh enabled we should only attempt to paint
@@ -168,13 +182,37 @@ void FrameColorHelper::AddNativeChromeColors(
     mixer[ui::kColorSysHeaderContainerInactive] = {ui::kColorSysBase};
   }
 
-  if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
-    mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
-    mixer[kColorNewTabButtonInkDropFrameActive] =
-        ui::GetColorWithMaxContrast(ui::kColorFrameActive);
-    mixer[kColorNewTabButtonInkDropFrameInactive] =
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE)) {
+      mixer[ui::kColorFrameInactive] = {color.value()};
+    } else if (dwm_inactive_frame_color_) {
+      mixer[ui::kColorFrameInactive] = {dwm_inactive_frame_color_.value()};
+    } else if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemMicaDarkFrameColor
+                                            : kSystemMicaLightFrameColor};
+    } else if (!ShouldCustomDrawSystemTitlebar()) {
+      mixer[ui::kColorFrameInactive] = {key.color_mode == ColorMode::kDark
+                                            ? kSystemSolidDarkInactiveFrameColor
+                                            : kSystemSolidLightFrameColor};
+    } else if (dwm_frame_color_) {
+      mixer[ui::kColorFrameInactive] =
+          ui::HSLShift({dwm_frame_color_.value()},
+                       GetTint(ThemeProperties::TINT_FRAME_INACTIVE, key));
+    }
+
+    if (ShouldDefaultThemeUseMicaTitlebar() && !key.app_controller) {
+      mixer[kColorNewTabButtonBackgroundFrameActive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonBackgroundFrameInactive] = {SK_ColorTRANSPARENT};
+      mixer[kColorNewTabButtonInkDropFrameInactive] =
         ui::GetColorWithMaxContrast(ui::kColorFrameInactive);
+      mixer[kColorNewTabButtonInkDropFrameActive] =
+          ui::GetColorWithMaxContrast(ui::kColorFrameActive);
+    }
+  } else {
+    if (auto color = get_theme_color(TP::COLOR_FRAME_ACTIVE))
+      mixer[ui::kColorFrameActive] = {color.value()};
+    if (auto color = get_theme_color(TP::COLOR_FRAME_INACTIVE))
+      mixer[ui::kColorFrameInactive] = {color.value()};
   }
 }
 
@@ -197,6 +235,19 @@ FrameColorHelper* FrameColorHelper::Get() {
   return g_frame_color_helper.get();
 }
 
+bool FrameColorHelper::HasCustomImage(
+    int id,
+    const ui::ColorProviderKey& key) const {
+  return BrowserThemePack::IsPersistentImageID(id) && key.custom_theme &&
+         key.custom_theme->HasCustomImage(id);
+}
+
+bool FrameColorHelper::DwmColorsAllowed(
+    const ui::ColorProviderKey& key) const {
+  return (!ShouldCustomDrawSystemTitlebar() ||
+         !HasCustomImage(IDR_THEME_FRAME, key));
+}
+
 color_utils::HSL FrameColorHelper::GetTint(
     int id,
     const ui::ColorProviderKey& key) const {
diff --git a/chrome/browser/ui/sharing_hub/screenshot/screenshot_captured_bubble_controller.cc b/chrome/browser/ui/sharing_hub/screenshot/screenshot_captured_bubble_controller.cc
index 298ddbffdd8ed..b7538a3180c05 100644
--- a/chrome/browser/ui/sharing_hub/screenshot/screenshot_captured_bubble_controller.cc
+++ b/chrome/browser/ui/sharing_hub/screenshot/screenshot_captured_bubble_controller.cc
@@ -35,7 +35,6 @@ void ScreenshotCapturedBubbleController::ShowBubble(
   const gfx::Image& captured_image = image.image;
   ui::ScopedClipboardWriter(ui::ClipboardBuffer::kCopyPaste)
       .WriteImage(*captured_image.ToSkBitmap());
-
   Browser* browser = chrome::FindBrowserWithWebContents(&GetWebContents());
   browser->window()->ShowScreenshotCapturedBubble(&GetWebContents(),
                                                   captured_image);
diff --git a/chrome/browser/ui/startup/bad_flags_prompt.cc b/chrome/browser/ui/startup/bad_flags_prompt.cc
index fd2bd40a10288..f984e16e57281 100644
--- a/chrome/browser/ui/startup/bad_flags_prompt.cc
+++ b/chrome/browser/ui/startup/bad_flags_prompt.cc
@@ -73,7 +73,6 @@ const char* const kBadFlags[] = {
     sandbox::policy::switches::kDisableGpuSandbox,
     sandbox::policy::switches::kDisableSeccompFilterSandbox,
     sandbox::policy::switches::kDisableSetuidSandbox,
-    sandbox::policy::switches::kNoSandbox,
 #if BUILDFLAG(IS_WIN)
     sandbox::policy::switches::kAllowThirdPartyModules,
 #endif
diff --git a/chrome/browser/ui/test/test_browser_ui.cc b/chrome/browser/ui/test/test_browser_ui.cc
index 2f61aef15bbf8..2b49f57680e6f 100644
--- a/chrome/browser/ui/test/test_browser_ui.cc
+++ b/chrome/browser/ui/test/test_browser_ui.cc
@@ -5,6 +5,7 @@
 #include "chrome/browser/ui/test/test_browser_ui.h"
 
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/test/gtest_util.h"
 #include "base/test/test_switches.h"
 #include "build/build_config.h"
@@ -159,8 +160,8 @@ void TestBrowserUi::ShowAndVerifyUi() {
   // Gold files for pixel tests are for light mode, so if dark mode is not
   // forced, and host is in dark mode, skip test.
   if (!IsInteractiveUi() &&
-      !base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode) &&
+      (!base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag) &&
       ui::NativeTheme::GetInstanceForNativeUi()->ShouldUseDarkColors()) {
     GTEST_SKIP() << "Host is in dark mode; skipping test";
   }
diff --git a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
index ac17822240248..87d4c7ca95ede 100644
--- a/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
+++ b/chrome/browser/ui/views/frame/browser_desktop_window_tree_host_win.cc
@@ -465,6 +465,9 @@ void BrowserDesktopWindowTreeHostWin::PostHandleMSG(UINT message,
 }
 
 views::FrameMode BrowserDesktopWindowTreeHostWin::GetFrameMode() const {
+  if (browser_view_->GetIsWebAppType()) 
+	  return views::FrameMode::CUSTOM_DRAWN; 
+  
   const views::FrameMode system_frame_mode =
       ShouldBrowserCustomDrawTitlebar(browser_view_)
           ? views::FrameMode::SYSTEM_DRAWN_NO_CONTROLS
@@ -494,11 +497,13 @@ bool BrowserDesktopWindowTreeHostWin::ShouldUseNativeFrame() const {
   if (!browser_view_->browser())
     return false;
 
-  // We don't theme popup or app windows, so regardless of whether or not a
-  // theme is active for normal browser windows, we don't want to use the custom
-  // frame for popups/apps.
-  if (!browser_view_->GetIsNormalType())
-    return true;
+  // Use the custom frame where desired.
+  if (!browser_view_->GetIsNormalType()) {
+	 if(!browser_view_->GetIsWebAppType() && GetWidget()->GetThemeProvider()->ShouldUseNativeFrame())
+		return true;
+	 else
+		return false;
+  }
   // Otherwise, we use the native frame when we're told we should by the theme
   // provider (e.g. no custom theme is active).
   return GetWidget()->GetThemeProvider()->ShouldUseNativeFrame();
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.cc b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
index 769e7e8ac3b39..8579e6a095305 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.cc
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.cc
@@ -409,7 +409,7 @@ void BrowserFrameViewWin::ResetWindowControls() {
 void BrowserFrameViewWin::OnThemeChanged() {
   BrowserNonClientFrameView::OnThemeChanged();
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
@@ -649,24 +649,26 @@ bool BrowserFrameViewWin::ShouldShowWindowTitle(TitlebarType type) const {
 
 void BrowserFrameViewWin::TabletModeChanged() {
   if (!ShouldBrowserCustomDrawTitlebar(browser_view())) {
-    SetSystemMicaTitlebarAttributes();
+    SetSystemTitlebarAttributes();
   }
 }
 
-void BrowserFrameViewWin::SetSystemMicaTitlebarAttributes() {
-  CHECK(SystemTitlebarCanUseMicaMaterial());
-
-  const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
-                        sizeof(dark_titlebar_enabled));
+void BrowserFrameViewWin::SetSystemTitlebarAttributes() {
+  if (SystemTitlebarSupportsDarkMode()) {
+    const BOOL dark_titlebar_enabled = GetNativeTheme()->ShouldUseDarkColors();
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_USE_IMMERSIVE_DARK_MODE, &dark_titlebar_enabled,
+                          sizeof(dark_titlebar_enabled));
+  }
 
-  const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
-      browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
-                                           : DWMSBT_MAINWINDOW;
-  DwmSetWindowAttribute(views::HWNDForWidget(frame()),
-                        DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
-                        sizeof(dwm_backdrop_type));
+  if (ShouldBrowserUseMicaTitlebar(browser_view())) {
+    const DWM_SYSTEMBACKDROP_TYPE dwm_backdrop_type =
+        browser_view()->GetTabStripVisible() ? DWMSBT_TABBEDWINDOW
+                                             : DWMSBT_MAINWINDOW;
+    DwmSetWindowAttribute(views::HWNDForWidget(frame()),
+                          DWMWA_SYSTEMBACKDROP_TYPE, &dwm_backdrop_type,
+                          sizeof(dwm_backdrop_type));
+  }
 }
 
 SkColor BrowserFrameViewWin::GetTitlebarColor() const {
diff --git a/chrome/browser/ui/views/frame/browser_frame_view_win.h b/chrome/browser/ui/views/frame/browser_frame_view_win.h
index d984437fca46f..bd9a8c6f72dfd 100644
--- a/chrome/browser/ui/views/frame/browser_frame_view_win.h
+++ b/chrome/browser/ui/views/frame/browser_frame_view_win.h
@@ -144,8 +144,8 @@ class BrowserFrameViewWin : public BrowserNonClientFrameView,
   // Called when the device enters or exits tablet mode.
   void TabletModeChanged();
 
-  // Sets DWM attributes for rendering the system-drawn Mica titlebar.
-  void SetSystemMicaTitlebarAttributes();
+  // Sets DWM attributes for rendering the system-drawn titlebar.
+  void SetSystemTitlebarAttributes();
 
   // Paint various sub-components of this view.
   void PaintTitlebar(gfx::Canvas* canvas) const;
diff --git a/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc b/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
index 1bf912250ff05..e768404fabf43 100644
--- a/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
+++ b/chrome/browser/ui/views/sharing_hub/screenshot/screenshot_captured_bubble.cc
@@ -65,6 +65,7 @@ ScreenshotCapturedBubble::ScreenshotCapturedBubble(
       image_(image),
       web_contents_(web_contents->GetWeakPtr()),
       profile_(profile) {
+
   SetButtons(ui::DIALOG_BUTTON_NONE);
   SetTitle(IDS_BROWSER_SHARING_SCREENSHOT_POST_CAPTURE_TITLE);
 }
diff --git a/chrome/browser/webshare/win/fake_storage_file_statics.cc b/chrome/browser/webshare/win/fake_storage_file_statics.cc
index 6308ccec3a576..f17033b2d1ec7 100644
--- a/chrome/browser/webshare/win/fake_storage_file_statics.cc
+++ b/chrome/browser/webshare/win/fake_storage_file_statics.cc
@@ -9,7 +9,6 @@
 #include <wrl/module.h>
 
 #include <memory>
-#include <string>
 #include <tuple>
 
 #include "base/functional/bind.h"
@@ -279,6 +278,13 @@ IFACEMETHODIMP FakeStorageFileStatics::CreateStreamedFileAsync(
     IStreamedFileDataRequestedHandler* data_requested,
     IRandomAccessStreamReference* thumbnail,
     IAsyncOperation<StorageFile*>** operation) {
+
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    ADD_FAILURE() << "Attempted to use FakeStorageFileStatics in an "
+                     "environment that doesn't support ScopedHStrings.";
+    return E_UNEXPECTED;
+  }
+
   auto fake_iasync_operation =
       Make<base::win::FakeIAsyncOperation<StorageFile*>>();
   HRESULT hr = fake_iasync_operation->QueryInterface(IID_PPV_ARGS(operation));
diff --git a/chrome/browser/webshare/win/share_operation.cc b/chrome/browser/webshare/win/share_operation.cc
index ef09f08ba9cf4..8747e21cbe552 100644
--- a/chrome/browser/webshare/win/share_operation.cc
+++ b/chrome/browser/webshare/win/share_operation.cc
@@ -370,6 +370,13 @@ void ShareOperation::Run(blink::mojom::ShareService::ShareCallback callback) {
   DCHECK(!callback_);
   callback_ = std::move(callback);
 
+  // Ensure that the required WinRT functionality is available/loaded.
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    Complete(blink::mojom::ShareError::INTERNAL_ERROR);
+    return;
+  }
+
   // If the corresponding web_contents have already been cleaned up, cancel
   // the operation.
   if (!web_contents_) {
diff --git a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
index 15f2def437648..021f9f2b55471 100644
--- a/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
+++ b/chrome/browser/webshare/win/show_share_ui_for_window_operation.cc
@@ -40,6 +40,12 @@ HRESULT GetDataTransferManagerHandles(
     HWND hwnd,
     IDataTransferManagerInterop** data_transfer_manager_interop,
     IDataTransferManager** data_transfer_manager) {
+
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return E_FAIL;
+  }
+
   // IDataTransferManagerInterop is semi-hidden behind a CloakedIid
   // structure on the DataTransferManager, excluding it from things
   // used by RoGetActivationFactory like GetIids(). Because of this,
diff --git a/chrome/browser/win/titlebar_config.cc b/chrome/browser/win/titlebar_config.cc
index f088a7071b1e0..48729bce514dd 100644
--- a/chrome/browser/win/titlebar_config.cc
+++ b/chrome/browser/win/titlebar_config.cc
@@ -4,28 +4,55 @@
 
 #include "chrome/browser/win/titlebar_config.h"
 
+#include <Windows.h>
+#include "base/command_line.h"
 #include "base/win/windows_version.h"
 #include "chrome/browser/themes/theme_service.h"
 #include "chrome/browser/themes/theme_service_factory.h"
 #include "chrome/browser/ui/views/frame/browser_view.h"
+#include "chrome/common/chrome_switches.h"
 #include "ui/color/win/accent_color_observer.h"
 #include "ui/native_theme/native_theme.h"
 
-// Allows the titlebar to be drawn by the system using the Mica material
-// on Windows 11, version 22H2 and above.
-BASE_FEATURE(kWindows11MicaTitlebar,
-             "Windows11MicaTitlebar",
-             base::FEATURE_DISABLED_BY_DEFAULT);
+bool ShouldCustomDrawSystemTitlebar() {
+  // Some extra code added here because those with pre-win8 and no DWM will have to fallback on the custom titlebar.
+  BOOL result = FALSE;
+	
+  typedef HRESULT(WINAPI* DwmIsCompositionEnabledFunc)(BOOL* enabled);
+  DwmIsCompositionEnabledFunc func_ = nullptr;
+	
+  HMODULE dwmapi_library_ = LoadLibraryW(L"dwmapi.dll");
+  if (dwmapi_library_) {
+    func_ = reinterpret_cast<DwmIsCompositionEnabledFunc>(
+        GetProcAddress(dwmapi_library_, "DwmIsCompositionEnabled"));
+  }
+  else
+	  return true;
+  
+  if (func_) {
+	  func_(&result);
+  }
+  else
+	  return true;
+  // Cache flag lookup.
+  static const bool custom_titlebar_disabled =
+      base::CommandLine::InitializedForCurrentProcess() &&
+      base::CommandLine::ForCurrentProcess()->HasSwitch(
+          switches::kDisableWindows10CustomTitlebar);
+
+  return (!custom_titlebar_disabled &&
+         base::win::GetVersion() >= base::win::Version::WIN10) || !result;
+}
 
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view) {
-  return !ShouldDefaultThemeUseMicaTitlebar() ||
-         !ThemeServiceFactory::GetForProfile(browser_view->GetProfile())
-              ->UsingSystemTheme() ||
+
+  return ShouldCustomDrawSystemTitlebar() ||
          (!browser_view->browser()->is_type_normal() &&
           !browser_view->browser()->is_type_popup() &&
           !browser_view->browser()->is_type_devtools());
 }
 
+
 bool ShouldDefaultThemeUseMicaTitlebar() {
   return SystemTitlebarCanUseMicaMaterial() &&
          !ui::AccentColorObserver::Get()->use_dwm_frame_color() &&
@@ -34,6 +61,13 @@ bool ShouldDefaultThemeUseMicaTitlebar() {
 }
 
 bool SystemTitlebarCanUseMicaMaterial() {
-  return base::win::GetVersion() >= base::win::Version::WIN11_22H2 &&
-         base::FeatureList::IsEnabled(kWindows11MicaTitlebar);
+  return false;
+}
+
+bool ShouldBrowserUseMicaTitlebar(class BrowserView *) {
+  return false;
+}
+
+bool SystemTitlebarSupportsDarkMode() {
+  return base::win::GetVersion() >= base::win::Version::WIN11;
 }
diff --git a/chrome/browser/win/titlebar_config.h b/chrome/browser/win/titlebar_config.h
index 48f413792d5aa..596d9ad041c21 100644
--- a/chrome/browser/win/titlebar_config.h
+++ b/chrome/browser/win/titlebar_config.h
@@ -10,10 +10,18 @@
 class BrowserView;
 
 BASE_DECLARE_FEATURE(kWindows11MicaTitlebar);
+BASE_DECLARE_FEATURE(kForceXpTheme);
 
 // Returns whether we should custom draw the titlebar for a browser window.
 bool ShouldBrowserCustomDrawTitlebar(BrowserView* browser_view);
 
+// Returns whether we should always custom draw the system title bar.
+bool ShouldCustomDrawSystemTitlebar();
+
+// Returns whether we should use the Mica titlebar material for a browser
+// window.
+bool ShouldBrowserUseMicaTitlebar(BrowserView* browser_view);
+
 // Returns whether we should use the Mica titlebar in standard browser windows
 // using the default theme.
 bool ShouldDefaultThemeUseMicaTitlebar();
@@ -22,4 +30,7 @@ bool ShouldDefaultThemeUseMicaTitlebar();
 // material.
 bool SystemTitlebarCanUseMicaMaterial();
 
+// Returns whether the system-drawn titlebar can be drawn in dark mode.
+bool SystemTitlebarSupportsDarkMode();
+
 #endif  // CHROME_BROWSER_WIN_TITLEBAR_CONFIG_H_
diff --git a/chrome/chrome_elf/chrome_elf_security.cc b/chrome/chrome_elf/chrome_elf_security.cc
index ea44babfb52ea..045b3a6221712 100644
--- a/chrome/chrome_elf/chrome_elf_security.cc
+++ b/chrome/chrome_elf/chrome_elf_security.cc
@@ -82,6 +82,7 @@ class ExtensionPointDisableSet {
 }  // namespace
 
 void EarlyBrowserSecurity() {
+  typedef decltype(SetProcessMitigationPolicy)* SetProcessMitigationPolicyFunc;
   // This function is called from within DllMain.
   // Don't do anything naughty while we have the loader lock.
   NTSTATUS ret_val = STATUS_SUCCESS;
@@ -105,12 +106,20 @@ void EarlyBrowserSecurity() {
 
   nt::CloseRegKey(handle);
 
-  // Disable extension points (legacy hooking) in this process.
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  policy.DisableExtensionPoints = true;
-  SetProcessMitigationPolicy(ProcessExtensionPointDisablePolicy, &policy,
-                             sizeof(policy));
-  ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+  if (::IsWindows8OrGreater()) {
+    SetProcessMitigationPolicyFunc set_process_mitigation_policy =
+        reinterpret_cast<SetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "SetProcessMitigationPolicy"));
+    if (set_process_mitigation_policy) {
+      // Disable extension points in this process.
+      // (Legacy hooking.)
+      PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+      policy.DisableExtensionPoints = true;
+      set_process_mitigation_policy(ProcessExtensionPointDisablePolicy, &policy,
+                                    sizeof(policy));
+      ExtensionPointDisableSet::GetInstance()->SetExtensionPointDisabled(true);
+    }
+  }
 
   return;
 }
diff --git a/chrome/chrome_elf/chrome_elf_util_unittest.cc b/chrome/chrome_elf/chrome_elf_util_unittest.cc
index 5ee09effb6e03..3af5789ad6185 100644
--- a/chrome/chrome_elf/chrome_elf_util_unittest.cc
+++ b/chrome/chrome_elf/chrome_elf_util_unittest.cc
@@ -4,6 +4,8 @@
 
 #include <windows.h>
 
+#include <versionhelpers.h>  // windows.h must be before.
+
 #include <tuple>
 
 #include "base/test/test_reg_util_win.h"
@@ -37,14 +39,28 @@ bool SetExtensionPointEnabledFlag(bool creation) {
 }
 
 bool IsSecuritySet() {
-  // Check that extension points are disabled. (Legacy hooking.)
-  PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                    ProcessExtensionPointDisablePolicy, &policy,
-                                    sizeof(policy))) {
-    return false;
+  typedef decltype(GetProcessMitigationPolicy)* GetProcessMitigationPolicyFunc;
+
+  // Check the settings from EarlyBrowserSecurity().
+  if (::IsWindows8OrGreater()) {
+    GetProcessMitigationPolicyFunc get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunc>(::GetProcAddress(
+            ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (!get_process_mitigation_policy)
+      return false;
+
+    // Check that extension points are disabled.
+    // (Legacy hooking.)
+    PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
+    if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                       ProcessExtensionPointDisablePolicy,
+                                       &policy, sizeof(policy)))
+      return false;
+
+    return policy.DisableExtensionPoints;
   }
-  return policy.DisableExtensionPoints;
+
+  return true;
 }
 
 void RegRedirect(nt::ROOT_KEY key,
@@ -70,6 +86,9 @@ void CancelRegRedirect(nt::ROOT_KEY key) {
 }
 
 TEST(ChromeElfUtilTest, ValidateExtensionPointCallComesFromDLL) {
+
+  if (!::IsWindows8OrGreater())
+    return;
   // We should validate the exe version isn't used for this test
   elf_security::ValidateExeForTesting(true);
 
@@ -78,6 +97,8 @@ TEST(ChromeElfUtilTest, ValidateExtensionPointCallComesFromDLL) {
 }
 
 TEST(ChromeElfUtilTest, BrowserProcessSecurityTest) {
+  if (!::IsWindows8OrGreater())
+    return;
   // Set up registry override for this test.
   registry_util::RegistryOverrideManager override_manager;
   ASSERT_NO_FATAL_FAILURE(RegRedirect(nt::HKCU, &override_manager));
diff --git a/chrome/chrome_elf/hook_util/hook_util.cc b/chrome/chrome_elf/hook_util/hook_util.cc
index ce309c8b6888b..96ab0afa9bbf3 100644
--- a/chrome/chrome_elf/hook_util/hook_util.cc
+++ b/chrome/chrome_elf/hook_util/hook_util.cc
@@ -8,6 +8,9 @@
 #include <versionhelpers.h>  // windows.h must be before
 
 #include "base/win/pe_image.h"
+#include "chrome/chrome_elf/nt_registry/nt_registry.h"  // utils
+#include "sandbox/win/src/internal_types.h"
+#include "sandbox/win/src/service_resolver.h"
 
 namespace {
 
@@ -194,6 +197,44 @@ DWORD RemoveIATHook(void* intercept_function,
 
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed) {
+  // Create a thunk via the appropriate ServiceResolver instance.
+  sandbox::ServiceResolverThunk* thunk = nullptr;
+
+  // No hooking on unsupported OS versions.
+  if (!::IsWindows7OrGreater())
+    return thunk;
+
+  // Pseudo-handle, no need to close.
+  HANDLE current_process = ::GetCurrentProcess();
+
+#if defined(_WIN64)
+  // ServiceResolverThunk can handle all the formats in 64-bit (instead only
+  // handling one like it does in 32-bit versions).
+  thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+#else
+  BOOL is_wow64 = FALSE;
+  if (::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64) {
+    if (::IsWindows10OrGreater())
+      thunk = new sandbox::Wow64W10ResolverThunk(current_process, relaxed);
+    else if (::IsWindows8OrGreater())
+      thunk = new sandbox::Wow64W8ResolverThunk(current_process, relaxed);
+    else
+      thunk = new sandbox::Wow64ResolverThunk(current_process, relaxed);
+  } else if (::IsWindows8OrGreater()) {
+    thunk = new sandbox::Win8ResolverThunk(current_process, relaxed);
+  } else {
+    thunk = new sandbox::ServiceResolverThunk(current_process, relaxed);
+  }
+#endif
+
+  return thunk;
+}
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/chrome_elf/hook_util/hook_util.h b/chrome/chrome_elf/hook_util/hook_util.h
index 9070b9d93a6f0..687042ec330c7 100644
--- a/chrome/chrome_elf/hook_util/hook_util.h
+++ b/chrome/chrome_elf/hook_util/hook_util.h
@@ -7,8 +7,20 @@
 
 #include <windows.h>
 
+namespace sandbox {
+class ServiceResolverThunk;
+}
+
 namespace elf_hook {
 
+//------------------------------------------------------------------------------
+// System Service hooking support
+//------------------------------------------------------------------------------
+
+// Creates a |ServiceResolverThunk| based on the OS version. Ownership of the
+// resulting thunk is passed to the caller.
+sandbox::ServiceResolverThunk* HookSystemService(bool relaxed);
+
 //------------------------------------------------------------------------------
 // Import Address Table hooking support
 //------------------------------------------------------------------------------
diff --git a/chrome/common/chrome_constants.cc b/chrome/common/chrome_constants.cc
index 3a39e2bb7b608..f3926eb56e280 100644
--- a/chrome/common/chrome_constants.cc
+++ b/chrome/common/chrome_constants.cc
@@ -16,7 +16,7 @@
 #elif BUILDFLAG(GOOGLE_CHROME_FOR_TESTING_BRANDING)
 #define PRODUCT_STRING "Google Chrome for Testing"
 #elif BUILDFLAG(CHROMIUM_BRANDING)
-#define PRODUCT_STRING "Chromium"
+#define PRODUCT_STRING "Supermium"
 #else
 #error Unknown branding
 #endif
diff --git a/chrome/common/chrome_switches.cc b/chrome/common/chrome_switches.cc
index 203854c109335..c287212aa9e7a 100644
--- a/chrome/common/chrome_switches.cc
+++ b/chrome/common/chrome_switches.cc
@@ -776,7 +776,15 @@ const char kRelauncherProcessDMGDevice[] = "dmg-device";
 const char kMakeChromeDefault[] = "make-chrome-default";
 #endif  // BUILDFLAG(IS_MAC)
 
+const char kDisableDownloadUpload[] = "disable-download-upload";
+
+const char kUngoogledSupermium[] = "ungoogled-supermium";
+
 #if BUILDFLAG(IS_WIN)
+// Disables custom-drawing the window titlebar on Windows 10.
+const char kDisableWindows10CustomTitlebar[] =
+    "disable-windows10-custom-titlebar";
+
 // Force-enables the profile shortcut manager. This is needed for tests since
 // they use a custom-user-data-dir which disables this.
 const char kEnableProfileShortcutManager[] = "enable-profile-shortcut-manager";
diff --git a/chrome/common/chrome_switches.h b/chrome/common/chrome_switches.h
index 3939a1c43cff2..d2db193cad1a6 100644
--- a/chrome/common/chrome_switches.h
+++ b/chrome/common/chrome_switches.h
@@ -246,7 +246,11 @@ extern const char kRelauncherProcessDMGDevice[];
 extern const char kMakeChromeDefault[];
 #endif  // BUILDFLAG(IS_MAC)
 
+extern const char kDisableDownloadUpload[];
+extern const char kUngoogledSupermium[];
+
 #if BUILDFLAG(IS_WIN)
+extern const char kDisableWindows10CustomTitlebar[];
 extern const char kEnableProfileShortcutManager[];
 extern const char kFromInstaller[];
 extern const char kHideIcons[];
diff --git a/chrome/install_static/chromium_install_modes.cc b/chrome/install_static/chromium_install_modes.cc
index 0ffb200b16e34..fd2505849c776 100644
--- a/chrome/install_static/chromium_install_modes.cc
+++ b/chrome/install_static/chromium_install_modes.cc
@@ -16,7 +16,7 @@ namespace install_static {
 
 const wchar_t kCompanyPathName[] = L"";
 
-const wchar_t kProductPathName[] = L"Chromium";
+const wchar_t kProductPathName[] = L"Supermium";
 
 const size_t kProductPathNameLength = _countof(kProductPathName) - 1;
 
@@ -34,14 +34,14 @@ const InstallConstants kInstallModes[] = {
         .logo_suffix = L"",  // No logo suffix for the primary install mode.
         .app_guid =
             L"",  // Empty app_guid since no integration with Google Update.
-        .base_app_name = L"Chromium",              // A distinct base_app_name.
-        .base_app_id = L"Chromium",                // A distinct base_app_id.
-        .browser_prog_id_prefix = L"ChromiumHTM",  // Browser ProgID prefix.
+        .base_app_name = L"Supemium",              // A distinct base_app_name.
+        .base_app_id = L"Supemium",                // A distinct base_app_id.
+        .browser_prog_id_prefix = L"SupemiumHTM",  // Browser ProgID prefix.
         .browser_prog_id_description =
-            L"Chromium HTML Document",         // Browser ProgID description.
-        .pdf_prog_id_prefix = L"ChromiumPDF",  // PDF ProgID prefix.
+            L"Supermium HTML Document",         // Browser ProgID description.
+        .pdf_prog_id_prefix = L"SupermiumPDF",  // PDF ProgID prefix.
         .pdf_prog_id_description =
-            L"Chromium PDF Document",  // PDF ProgID description.
+            L"Supermium PDF Document",  // PDF ProgID description.
         .active_setup_guid =
             L"{7D2B3E1D-D096-4594-9D8F-A6667F12E0AC}",  // Active Setup GUID.
         .legacy_command_execute_clsid =
diff --git a/chrome/installer/setup/install.cc b/chrome/installer/setup/install.cc
index e5d72ffd39ded..baf105aaf9f48 100644
--- a/chrome/installer/setup/install.cc
+++ b/chrome/installer/setup/install.cc
@@ -28,6 +28,7 @@
 #include "base/strings/utf_string_conversions.h"
 #include "base/time/time.h"
 #include "base/win/shortcut.h"
+#include "base/win/windows_version.h"
 #include "chrome/install_static/install_details.h"
 #include "chrome/install_static/install_util.h"
 #include "chrome/installer/setup/install_params.h"
@@ -135,6 +136,7 @@ void ExecuteAndLogShortcutOperation(
   // For Start Menu shortcut creation on versions of Win10 that support
   // pinning, record whether or not the installer pinned Chrome.
   if (location == ShellUtil::SHORTCUT_LOCATION_START_MENU_ROOT &&
+      base::win::GetVersion() >= base::win::Version::WIN10 &&
       CanPinShortcutToTaskbar()) {
     SetInstallerPinnedChromeToTaskbar(properties.pin_to_taskbar && pinned);
   }
diff --git a/chrome/installer/setup/setup_util.cc b/chrome/installer/setup/setup_util.cc
index f7f654d7b979a..578c5fd2db6c6 100644
--- a/chrome/installer/setup/setup_util.cc
+++ b/chrome/installer/setup/setup_util.cc
@@ -374,7 +374,7 @@ bool ContainsUnsupportedSwitch(const base::CommandLine& cmd_line) {
 
 bool IsProcessorSupported() {
 #if defined(ARCH_CPU_X86_FAMILY)
-  return base::CPU().has_sse3();
+  return base::CPU().has_sse2();
 #elif defined(ARCH_CPU_ARM64)
   return true;
 #else
diff --git a/chrome/installer/util/install_util.cc b/chrome/installer/util/install_util.cc
index 5efc79e743383..1bf0bf47f68e4 100644
--- a/chrome/installer/util/install_util.cc
+++ b/chrome/installer/util/install_util.cc
@@ -242,10 +242,10 @@ base::Version InstallUtil::GetCriticalUpdateVersion() {
 }
 
 bool InstallUtil::IsOSSupported() {
-  // We do not support anything prior to Windows 10.
+  // We do not support anything prior to Windows Vista.
   VLOG(1) << base::SysInfo::OperatingSystemName() << ' '
           << base::SysInfo::OperatingSystemVersion();
-  return base::win::GetVersion() >= base::win::Version::WIN10;
+  return base::win::GetVersion() >= base::win::Version::VISTA;
 }
 
 void InstallUtil::AddInstallerResultItems(bool system_install,
diff --git a/chrome/installer/util/shell_util.cc b/chrome/installer/util/shell_util.cc
index 7f20d494956cd..b2fc2f967de55 100644
--- a/chrome/installer/util/shell_util.cc
+++ b/chrome/installer/util/shell_util.cc
@@ -297,12 +297,13 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
     entries->back()->set_removal_flag(RegistryEntry::RemovalFlag::VALUE);
   }
 
-  // The following entries are required but do not depend on the DelegateExecute
-  // verb handler being set.
-  if (!app_info.app_id.empty()) {
-    entries->push_back(std::make_unique<RegistryEntry>(
-        prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
-  }
+  // The following entries are required as of Windows 8, but do not
+  // depend on the DelegateExecute verb handler being set.
+  if (base::win::GetVersion() >= base::win::Version::WIN8) {
+    if (!app_info.app_id.empty()) {
+      entries->push_back(std::make_unique<RegistryEntry>(
+          prog_id_path, ShellUtil::kRegAppUserModelId, app_info.app_id));
+    }
 
   // Add \Software\Classes\<prog_id>\Application entries
   std::wstring application_path(prog_id_path + ShellUtil::kRegApplication);
@@ -332,6 +333,7 @@ void GetProgIdEntries(const ShellUtil::ApplicationInfo& app_info,
         app_info.publisher_name));
   }
 }
+}
 
 // This method returns a list of all the registry entries that are needed to
 // register this installation's ProgIds and AppId.
@@ -744,11 +746,12 @@ bool QuickIsChromeRegisteredForMode(
   }
   reg_key += ShellUtil::kRegShellOpen;
 
-  // ProgId and shell integration registrations are allowed to reside in HKCU
-  // for user-level installs, and values there have priority over values in
-  // HKLM.
+  // ProgId registrations are allowed to reside in HKCU for user-level installs
+  // (and values there have priority over values in HKLM). The same is true for
+  // shell integration entries as of Windows 8.
   if (confirmation_level == CONFIRM_PROGID_REGISTRATION ||
-      confirmation_level == CONFIRM_SHELL_REGISTRATION) {
+      (confirmation_level == CONFIRM_SHELL_REGISTRATION &&
+       base::win::GetVersion() >= base::win::Version::WIN8)) {
     const RegKey key_hkcu(HKEY_CURRENT_USER, reg_key.c_str(), KEY_QUERY_VALUE);
     std::wstring hkcu_value;
     // If |reg_key| is present in HKCU, assert that it points to |chrome_exe|.
@@ -823,7 +826,9 @@ bool GetInstallationSpecificSuffix(const base::FilePath& chrome_exe,
 // be placed for this install. As of Windows 8 everything can go in HKCU for
 // per-user installs.
 HKEY DetermineRegistrationRoot(bool is_per_user) {
-  return is_per_user ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;
+    return is_per_user && base::win::GetVersion() >= base::win::Version::WIN8
+             ? HKEY_CURRENT_USER
+             : HKEY_LOCAL_MACHINE;
 }
 
 // Associates Chrome with supported protocols and file associations. This should
@@ -1042,6 +1047,7 @@ ShellUtil::DefaultState ProbeProtocolHandlers(const base::FilePath& chrome_exe,
 // Returns true on success.
 bool GetAppShortcutsFolder(ShellUtil::ShellChange level, base::FilePath* path) {
   DCHECK(path);
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN8);
 
   base::FilePath folder;
   if (!base::PathService::Get(base::DIR_APP_SHORTCUTS, &folder)) {
@@ -1419,6 +1425,7 @@ bool RegisterChromeBrowserImpl(const base::FilePath& chrome_exe,
 bool RegisterApplicationForProtocols(const std::vector<std::wstring>& protocols,
                                      const std::wstring& prog_id,
                                      const base::FilePath& chrome_exe) {
+  DCHECK_GT(base::win::GetVersion(), base::win::Version::WIN7);
   std::vector<std::unique_ptr<RegistryEntry>> entries;
   ShellUtil::ApplicationInfo app_info =
       ShellUtil::GetApplicationInfoForProgId(prog_id);
@@ -1571,10 +1578,12 @@ bool ShellUtil::ShortcutLocationIsSupported(ShortcutLocation location) {
     case SHORTCUT_LOCATION_START_MENU_ROOT:                   // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_DIR_DEPRECATED:  // Falls through.
     case SHORTCUT_LOCATION_START_MENU_CHROME_APPS_DIR:        // Falls through.
-    case SHORTCUT_LOCATION_STARTUP:                           // Falls through.
-    case SHORTCUT_LOCATION_TASKBAR_PINS:                      // Falls through.
-    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+    case SHORTCUT_LOCATION_STARTUP:
       return true;
+    case SHORTCUT_LOCATION_TASKBAR_PINS:
+      return base::win::GetVersion() >= base::win::Version::WIN7;
+    case SHORTCUT_LOCATION_APP_SHORTCUTS:
+      return base::win::GetVersion() >= base::win::Version::WIN8;
     default:
       NOTREACHED();
       return false;
@@ -2520,16 +2529,19 @@ bool ShellUtil::AddAppProtocolAssociations(
     if (!AddRegistryEntries(HKEY_CURRENT_USER, entries))
       success = false;
 
-    // Removing the existing user choice for a given protocol forces Windows to
-    // present a disambiguation dialog the next time this protocol is invoked
-    // from the OS.
-    std::unique_ptr<RegistryEntry> entry = GetProtocolUserChoiceEntry(protocol);
-    if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
-                                        WorkItem::kWow64Default, kRegProgId)) {
-      success = false;
+    // On Windows 10, removing the existing user choice for a given protocol
+    // forces Windows to present a disambiguation dialog the next time this
+    // protocol is invoked from the OS.
+    if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      std::unique_ptr<RegistryEntry> entry =
+          GetProtocolUserChoiceEntry(protocol);
+      if (!installer::DeleteRegistryValue(HKEY_CURRENT_USER, entry->key_path(),
+                                          WorkItem::kWow64Default,
+                                          kRegProgId)) {
+        success = false;
+      }
     }
   }
-
   return success;
 }
 
diff --git a/chrome/services/util_win/processor_metrics.cc b/chrome/services/util_win/processor_metrics.cc
index 29c5bb2dd47f4..8742d122b3879 100644
--- a/chrome/services/util_win/processor_metrics.cc
+++ b/chrome/services/util_win/processor_metrics.cc
@@ -7,7 +7,6 @@
 #include <objbase.h>
 #include <sysinfoapi.h>
 #include <wbemidl.h>
-#include <winbase.h>
 #include <wrl/client.h>
 
 #include "base/metrics/histogram_functions.h"
@@ -110,63 +109,36 @@ void RecordCetAvailability() {
           ::GetProcAddress(::GetModuleHandleW(L"kernel32.dll"),
                            "IsUserCetAvailableInEnvironment"));
 
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+
   if (is_user_cet_available_in_environment) {
     available = is_user_cet_available_in_environment(
         USER_CET_ENVIRONMENT_WIN32_PROCESS);
   }
   base::UmaHistogramBoolean("Windows.CetAvailable", available);
 
-  if (available) {
+  if (available && get_process_mitigation_policy) {
     PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {0};
-    if (::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                     ProcessUserShadowStackPolicy, &policy,
-                                     sizeof(policy))) {
+    if (get_process_mitigation_policy(GetCurrentProcess(),
+                                      ProcessUserShadowStackPolicy, &policy,
+                                      sizeof(policy))) {
       base::UmaHistogramBoolean("Windows.CetEnabled",
                                 policy.EnableUserShadowStack);
     }
   }
 }
 
-void RecordEnclaveAvailabilityInternal(base::StringPiece type,
-                                       DWORD enclave_type) {
-  // This API does not appear to be exported from kernel32.dll on
-  // Windows 10.0.10240.
-  static auto is_enclave_type_supported_func =
-      reinterpret_cast<decltype(&IsEnclaveTypeSupported)>(::GetProcAddress(
-          ::GetModuleHandleW(L"kernel32.dll"), "IsEnclaveTypeSupported"));
-
-  bool is_supported = false;
-
-  if (is_enclave_type_supported_func) {
-    is_supported = is_enclave_type_supported_func(enclave_type);
-  }
-
-  base::UmaHistogramBoolean(
-      base::StrCat({"Windows.Enclave.", type, ".Available"}), is_supported);
-}
-
-void RecordEnclaveAvailability() {
-  RecordEnclaveAvailabilityInternal("SGX", ENCLAVE_TYPE_SGX);
-  RecordEnclaveAvailabilityInternal("SGX2", ENCLAVE_TYPE_SGX2);
-  RecordEnclaveAvailabilityInternal("VBS", ENCLAVE_TYPE_VBS);
-  RecordEnclaveAvailabilityInternal("VBSBasic", ENCLAVE_TYPE_VBS_BASIC);
-}
-
 void RecordProcessorMetrics() {
-  // These metrics do not require a WMI connection.
+  base::ScopedBlockingCall scoped_blocking_call(FROM_HERE,
+                                                base::BlockingType::MAY_BLOCK);
+  ComPtr<IWbemServices> wmi_services;
+  if (!base::win::CreateLocalWmiConnection(true, &wmi_services))
+    return;
+  RecordProcessorMetricsFromWMI(wmi_services);
+  RecordHypervStatusFromWMI(wmi_services);
   RecordCetAvailability();
-  RecordEnclaveAvailability();
-
-  {
-    base::ScopedBlockingCall scoped_blocking_call(
-        FROM_HERE, base::BlockingType::MAY_BLOCK);
-    ComPtr<IWbemServices> wmi_services;
-    if (!base::win::CreateLocalWmiConnection(true, &wmi_services)) {
-      return;
-    }
-    RecordProcessorMetricsFromWMI(wmi_services);
-    RecordHypervStatusFromWMI(wmi_services);
-  }
 }
 
 }  // namespace
diff --git a/chrome/updater/net/network_fetcher_win.cc b/chrome/updater/net/network_fetcher_win.cc
index bc2127fedcd84..a985a08a8b622 100644
--- a/chrome/updater/net/network_fetcher_win.cc
+++ b/chrome/updater/net/network_fetcher_win.cc
@@ -20,9 +20,11 @@
 #include "base/sequence_checker.h"
 #include "base/strings/sys_string_conversions.h"
 #include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
 #include "chrome/updater/policy/service.h"
 #include "chrome/updater/util/util.h"
 #include "chrome/updater/util/win_util.h"
+#include "chrome/updater/win/scoped_impersonation.h"
 #include "chrome/updater/win/user_info.h"
 #include "components/update_client/network.h"
 #include "components/winhttp/network_fetcher.h"
@@ -33,6 +35,56 @@
 
 namespace updater {
 namespace {
+	
+	std::wstring FromCharOrEmpty(const wchar_t* str) {
+  return str ? std::wstring(str) : std::wstring();
+}
+
+// Wrapper for WINHTTP_CURRENT_USER_IE_PROXY_CONFIG structure.
+// According to MSDN, callers must free strings with GlobalFree.
+class ScopedIeProxyConfig {
+ public:
+  ScopedIeProxyConfig();
+  ScopedIeProxyConfig(const ScopedIeProxyConfig&) = delete;
+  ScopedIeProxyConfig& operator=(const ScopedIeProxyConfig&) = delete;
+  ~ScopedIeProxyConfig();
+
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* receive() { return &ie_proxy_config_; }
+
+  bool auto_detect() const { return ie_proxy_config_.fAutoDetect; }
+  std::wstring auto_config_url() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszAutoConfigUrl);
+  }
+  std::wstring proxy() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxy);
+  }
+  std::wstring proxy_bypass() const {
+    return FromCharOrEmpty(ie_proxy_config_.lpszProxyBypass);
+  }
+
+ private:
+  WINHTTP_CURRENT_USER_IE_PROXY_CONFIG ie_proxy_config_ = {};
+};
+
+ScopedIeProxyConfig::ScopedIeProxyConfig() {
+  ie_proxy_config_.fAutoDetect = false;
+  ie_proxy_config_.lpszAutoConfigUrl = nullptr;
+  ie_proxy_config_.lpszProxy = nullptr;
+  ie_proxy_config_.lpszProxyBypass = nullptr;
+}
+
+ScopedIeProxyConfig::~ScopedIeProxyConfig() {
+  if (ie_proxy_config_.lpszAutoConfigUrl)
+    ::GlobalFree(ie_proxy_config_.lpszAutoConfigUrl);
+
+  if (ie_proxy_config_.lpszProxy)
+    ::GlobalFree(ie_proxy_config_.lpszProxy);
+
+  if (ie_proxy_config_.lpszProxyBypass)
+    ::GlobalFree(ie_proxy_config_.lpszProxyBypass);
+}
+
+
 
 // Factory method for the proxy configuration strategy.
 scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
@@ -50,7 +102,32 @@ scoped_refptr<winhttp::ProxyConfiguration> GetProxyConfiguration(
 
   VLOG(1) << "Using the system configuration for proxy.";
 
-  return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+   const base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  const bool supports_automatic_proxy =
+      os_info->version() >= base::win::Version::WIN8_1;
+  if (supports_automatic_proxy) {
+    return base::MakeRefCounted<winhttp::AutoProxyConfiguration>();
+  }
+
+  ScopedImpersonation impersonate_user;
+  if (IsLocalSystemUser()) {
+    VLOG(2) << "Running as SYSTEM, impersonate the current user.";
+    base::win::ScopedHandle user_token = GetUserTokenFromCurrentSessionId();
+    if (user_token.IsValid()) {
+      impersonate_user.Impersonate(user_token.Get());
+    }
+  }
+
+  ScopedIeProxyConfig ie_proxy_config;
+  if (::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config.receive())) {
+    return base::MakeRefCounted<winhttp::ProxyConfiguration>(winhttp::ProxyInfo{
+        ie_proxy_config.auto_detect(), ie_proxy_config.auto_config_url(),
+        ie_proxy_config.proxy(), ie_proxy_config.proxy_bypass()});
+  } else {
+    PLOG(ERROR) << "Failed to get proxy for current user";
+  }
+
+  return base::MakeRefCounted<winhttp::ProxyConfiguration>();
 }
 
 class NetworkFetcher : public update_client::NetworkFetcher {
diff --git a/chrome/updater/win/installer/installer.cc b/chrome/updater/win/installer/installer.cc
index 649d8af0f3cb0..7d1945fb57275 100644
--- a/chrome/updater/win/installer/installer.cc
+++ b/chrome/updater/win/installer/installer.cc
@@ -342,7 +342,7 @@ ProcessExitResult InstallerMain(HMODULE module) {
   CHECK(EnableSecureDllLoading());
   EnableProcessHeapMetadataProtection();
 
-  if (base::win::GetVersion() < base::win::Version::WIN10) {
+  if (base::win::GetVersion() < base::win::Version::VISTA) {
     return ProcessExitResult(UNSUPPORTED_WINDOWS_VERSION);
   }
 
diff --git a/components/embedder_support/user_agent_utils.cc b/components/embedder_support/user_agent_utils.cc
index c957a691efcac..59bcdbb763bc2 100644
--- a/components/embedder_support/user_agent_utils.cc
+++ b/components/embedder_support/user_agent_utils.cc
@@ -88,13 +88,45 @@ int GetPreRS5UniversalApiContractVersion() {
     return 6;
   }
   // The list above should account for all Windows versions prior to
-  // RS5.
-  NOTREACHED();
+  // RS5. 0 represents all pre-Win10 releases.
   return 0;
 }
 
+int GetLegacyWindowsVersion() {
+// The User Agent Client Hints specification indicates that Windows 7 through 8.x
+// should be handled as having a major version of 0 while using the OS' minor version.
+// (i.e. Windows 7 is 0.1). This does not account for how to handle Windows Vista and below.
+// As a result, Vista will report as 0.60 and NT 5.x as 0.5x.
+// TODO: introduce UA-CH spoofer to avoid any undesirable impacts of having the "wrong" values in future.
+	const base::win::Version version = base::win::OSInfo::Kernel32Version();
+	if (version == base::win::Version::WIN8_1) {
+		return 3;
+	}
+	if (version == base::win::Version::WIN8) {
+		return 2;
+	}
+	if (version == base::win::Version::WIN7) {
+		return 1;
+	}
+	if (version == base::win::Version::VISTA) {
+		return 60;
+	}
+	if (version == base::win::Version::SERVER_2003) {
+		return 52;
+	}
+	if (version == base::win::Version::XP) {
+		return 51;
+	}	
+	if (version == base::win::Version::PRE_XP) {
+		return 50;
+	}	
+	return 0;
+}
+
 // Returns the UniversalApiContract version number, which is available for
-// Windows versions greater than RS5. Otherwise, returns 0.
+// Windows versions greater than RS5. Otherwise, returns a version value
+// representing the Windows version (non-zero major version for early Windows 10,
+// non-zero minor version for pre-Windows 10).
 const std::string& GetUniversalApiContractVersion() {
   // Do not use this for runtime environment detection logic. This method should
   // only be used to help populate the Sec-CH-UA-Platform client hint. If
@@ -108,6 +140,7 @@ const std::string& GetUniversalApiContractVersion() {
         if (base::win::OSInfo::Kernel32Version() <=
             base::win::Version::WIN10_RS4) {
           major_version = GetPreRS5UniversalApiContractVersion();
+		  minor_version = GetLegacyWindowsVersion();
         } else {
           base::win::RegKey version_key(
               HKEY_LOCAL_MACHINE, kWindowsRuntimeWellKnownContractsRegKeyName,
diff --git a/components/metrics/motherboard.cc b/components/metrics/motherboard.cc
index 4b2270d10a86d..e97bde5ddf5d1 100644
--- a/components/metrics/motherboard.cc
+++ b/components/metrics/motherboard.cc
@@ -16,6 +16,7 @@
 #if BUILDFLAG(IS_WIN)
 #include <windows.h>
 
+#include "base/scoped_native_library.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/threading/scoped_blocking_call.h"
 #include "base/win/scoped_bstr.h"
@@ -142,7 +143,19 @@ void ReadWin32Bios(const ComPtr<IWbemServices>& services,
 
 void ReadFirmwareType(absl::optional<Motherboard::BiosType>* bios_type) {
   FIRMWARE_TYPE firmware_type = FirmwareTypeUnknown;
-  if (::GetFirmwareType(&firmware_type)) {
+  // NOTE: GetFirmwareType API only exists on >= Win8.  Dynamically
+  //       get function handle.
+  using GetFirmwareTypeFunction = decltype(&GetFirmwareType);
+  base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+  if (!dll.is_valid())
+    return;
+  GetFirmwareTypeFunction get_firmware_type_function =
+      reinterpret_cast<GetFirmwareTypeFunction>(
+          dll.GetFunctionPointer("GetFirmwareType"));
+  if (!get_firmware_type_function)
+    return;
+
+  if (get_firmware_type_function(&firmware_type)) {
     if (firmware_type == FirmwareTypeBios) {
       *bios_type = Motherboard::BiosType::kLegacy;
     } else if (firmware_type == FirmwareTypeUefi) {
diff --git a/components/system_media_controls/win/system_media_controls_win.cc b/components/system_media_controls/win/system_media_controls_win.cc
index 8e6430f0832db..9291a58c2c003 100644
--- a/components/system_media_controls/win/system_media_controls_win.cc
+++ b/components/system_media_controls/win/system_media_controls_win.cc
@@ -9,11 +9,6 @@
 #include <wrl/client.h>
 #include <wrl/event.h>
 
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
 #include "base/strings/string_piece.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/win/core_winrt_util.h"
@@ -91,6 +86,11 @@ bool SystemMediaControlsWin::Initialize() {
 
   attempted_to_initialize_ = true;
 
+  if (!base::win::ResolveCoreWinRTDelayload() ||
+      !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+    return false;
+  }
+
   Microsoft::WRL::ComPtr<ISystemMediaTransportControlsInterop> interop;
   HRESULT hr = base::win::GetActivationFactory<
       ISystemMediaTransportControlsInterop,
diff --git a/content/app/initialize_mojo_core.cc b/content/app/initialize_mojo_core.cc
index 6600e576a857f..6259f4a0754e9 100644
--- a/content/app/initialize_mojo_core.cc
+++ b/content/app/initialize_mojo_core.cc
@@ -20,6 +20,10 @@
 #include "mojo/public/cpp/system/dynamic_library_support.h"
 #include "sandbox/policy/sandbox_type.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace content {
 
 void InitializeMojoCore() {
@@ -52,9 +56,16 @@ void InitializeMojoCore() {
       config.force_direct_shared_memory_allocation = true;
   } else {
 #if BUILDFLAG(IS_WIN)
-    // On Windows it's not necessary to broker shared memory allocation, as
-    // even sandboxed processes can allocate their own without trouble.
-    config.force_direct_shared_memory_allocation = true;
+    if (base::win::GetVersion() >= base::win::Version::WIN8_1) {
+      // On Windows 8.1 and later it's not necessary to broker shared memory
+      // allocation, as even sandboxed processes can allocate their own without
+      // trouble.
+      config.force_direct_shared_memory_allocation = true;
+    }
+#elif BUILDFLAG(IS_ANDROID)
+    // On Android we run a Finch experiment testing direct memory allocation.
+    config.force_direct_shared_memory_allocation = base::FeatureList::IsEnabled(
+        mojo::core::kMojoDirectSharedMemoryAndroid);
 #endif
   }
 
diff --git a/content/browser/BUILD.gn b/content/browser/BUILD.gn
index 576f6e3b2ef21..471ef0a39818e 100644
--- a/content/browser/BUILD.gn
+++ b/content/browser/BUILD.gn
@@ -2839,6 +2839,8 @@ source_set("browser") {
       "renderer_host/direct_manipulation_helper_win.h",
       "renderer_host/dwrite_font_file_util_win.cc",
       "renderer_host/dwrite_font_file_util_win.h",
+      "renderer_host/dwrite_font_lookup_table_builder_win.cc",
+      "renderer_host/dwrite_font_lookup_table_builder_win.h",
       "renderer_host/dwrite_font_proxy_impl_win.cc",
       "renderer_host/dwrite_font_proxy_impl_win.h",
       "renderer_host/legacy_render_widget_host_win.cc",
diff --git a/content/browser/browser_main_loop.cc b/content/browser/browser_main_loop.cc
index 0c63eb5ecf270..b62f9c6c8b994 100644
--- a/content/browser/browser_main_loop.cc
+++ b/content/browser/browser_main_loop.cc
@@ -193,6 +193,7 @@
 #include <windows.h>
 
 #include "base/threading/platform_thread_win.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "net/base/winsock_init.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
@@ -1002,6 +1003,16 @@ int BrowserMainLoop::PreMainMessageLoopRun() {
 
   variations::MaybeScheduleFakeCrash();
 
+#if BUILDFLAG(IS_WIN)
+  // ShellBrowserMainParts initializes a ShellBrowserContext with a profile
+  // directory only in PreMainMessageLoopRun(). DWriteFontLookupTableBuilder
+  // needs to access this directory, hence triggering after this stage has run.
+  if (base::FeatureList::IsEnabled(features::kFontSrcLocalMatching)) {
+    content::DWriteFontLookupTableBuilder::GetInstance()
+        ->SchedulePrepareFontUniqueNameTableIfNeeded();
+  }
+#endif  // BUILDFLAG(IS_WIN)
+
   // Unretained(this) is safe as the main message loop expected to run it is
   // stopped before ~BrowserMainLoop (in the event the message loop doesn't
   // reach idle before that point).
diff --git a/content/browser/installedapp/installed_app_provider_impl_win.cc b/content/browser/installedapp/installed_app_provider_impl_win.cc
index 252da4a57d373..4f379ef5a3d65 100644
--- a/content/browser/installedapp/installed_app_provider_impl_win.cc
+++ b/content/browser/installedapp/installed_app_provider_impl_win.cc
@@ -112,6 +112,13 @@ void FilterInstalledAppsForWin(
     std::vector<blink::mojom::RelatedApplicationPtr> related_apps,
     blink::mojom::InstalledAppProvider::FilterInstalledAppsCallback callback,
     const GURL frame_url) {
+
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload() ||
+      !base::win::ResolveCoreWinRTDelayload()) {
+    std::move(callback).Run(std::vector<blink::mojom::RelatedApplicationPtr>());
+    return;
+  }
+
   ComPtr<ILauncherStatics4> launcher_statics;
   HRESULT hr = base::win::RoActivateInstance(
       base::win::ScopedHString::Create(RuntimeClass_Windows_System_Launcher)
diff --git a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
index b141cfe3cc2e6..711838407f765 100644
--- a/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
+++ b/content/browser/ppapi_plugin_sandboxed_process_launcher_delegate.cc
@@ -12,6 +12,7 @@
 #include "sandbox/policy/mojom/sandbox.mojom.h"
 
 #if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox_policy.h"
@@ -34,8 +35,10 @@ bool PpapiPluginSandboxedProcessLauncherDelegate::InitializeConfig(
   // create the server side of Chrome pipes.
   sandbox::ResultCode result;
 #if !defined(NACL_WIN64)
+  // We don't support PPAPI win32k lockdown prior to Windows 10.
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
   result = sandbox::policy::SandboxWin::AddWin32kLockdownPolicy(config);
-  if (result != sandbox::SBOX_ALL_OK) {
+  if (result != sandbox::SBOX_ALL_OK) 
     return false;
   }
 #endif  // !defined(NACL_WIN64)
diff --git a/content/browser/renderer_host/direct_manipulation_helper_win.cc b/content/browser/renderer_host/direct_manipulation_helper_win.cc
index b04194c32a4d1..d760a109ff576 100644
--- a/content/browser/renderer_host/direct_manipulation_helper_win.cc
+++ b/content/browser/renderer_host/direct_manipulation_helper_win.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/memory/ptr_util.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/base/win/window_event_target.h"
 #include "ui/compositor/compositor.h"
@@ -27,6 +28,10 @@ DirectManipulationHelper::CreateInstance(HWND window,
   if (!::IsWindow(window) || !compositor || !event_target)
     return nullptr;
 
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
+
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(window, compositor));
 
@@ -41,6 +46,9 @@ std::unique_ptr<DirectManipulationHelper>
 DirectManipulationHelper::CreateInstanceForTesting(
     ui::WindowEventTarget* event_target,
     Microsoft::WRL::ComPtr<IDirectManipulationViewport> viewport) {
+  // DM_POINTERHITTEST supported since Win10.
+  if (base::win::GetVersion() < base::win::Version::WIN10)
+    return nullptr;
   std::unique_ptr<DirectManipulationHelper> instance =
       base::WrapUnique(new DirectManipulationHelper(0, nullptr));
 
@@ -173,9 +181,12 @@ void DirectManipulationHelper::OnPointerHitTest(WPARAM w_param) {
   // For WM_POINTER, the pointer type will show the event from mouse.
   // For WM_POINTERACTIVATE, the pointer id will be different with the following
   // message.
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(pointer_id, &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     viewport_->SetContact(pointer_id);
   }
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
new file mode 100644
index 0000000000000..2547e1d5e893b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.cc
@@ -0,0 +1,771 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+
+#include <set>
+#include <utility>
+
+#include "base/file_version_info.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/hash/hash.h"
+#include "base/i18n/case_conversion.h"
+#include "base/metrics/histogram_functions.h"
+#include "base/metrics/histogram_macros.h"
+#include "base/no_destructor.h"
+#include "base/path_service.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/task/sequenced_task_runner.h"
+#include "base/task/task_traits.h"
+#include "base/task/thread_pool.h"
+#include "base/threading/scoped_blocking_call.h"
+#include "base/threading/thread_restrictions.h"
+#include "base/trace_event/trace_event.h"
+#include "base/types/optional_util.h"
+#include "base/version.h"
+#include "base/win/registry.h"
+#include "content/browser/renderer_host/dwrite_font_file_util_win.h"
+#include "content/browser/renderer_host/dwrite_font_proxy_impl_win.h"
+#include "content/public/browser/content_browser_client.h"
+#include "content/public/common/content_client.h"
+#include "content/public/common/content_features.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_table_persistence.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "ui/gfx/win/direct_write.h"
+
+namespace content {
+
+namespace {
+
+const base::FilePath::CharType kProtobufFilename[] =
+    FILE_PATH_LITERAL("font_unique_name_table.pb");
+
+// Timeout after which font scanning and metadata extraction is stopped and the
+// local lookup table is cleared. Font scanning and lookup table construction is
+// only needed pre Windows 10. If the timeout is hit, no local font matching
+// will be performed on this particular pre Win 10 system.
+constexpr base::TimeDelta kFontIndexingTimeoutDefault = base::Minutes(5);
+
+// In timeout test case, slow down indexing of one font file to this percentage
+// of the timeout value. Assuming that at least two fonts are indexed, the
+// timeout should be usually hit during indexing the second font.
+constexpr float kIndexingSlowDownForTestingPercentage = 0.75;
+
+// Additional local custom interface specific HRESULT codes (also added to
+// enums.xml) to mark font scanning implementation specific error situations, as
+// part of reporting them in a UMA metric.
+constexpr HRESULT kErrorFontScanningTimedOut =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD101);
+constexpr HRESULT kErrorExtractingLocalizedStringsFailed =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD102);
+constexpr HRESULT kErrorNoFullNameOrPostScriptName =
+    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xD103);
+
+bool ExtractCaseFoldedLocalizedStrings(
+    IDWriteLocalizedStrings* dwrite_localized_strings,
+    std::vector<std::string>* localized_strings) {
+  uint32_t strings_count = dwrite_localized_strings->GetCount();
+
+  if (!strings_count)
+    return false;
+
+  localized_strings->reserve(localized_strings->size() + strings_count);
+  for (UINT32 j = 0; j < strings_count; ++j) {
+    UINT32 length;
+    HRESULT hr = dwrite_localized_strings->GetStringLength(j, &length);
+    if (FAILED(hr))
+      continue;
+    std::wstring localized_name;
+    localized_name.resize(length + 1);
+    hr = dwrite_localized_strings->GetString(j, &localized_name[0], length + 1);
+    if (FAILED(hr)) {
+      continue;
+    }
+    localized_name.resize(length);
+    // The documentation for the API call does not specify an encoding but the
+    // results are wchar_t and FireFox considers them UTF-16, as seen here:
+    // https://dxr.mozilla.org/mozilla-central/source/gfx/thebes/gfxDWriteFontList.cpp#90
+    // so we'll assume that.
+    localized_strings->push_back(base::UTF16ToUTF8(
+        base::i18n::FoldCase(base::WideToUTF16(localized_name))));
+  }
+  return true;
+}
+
+bool EnsureCacheDirectory(base::FilePath cache_directory) {
+  // If the directory does not exist already, ensure that the parent directory
+  // exists, which is usually the User Data directory. If it exists, we can try
+  // creating the cache directory.
+  return !cache_directory.empty() &&
+         (base::DirectoryExists(cache_directory) ||
+          (base::DirectoryExists(cache_directory.DirName()) &&
+           CreateDirectory(cache_directory)));
+}
+
+}  // namespace
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    blink::FontUniqueNameTable_UniqueFont&& font,
+    std::vector<std::string>&& names)
+    : font_entry(std::move(font)), extracted_names(std::move(names)) {}
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::
+    ~FontFileWithUniqueNames() = default;
+
+DWriteFontLookupTableBuilder::FontFileWithUniqueNames::FontFileWithUniqueNames(
+    DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other) = default;
+
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult() = default;
+DWriteFontLookupTableBuilder::FamilyResult::FamilyResult(FamilyResult&& other) =
+    default;
+DWriteFontLookupTableBuilder::FamilyResult::~FamilyResult() = default;
+
+DWriteFontLookupTableBuilder::DWriteFontLookupTableBuilder()
+    : font_indexing_timeout_(kFontIndexingTimeoutDefault) {
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::InitializeCacheDirectoryFromProfile() {
+  // Unit tests that do not launch a full browser environment usually don't need
+  // testing of src:local()-style font matching. Check that an environment is
+  // present here and configcure the cache directory based on that. If none is
+  // configured, catch this in DuplicateMemoryRegion(), i.e. when a client
+  // tries to use this API.
+  cache_directory_ =
+      GetContentClient() && GetContentClient()->browser()
+          ? GetContentClient()->browser()->GetFontLookupTableCacheDir()
+          : base::FilePath();
+}
+
+DWriteFontLookupTableBuilder::~DWriteFontLookupTableBuilder() = default;
+
+base::ReadOnlySharedMemoryRegion
+DWriteFontLookupTableBuilder::DuplicateMemoryRegion() {
+  DCHECK(!TableCacheFilePath().empty())
+      << "Ensure that a cache_directory_ is set (see "
+         "InitializeCacheDirectoryFromProfile())";
+  DCHECK(FontUniqueNameTableReady());
+  return font_table_memory_.region.Duplicate();
+}
+
+bool DWriteFontLookupTableBuilder::IsFontUniqueNameTableValid() {
+  return font_table_memory_.IsValid() && font_table_memory_.mapping.size();
+}
+
+void DWriteFontLookupTableBuilder::InitializeDirectWrite() {
+  if (direct_write_initialized_)
+    return;
+  direct_write_initialized_ = true;
+
+  Microsoft::WRL::ComPtr<IDWriteFactory> factory;
+  gfx::win::CreateDWriteFactory(&factory);
+  if (factory == nullptr) {
+    // We won't be able to load fonts, but we should still return messages so
+    // renderers don't hang if they for some reason send us a font message.
+    return;
+  }
+
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
+  factory.As<IDWriteFactory3>(&factory3_);
+
+  HRESULT hr = factory->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+
+  if (!collection_) {
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.GetSystemFontCollectionResult", hr);
+    return;
+  }
+}
+
+std::string DWriteFontLookupTableBuilder::ComputePersistenceHash(
+    const std::string& browser_version) {
+  // Build a hash from DWrite product version, browser major version and font
+  // names and file paths as stored in the registry. The browser major version
+  // is included to ensure that the cache is rebuild at least once for every
+  // Chrome milestone release. DWrite DLL version is included to ensure that any
+  // change in DWrite behavior after an update does not interfere with the
+  // information we have in the cache. The font registry keys and values are
+  // used to detect changes in installed fonts.
+
+  std::unique_ptr<FileVersionInfo> dwrite_version_info =
+      FileVersionInfo::CreateFileVersionInfo(
+          base::FilePath(FILE_PATH_LITERAL("DWrite.dll")));
+
+  DCHECK(dwrite_version_info);
+
+  std::string dwrite_version =
+      base::UTF16ToUTF8(dwrite_version_info->product_version());
+
+  std::string to_hash = dwrite_version;
+
+  const wchar_t kFonts[] =
+      L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
+  base::win::RegistryValueIterator it(HKEY_LOCAL_MACHINE, kFonts);
+  for (; it.Valid(); ++it) {
+    to_hash.append(base::WideToUTF8(it.Name()));
+    to_hash.append(base::WideToUTF8(it.Value()));
+  }
+
+  base::Version full_version = base::Version(browser_version);
+
+  // Version can be an empty string on trybots.
+  if (full_version.IsValid()) {
+    to_hash.append(base::NumberToString(full_version.components()[0]));
+  }
+
+  uint32_t fonts_changed_hash = base::PersistentHash(to_hash);
+  return std::to_string(fonts_changed_hash);
+}
+
+void DWriteFontLookupTableBuilder::SetCacheDirectoryForTesting(
+    base::FilePath cache_directory) {
+  cache_directory_ = cache_directory;
+}
+
+void DWriteFontLookupTableBuilder::SetCachingEnabledForTesting(
+    bool caching_enabled) {
+  caching_enabled_ = caching_enabled;
+}
+
+bool DWriteFontLookupTableBuilder::HasDWriteUniqueFontLookups() {
+  InitializeDirectWrite();
+  return factory3_;
+}
+
+void DWriteFontLookupTableBuilder::OverrideDWriteVersionChecksForTesting() {
+  InitializeDirectWrite();
+  factory3_.Reset();
+}
+
+base::TimeDelta DWriteFontLookupTableBuilder::IndexingTimeout() {
+  return font_indexing_timeout_;
+}
+
+void DWriteFontLookupTableBuilder::PostCallbacks() {
+  callbacks_task_runner_->StartWithTaskRunner(
+      base::ThreadPool::CreateSequencedTaskRunner({
+#if DCHECK_IS_ON()
+            // Needed for DCHECK in DuplicateMemoryRegion() which performs file
+            // operations to detect cache directory.
+            base::MayBlock(),
+#endif
+            base::TaskPriority::USER_VISIBLE,
+            base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN
+      }));
+}
+
+base::FilePath DWriteFontLookupTableBuilder::TableCacheFilePath() {
+  if (!EnsureCacheDirectory(cache_directory_))
+    return base::FilePath();
+  return cache_directory_.Append(kProtobufFilename);
+}
+
+bool DWriteFontLookupTableBuilder::PersistToFile() {
+  DCHECK(caching_enabled_);
+
+  if (!IsFontUniqueNameTableValid())
+    return false;
+
+  return blink::font_table_persistence::PersistToFile(font_table_memory_,
+                                                      TableCacheFilePath());
+}
+
+bool DWriteFontLookupTableBuilder::LoadFromFile() {
+  DCHECK(caching_enabled_);
+  DCHECK(!IsFontUniqueNameTableValid());
+
+  return blink::font_table_persistence::LoadFromFile(TableCacheFilePath(),
+                                                     &font_table_memory_);
+}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    scoped_refptr<base::SequencedTaskRunner> runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback)
+    : task_runner(std::move(runner)), mojo_callback(std::move(callback)) {}
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::CallbackOnTaskRunner(
+    CallbackOnTaskRunner&& other) = default;
+
+DWriteFontLookupTableBuilder::CallbackOnTaskRunner::~CallbackOnTaskRunner() =
+    default;
+
+void DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady(
+    scoped_refptr<base::SequencedTaskRunner> task_runner,
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::QueueShareMemoryRegionWhenReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+
+  // base::Unretained(this) acceptable as bound argument here since
+  // DWriteFontLookupTableBuilder is a singleton instance.
+  callbacks_task_runner_->PostTask(
+      FROM_HERE,
+      base::BindOnce(
+          &DWriteFontLookupTableBuilder::RunPendingCallback,
+          base::Unretained(this),
+          CallbackOnTaskRunner(std::move(task_runner), std::move(callback))));
+}
+
+bool DWriteFontLookupTableBuilder::FontUniqueNameTableReady() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FontUniqueNameTableReady");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  return font_table_built_.IsSet() && IsFontUniqueNameTableValid();
+}
+
+void DWriteFontLookupTableBuilder::
+    SchedulePrepareFontUniqueNameTableIfNeeded() {
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+    InitializeDirectWrite();
+  }
+
+  // Nothing to do if we have API to directly lookup local fonts by unique name
+  // (as on Windows 10, IDWriteFactory3 available).
+  if (HasDWriteUniqueFontLookups())
+    return;
+
+  // Do not schedule indexing if we do not have a profile or temporary directory
+  // to store the cached table. This prevents repetitive and redundant scanning
+  // when the ContentBrowserClient did not provide a cache directory, as is the
+  // case in content_unittests.
+  if (TableCacheFilePath().empty())
+    return;
+
+  start_time_table_ready_ = base::TimeTicks::Now();
+  scanning_error_reasons_.clear();
+
+  scoped_refptr<base::SequencedTaskRunner> results_collection_task_runner =
+      base::ThreadPool::CreateSequencedTaskRunner(
+          {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+           base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN});
+
+  std::string browser_version =
+      GetContentClient()->browser()->GetUserAgentMetadata().full_version;
+  results_collection_task_runner->PostTask(
+      FROM_HERE,
+      base::BindOnce(&DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable,
+                     base::Unretained(this), browser_version));
+}
+
+void DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable(
+    const std::string& browser_version) {
+  if (!collection_) {
+    return;
+  }
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::PrepareFontUniqueNameTable");
+  DCHECK(!HasDWriteUniqueFontLookups());
+  // The table must only be built once.
+  DCHECK(!font_table_built_.IsSet());
+
+  if (caching_enabled_ && LoadFromFile()) {
+    blink::FontUniqueNameTable font_table;
+    const bool update_needed =
+        !IsFontUniqueNameTableValid() ||
+        !font_table.ParseFromArray(font_table_memory_.mapping.memory(),
+                                   font_table_memory_.mapping.size()) ||
+        font_table.stored_for_platform_version_identifier() !=
+            ComputePersistenceHash(browser_version);
+
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTableDiskCacheHit",
+                          !update_needed);
+    if (!update_needed) {
+      base::TimeDelta duration =
+          base::TimeTicks::Now() - start_time_table_ready_;
+      UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                                 duration);
+      font_table_built_.Set();
+      PostCallbacks();
+      return;
+    }
+  }
+
+  start_time_table_build_ = base::TimeTicks::Now();
+  font_unique_name_table_ = std::make_unique<blink::FontUniqueNameTable>();
+
+  // The |stored_for_platform_version_identifier| proto field is used for
+  // persisting the table to disk and identifying whether an update to the
+  // table is needed when loading it back.
+  font_unique_name_table_->set_stored_for_platform_version_identifier(
+      ComputePersistenceHash(browser_version));
+
+  {
+    base::ScopedBlockingCall scoped_blocking_call(
+        FROM_HERE, base::BlockingType::MAY_BLOCK);
+
+    outstanding_family_results_ = collection_->GetFontFamilyCount();
+    family_results_empty_ = 0;
+    family_results_non_empty_ = 0;
+    UMA_HISTOGRAM_CUSTOM_COUNTS(
+        "DirectWrite.Fonts.Proxy.FamilyCountIndexingStart",
+        outstanding_family_results_, 1, 5000, 50);
+  }
+  for (UINT32 family_index = 0; family_index < outstanding_family_results_;
+       ++family_index) {
+    // Specify base::ThreadPolicy::MUST_USE_FOREGROUND because in
+    // https://crbug.com/960263 we observed a priority inversion when running
+    // DWrite worker tasks in the background.
+    base::ThreadPool::PostTaskAndReplyWithResult(
+        FROM_HERE,
+        {base::MayBlock(), base::TaskPriority::BEST_EFFORT,
+         base::ThreadPolicy::MUST_USE_FOREGROUND,
+         base::TaskShutdownBehavior::CONTINUE_ON_SHUTDOWN},
+        base::BindOnce(
+            &ExtractPathAndNamesFromFamily, collection_, family_index,
+            start_time_table_build_, slow_down_mode_for_testing_,
+            OptionalToPtr(hang_event_for_testing_), IndexingTimeout()),
+        base::BindOnce(&DWriteFontLookupTableBuilder::
+                           AppendFamilyResultAndFinalizeIfNeeded,
+                       base::Unretained(this)));
+  }
+  // Post a task to catch timeouts should one of the
+  // tasks will eventually not reply.
+  timeout_callback_.Reset(base::BindOnce(
+      &DWriteFontLookupTableBuilder::OnTimeout, base::Unretained(this)));
+  base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(
+      FROM_HERE, timeout_callback_.callback(), IndexingTimeout());
+}
+
+// static
+DWriteFontLookupTableBuilder::FamilyResult
+DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily(
+    Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+    uint32_t family_index,
+    base::TimeTicks start_time,
+    SlowDownMode slow_down_mode_for_testing,
+    base::WaitableEvent* hang_event_for_testing,
+    base::TimeDelta indexing_timeout) {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::ExtractPathAndNamesFromFamily");
+
+  static base::NoDestructor<std::u16string> windows_fonts_path(
+      GetWindowsFontsPath());
+
+  DWriteFontLookupTableBuilder::FamilyResult family_result;
+
+  if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+    family_result.exit_hresult = kErrorFontScanningTimedOut;
+    return family_result;
+  }
+
+  Microsoft::WRL::ComPtr<IDWriteFontFamily> family;
+  HRESULT hr = collection->GetFontFamily(family_index, &family);
+  if (FAILED(hr)) {
+    family_result.exit_hresult = hr;
+    return family_result;
+  }
+  UINT32 font_count = family->GetFontCount();
+
+  HRESULT last_hresult_continue_reason = S_OK;
+  for (UINT32 font_index = 0; font_index < font_count; ++font_index) {
+    if (base::TimeTicks::Now() - start_time > indexing_timeout) {
+      family_result.exit_hresult = kErrorFontScanningTimedOut;
+      return family_result;
+    }
+
+    Microsoft::WRL::ComPtr<IDWriteFont> font;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = family->GetFont(font_index, &font);
+    }
+    if (FAILED(hr)) {
+      family_result.exit_hresult = hr;
+      return family_result;
+    }
+
+    if (font->GetSimulations() != DWRITE_FONT_SIMULATIONS_NONE)
+      continue;
+
+    std::set<std::wstring> path_set;
+    std::set<std::wstring> custom_font_path_set;
+    uint32_t ttc_index = 0;
+    {
+      base::ScopedBlockingCall scoped_blocking_call(
+          FROM_HERE, base::BlockingType::MAY_BLOCK);
+      hr = AddFilesForFont(font.Get(), *windows_fonts_path, &path_set);
+      if (FAILED(hr)) {
+        // It's possible to not be able to retrieve a font file for a font that
+        // is in the system font collection, see https://crbug.com/922183. If we
+        // were not able to retrieve a file for a registered font, we do not
+        // need to add it to the map.
+        last_hresult_continue_reason = hr;
+        continue;
+      }
+    }
+
+    // After having received clarification from Microsoft, the API is designed
+    // for allowing multiple files to be returned, if MS was to support a file
+    // format like Type1 fonts with this API, but for now only ever returns 1
+    // font file as only TrueType / OpenType fonts are supported.
+    DCHECK_EQ(path_set.size() + custom_font_path_set.size(), 1u);
+    // If this font is placed in a custom font path location, we pass it to
+    // Blink, and we'll track with UMA there if such a font path is matched
+    // and used. If this happens more than very rarely, we will need to add an
+    // out-of-process loading mechanism for loading those uniquely matched
+    // font files.
+    base::FilePath file_path(path_set.size() ? *path_set.begin()
+                                             : *custom_font_path_set.begin());
+    DCHECK(!file_path.empty());
+
+    // Build entry for being added to the table in separate call.
+    blink::FontUniqueNameTable_UniqueFont unique_font;
+    unique_font.set_file_path(file_path.AsUTF8Unsafe());
+    unique_font.set_ttc_index(ttc_index);
+
+    std::vector<std::string> extracted_names;
+    auto extract_names =
+        [&extracted_names,
+         &font](DWRITE_INFORMATIONAL_STRING_ID font_info_string_id) -> HRESULT {
+      // Now get names, and make them point to the added font.
+      Microsoft::WRL::ComPtr<IDWriteLocalizedStrings> font_id_keyed_names;
+      BOOL has_id_keyed_names;
+      {
+        base::ScopedBlockingCall scoped_blocking_call(
+            FROM_HERE, base::BlockingType::MAY_BLOCK);
+        HRESULT hr = font->GetInformationalStrings(
+            font_info_string_id, &font_id_keyed_names, &has_id_keyed_names);
+        if (FAILED(hr))
+          return hr;
+        if (!has_id_keyed_names)
+          return kErrorNoFullNameOrPostScriptName;
+      }
+
+      return ExtractCaseFoldedLocalizedStrings(font_id_keyed_names.Get(),
+                                               &extracted_names)
+                 ? S_OK
+                 : kErrorExtractingLocalizedStringsFailed;
+    };
+
+    hr = extract_names(DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME);
+    hr = FAILED(hr) ? hr : extract_names(DWRITE_INFORMATIONAL_STRING_FULL_NAME);
+
+    if (UNLIKELY(slow_down_mode_for_testing == SlowDownMode::kDelayEachTask)) {
+      base::PlatformThread::Sleep(indexing_timeout *
+                                  kIndexingSlowDownForTestingPercentage);
+    } else if (UNLIKELY(slow_down_mode_for_testing ==
+                        SlowDownMode::kHangOneTask) &&
+               family_index == 0) {
+      base::ScopedAllowBaseSyncPrimitivesForTesting scoped_allow_sync_;
+      DCHECK(hang_event_for_testing);
+      hang_event_for_testing->Wait();
+    }
+
+    if (extracted_names.empty()) {
+      last_hresult_continue_reason = hr;
+      continue;
+    }
+
+    family_result.exit_hresult = S_OK;
+    family_result.font_files_with_names.push_back(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames(
+            std::move(unique_font), std::move(extracted_names)));
+  }
+
+  if (family_result.font_files_with_names.empty()) {
+    family_result.exit_hresult = last_hresult_continue_reason;
+  }
+
+  return family_result;
+}
+
+void DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded(
+    const FamilyResult& family_result) {
+  TRACE_EVENT0(
+      "dwrite,fonts",
+      "DWriteFontLookupTableBuilder::AppendFamilyResultAndFinalizeIfNeeded");
+
+  outstanding_family_results_--;
+
+  // If this task's response came late and OnTimeout was called, we
+  // do not need the results anymore and the table was already finalized.
+  if (font_table_built_.IsSet())
+    return;
+
+  if (!family_result.font_files_with_names.size())
+    family_results_empty_++;
+  else
+    family_results_non_empty_++;
+
+  if (FAILED(family_result.exit_hresult))
+    scanning_error_reasons_[family_result.exit_hresult]++;
+
+  for (const FontFileWithUniqueNames& font_of_family :
+       family_result.font_files_with_names) {
+    blink::FontUniqueNameTable_UniqueFont* added_unique_font =
+        font_unique_name_table_->add_fonts();
+
+    *added_unique_font = font_of_family.font_entry;
+
+    int added_font_index = font_unique_name_table_->fonts_size() - 1;
+
+    for (auto& font_name : font_of_family.extracted_names) {
+      blink::FontUniqueNameTable_UniqueNameToFontMapping* added_mapping =
+          font_unique_name_table_->add_name_map();
+      DCHECK(added_mapping);
+      added_mapping->set_font_name(font_name);
+      added_mapping->set_font_index(added_font_index);
+    }
+  }
+
+  if (!outstanding_family_results_) {
+    FinalizeFontTable();
+  }
+}
+
+void DWriteFontLookupTableBuilder::RunPendingCallback(
+    CallbackOnTaskRunner pending_callback) {
+  DCHECK(callbacks_task_runner_->RunsTasksInCurrentSequence());
+  pending_callback.task_runner->PostTask(
+      FROM_HERE, base::BindOnce(std::move(pending_callback.mojo_callback),
+                                DuplicateMemoryRegion()));
+}
+
+void DWriteFontLookupTableBuilder::FinalizeFontTable() {
+  TRACE_EVENT0("dwrite,fonts",
+               "DWriteFontLookupTableBuilder::FinalizeFontTable");
+  DCHECK(!font_table_built_.IsSet());
+
+  timeout_callback_.Cancel();
+
+  // Make sure that whatever happens in the remainder of this function the
+  // FontUniqueNameTable object gets released by moving it to a local variable.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table(
+      std::move(font_unique_name_table_));
+
+  bool timed_out = false;
+  if (base::TimeTicks::Now() - start_time_table_build_ > IndexingTimeout()) {
+    font_unique_name_table->clear_fonts();
+    font_unique_name_table->clear_name_map();
+    timed_out = true;
+  }
+  UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.TableBuildTimedOut",
+                        timed_out);
+
+  int empty_family_results_percentage =
+      round(((family_results_empty_ * 1.0f) /
+             (family_results_empty_ + family_results_non_empty_)) *
+            100.0);
+  UMA_HISTOGRAM_PERCENTAGE("DirectWrite.Fonts.Proxy.EmptyFamilyResultsRatio",
+                           empty_family_results_percentage);
+
+  if (empty_family_results_percentage > 0) {
+    auto most_frequent_hresult_element = std::max_element(
+        std::begin(scanning_error_reasons_), std::end(scanning_error_reasons_),
+        [](const decltype(scanning_error_reasons_)::value_type& a,
+           decltype(scanning_error_reasons_)::value_type& b) {
+          return a.second < b.second;
+        });
+    base::UmaHistogramSparse(
+        "DirectWrite.Fonts.Proxy.MostFrequentScanningFailure",
+        most_frequent_hresult_element->first);
+  }
+
+  unsigned num_font_files = font_unique_name_table->fonts_size();
+
+  blink::FontTableMatcher::SortUniqueNameTableForSearch(
+      font_unique_name_table.get());
+
+  font_table_memory_ = base::ReadOnlySharedMemoryRegion::Create(
+      font_unique_name_table->ByteSizeLong());
+
+  if (!IsFontUniqueNameTableValid() ||
+      !font_unique_name_table->SerializeToArray(
+          font_table_memory_.mapping.memory(),
+          font_table_memory_.mapping.size())) {
+    font_table_memory_ = base::MappedReadOnlyRegion();
+  }
+
+  if (caching_enabled_) {
+    bool persist_succeeded = PersistToFile();
+    UMA_HISTOGRAM_BOOLEAN("DirectWrite.Fonts.Proxy.LookupTablePersistSuccess",
+                          persist_succeeded);
+  }
+
+  font_table_built_.Set();
+  PostCallbacks();
+
+  if (!IsFontUniqueNameTableValid())
+    return;
+
+  base::TimeDelta duration = base::TimeTicks::Now() - start_time_table_build_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableBuildTime",
+                             duration);
+
+  duration = base::TimeTicks::Now() - start_time_table_ready_;
+  UMA_HISTOGRAM_MEDIUM_TIMES("DirectWrite.Fonts.Proxy.LookupTableReadyTime",
+                             duration);
+
+  // The size is usually tens of kilobytes, ~50kb on a standard Windows 10
+  // installation, 1MB should be a more than high enough upper limit.
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.LookupTableSize",
+                              font_table_memory_.mapping.size() / 1024, 1, 1000,
+                              50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.NumFontFiles",
+                              num_font_files, 1, 5000, 50);
+
+  UMA_HISTOGRAM_CUSTOM_COUNTS("DirectWrite.Fonts.Proxy.IndexingSpeed",
+                              num_font_files / duration.InSecondsF(), 1, 10000,
+                              50);
+}
+
+void DWriteFontLookupTableBuilder::OnTimeout() {
+  DCHECK(!font_table_built_.IsSet());
+  FinalizeFontTable();
+}
+
+void DWriteFontLookupTableBuilder::SetSlowDownIndexingForTestingWithTimeout(
+    SlowDownMode slow_down_mode,
+    base::TimeDelta new_timeout) {
+  slow_down_mode_for_testing_ = slow_down_mode;
+  font_indexing_timeout_ = new_timeout;
+  if (slow_down_mode == SlowDownMode::kHangOneTask)
+    hang_event_for_testing_.emplace();
+}
+
+void DWriteFontLookupTableBuilder::ResetLookupTableForTesting() {
+  slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  font_indexing_timeout_ = kFontIndexingTimeoutDefault;
+  callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+  font_table_memory_ = base::MappedReadOnlyRegion();
+  caching_enabled_ = true;
+  font_table_built_.UnsafeResetForTesting();
+}
+
+void DWriteFontLookupTableBuilder::ResetStateForTesting() {
+  ResetLookupTableForTesting();
+  // Recreate fFactory3 if available, to reset
+  // OverrideDWriteVersionChecksForTesting().
+  direct_write_initialized_ = false;
+  InitializeDirectWrite();
+  InitializeCacheDirectoryFromProfile();
+}
+
+void DWriteFontLookupTableBuilder::ResumeFromHangForTesting() {
+  hang_event_for_testing_->Signal();
+}
+
+// static
+DWriteFontLookupTableBuilder* DWriteFontLookupTableBuilder::GetInstance() {
+  static base::NoDestructor<DWriteFontLookupTableBuilder> instance;
+  return instance.get();
+}
+
+}  // namespace content
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
new file mode 100644
index 0000000000000..cee91dd4e059b
--- /dev/null
+++ b/content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h
@@ -0,0 +1,255 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+#define CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
+
+#include <dwrite.h>
+#include <dwrite_2.h>
+#include <dwrite_3.h>
+#include <wrl.h>
+#include <memory>
+#include <string>
+#include <vector>
+
+#include "base/cancelable_callback.h"
+#include "base/files/file_path.h"
+#include "base/memory/read_only_shared_memory_region.h"
+#include "base/memory/singleton.h"
+#include "base/no_destructor.h"
+#include "base/synchronization/atomic_flag.h"
+#include "base/synchronization/waitable_event.h"
+#include "base/task/deferred_sequenced_task_runner.h"
+#include "base/time/time.h"
+#include "content/common/content_export.h"
+#include "third_party/abseil-cpp/absl/types/optional.h"
+#include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom.h"
+
+namespace content {
+
+// Singleton class which encapsulates building the font unique name table lookup
+// once, then serving the built table as a ReadOnlySharedMemoryRegion. Receives
+// requests for accessing this table from DWriteFontProxyImpl after Mojo IPC
+// calls from the renderer. A method ScheduleBuildFontUniqueNameTable() is
+// provided to schedule building the font unique name lookup
+// structure. EnsureFontUniqueNameTable() can be called on any thread to wait
+// for the lookup table to be ready. After that, DuplicateMemoryRegion() can be
+// used to retrieve the lookup structure. Thread-safe when used as described
+// below.
+class CONTENT_EXPORT DWriteFontLookupTableBuilder {
+ public:
+  static DWriteFontLookupTableBuilder* GetInstance();
+
+  DWriteFontLookupTableBuilder(const DWriteFontLookupTableBuilder&) = delete;
+  DWriteFontLookupTableBuilder& operator=(const DWriteFontLookupTableBuilder&) =
+      delete;
+
+  // Retrieve the prepared memory region if it is available.
+  // EnsureFontUniqueNameTable() must be checked before.
+  base::ReadOnlySharedMemoryRegion DuplicateMemoryRegion();
+
+  // Enqueue a request to get notified about the availability of the shared
+  // memory region holding the unique font lookup table.
+  // https://crbug.com/967316 shows that we do have a higher number of
+  // DWriteFontProxyImpl instances, potentially running on different
+  // TaskRunners. Capture each relevant task runner with a call to this method.
+  void QueueShareMemoryRegionWhenReady(
+      scoped_refptr<base::SequencedTaskRunner> task_runner,
+      blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback callback);
+
+  // Returns whether the indexing has completed and the shared memory region is
+  // immediately ready without any sync operations.
+  bool FontUniqueNameTableReady();
+
+  // If needed, i.e. if we're on pre-Windows 10, posts a task to load from cache
+  // or build (if cache not available) the unique name table index, should only
+  // be called once at browser startup, after that,
+  // QueueShareMemoryRegionWhenReady() to trigger the mojo callbacks when the
+  // table is ready.
+  void SchedulePrepareFontUniqueNameTableIfNeeded();
+
+  enum class SlowDownMode { kDelayEachTask, kHangOneTask, kNoSlowdown };
+
+  // Slow down each family indexing step for testing the internal timeout,
+  // either with a single hung task or by delaying each indexing step. At the
+  // same time, configure a new timeout value for testing, overriding the
+  // default timeout.
+  void SetSlowDownIndexingForTestingWithTimeout(SlowDownMode slowdown_mode,
+                                                base::TimeDelta new_timeout);
+
+  // Reset timeout overrides and empty table. Needed to trigger rebuilding the
+  // lookup table, when testing using slowed-down indexing. Otherwise, the test
+  // methods would use the already cached lookup table.
+  void ResetLookupTableForTesting();
+
+  // Resets other overrides such as the DWrite version check override and cache
+  // directory back to its default values.
+  void ResetStateForTesting();
+
+  // Signals hang_event_for_testing_ which is used in testing hanging one of the
+  // font name retrieval tasks.
+  void ResumeFromHangForTesting();
+
+  // Computes a hash to determine whether cache contents needed to be updated,
+  // consisting of font names and their file paths read from the registry (not
+  // from disk), The DWrite.dll's product version and the Chrome version, as a
+  // safety mechanism to refresh the cache for every release. Exposed as a
+  // public method to be able to run the hash function in a test.
+  // `browser_version` is used in the hash.
+  std::string ComputePersistenceHash(const std::string& browser_version);
+
+  // Configures the cache directory in which to store the serialized font table
+  // lookup structure. Use only in testing. Normally the directory name is
+  // retrieved from ContentBrowserClient.
+  void SetCacheDirectoryForTesting(base::FilePath cache_directory);
+
+  // Configures whether the cache should be used. Needed for testing to test
+  // repeated rebuilding of the font table lookup structure.
+  void SetCachingEnabledForTesting(bool caching_enabled);
+
+  // Disable DCHECKs that ensure DWriteFontLookupTableBuilder is only
+  // run pre Windows 10, used for testing only to allow running the tests on
+  // Windows 10.
+  void OverrideDWriteVersionChecksForTesting();
+
+ private:
+  friend class base::NoDestructor<DWriteFontLookupTableBuilder>;
+
+  struct FontFileWithUniqueNames {
+    FontFileWithUniqueNames(blink::FontUniqueNameTable_UniqueFont&& font,
+                            std::vector<std::string>&& names);
+    ~FontFileWithUniqueNames();
+    FontFileWithUniqueNames(
+        DWriteFontLookupTableBuilder::FontFileWithUniqueNames&& other);
+    FontFileWithUniqueNames(const FontFileWithUniqueNames&) = delete;
+    FontFileWithUniqueNames& operator=(const FontFileWithUniqueNames&) = delete;
+
+    blink::FontUniqueNameTable_UniqueFont font_entry;
+    std::vector<std::string> extracted_names;
+  };
+
+  struct FamilyResult {
+    FamilyResult();
+
+    FamilyResult(const FamilyResult&) = delete;
+    FamilyResult& operator=(const FamilyResult&) = delete;
+
+    FamilyResult(FamilyResult&& other);
+
+    ~FamilyResult();
+
+    std::vector<FontFileWithUniqueNames> font_files_with_names;
+    HRESULT exit_hresult{S_OK};
+  };
+
+  // Try to find a serialized lookup table from the cache directory specified at
+  // construction and load it into memory.
+  bool LoadFromFile();
+
+  // Serialize the current lookup table into a file in the cache directory
+  // specified at construction time.
+  bool PersistToFile();
+
+  // Initialize the cache directory from the user profile directory if
+  // DWriteFontLookupTableBuilder is executed in an environment where the
+  // profile is accessible.
+  void InitializeCacheDirectoryFromProfile();
+
+  // Load from cache or construct the font unique name lookup table. If the
+  // cache is up to date, do not schedule a run to scan all Windows-enumerated
+  // fonts. `browser_version` is used in the hashing algorithm for the cache
+  // key.
+  void PrepareFontUniqueNameTable(const std::string& browser_version);
+
+  // Helper function to perform DWrite operations to retrieve path names, full
+  // font name and PostScript name for a font specified by collection + family
+  // index.
+  static FamilyResult ExtractPathAndNamesFromFamily(
+      Microsoft::WRL::ComPtr<IDWriteFontCollection> collection,
+      uint32_t family_index,
+      base::TimeTicks start_time,
+      SlowDownMode slow_down_mode,
+      base::WaitableEvent* hang_event_for_testing,
+      base::TimeDelta indexing_timeout);
+
+  // Callback from scheduled tasks to add the retrieved font names to the
+  // protobuf.
+  void AppendFamilyResultAndFinalizeIfNeeded(const FamilyResult& family_result);
+
+  // Sort the results that were collected into the protobuf structure and
+  // signal that font unique name lookup table construction is complete.
+  // Serializes the constructed protobuf to disk.
+  void FinalizeFontTable();
+
+  void OnTimeout();
+
+  bool IsFontUniqueNameTableValid();
+
+  void InitializeDirectWrite();
+
+  base::FilePath TableCacheFilePath();
+
+  // Returns true if IDWriteFactory3 is available, which means that we can
+  // access IDWriteFontSet API which provides direct lookup by PostScript name
+  // and full font name, in which case we do not need to build this table.
+  bool HasDWriteUniqueFontLookups();
+
+  base::TimeDelta IndexingTimeout();
+
+  void PostCallbacks();
+
+  DWriteFontLookupTableBuilder();
+  ~DWriteFontLookupTableBuilder();
+
+  // Protobuf structure temporarily used and shared during table construction.
+  std::unique_ptr<blink::FontUniqueNameTable> font_unique_name_table_;
+
+  struct CallbackOnTaskRunner {
+    CallbackOnTaskRunner(
+        scoped_refptr<base::SequencedTaskRunner>,
+        blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback);
+    CallbackOnTaskRunner(CallbackOnTaskRunner&&);
+    ~CallbackOnTaskRunner();
+    scoped_refptr<base::SequencedTaskRunner> task_runner;
+    blink::mojom::DWriteFontProxy::GetUniqueNameLookupTableCallback
+        mojo_callback;
+  };
+
+  // Task method to bind the CallbackOnTaskRunner for delayed execution when
+  // building the font table is completed.
+  void RunPendingCallback(CallbackOnTaskRunner pending_callback);
+
+  base::MappedReadOnlyRegion font_table_memory_;
+  base::AtomicFlag font_table_built_;
+
+  bool direct_write_initialized_ = false;
+  base::TimeDelta font_indexing_timeout_;
+  Microsoft::WRL::ComPtr<IDWriteFontCollection> collection_;
+  Microsoft::WRL::ComPtr<IDWriteFactory2> factory2_;
+  Microsoft::WRL::ComPtr<IDWriteFactory3> factory3_;
+  SlowDownMode slow_down_mode_for_testing_ = SlowDownMode::kNoSlowdown;
+  uint32_t outstanding_family_results_ = 0;
+  uint32_t family_results_non_empty_ = 0;
+  uint32_t family_results_empty_ = 0;
+  base::TimeTicks start_time_table_ready_;
+  base::TimeTicks start_time_table_build_;
+  base::FilePath cache_directory_;
+
+  bool caching_enabled_ = true;
+  absl::optional<base::WaitableEvent> hang_event_for_testing_;
+  base::CancelableOnceCallback<void()> timeout_callback_;
+
+  // All responses are serialized through this DeferredSequencedTaskRunner. It
+  // is started when the table is ready and guarantees that requests made before
+  // the table was ready are replied to first.
+  scoped_refptr<base::DeferredSequencedTaskRunner> callbacks_task_runner_ =
+      base::MakeRefCounted<base::DeferredSequencedTaskRunner>();
+
+  std::map<HRESULT, unsigned> scanning_error_reasons_;
+};
+
+}  // namespace content
+
+#endif  // CONTENT_BROWSER_RENDERER_HOST_DWRITE_FONT_LOOKUP_TABLE_BUILDER_WIN_H_
\ No newline at end of file
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
index b7ee9276d64fc..116953d3ef8f9 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.cc
@@ -36,6 +36,9 @@
 #include "third_party/abseil-cpp/absl/utility/utility.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_unique_name_table.pb.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/icu_fold_case_util.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+#include "third_party/skia/include/ports/SkTypeface_win.h"
 #include "ui/gfx/win/direct_write.h"
 #include "ui/gfx/win/text_analysis_source.h"
 
@@ -446,6 +449,40 @@ void DWriteFontProxyImpl::MapCharacters(
   DCHECK_GT(result->mapped_length, 0u);
 }
 
+void DWriteFontProxyImpl::GetUniqueNameLookupTableIfAvailable(
+    GetUniqueNameLookupTableIfAvailableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  /* Table is not synchronously available, return immediately. */
+  if (!DWriteFontLookupTableBuilder::GetInstance()
+           ->FontUniqueNameTableReady()) {
+    std::move(callback).Run(false, base::ReadOnlySharedMemoryRegion());
+    return;
+  }
+
+  std::move(callback).Run(
+      true,
+      DWriteFontLookupTableBuilder::GetInstance()->DuplicateMemoryRegion());
+}
+
+void DWriteFontProxyImpl::GetUniqueFontLookupMode(
+    GetUniqueFontLookupModeCallback callback) {
+  InitializeDirectWrite();
+  // If factory3_ is available, that means we can use IDWriteFontSet to filter
+  // for PostScript name and full font name directly and do not need to build
+  // the lookup table.
+  blink::mojom::UniqueFontLookupMode lookup_mode =
+      factory3_.Get() ? blink::mojom::UniqueFontLookupMode::kSingleLookups
+                      : blink::mojom::UniqueFontLookupMode::kRetrieveTable;
+  std::move(callback).Run(lookup_mode);
+}
+
+void DWriteFontProxyImpl::GetUniqueNameLookupTable(
+    GetUniqueNameLookupTableCallback callback) {
+  DCHECK(base::FeatureList::IsEnabled(features::kFontSrcLocalMatching));
+  DWriteFontLookupTableBuilder::GetInstance()->QueueShareMemoryRegionWhenReady(
+      base::SequencedTaskRunner::GetCurrentDefault(), std::move(callback));
+}
+
 void DWriteFontProxyImpl::MatchUniqueFont(
     const std::u16string& unique_font_name,
     MatchUniqueFontCallback callback) {
@@ -542,7 +579,52 @@ void DWriteFontProxyImpl::MatchUniqueFont(
   std::move(callback).Run(std::move(font_file), ttc_index);
 }
 
+void DWriteFontProxyImpl::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {
+  InitializeDirectWrite();
+  callback = mojo::WrapCallbackWithDefaultInvokeIfNotRun(
+      std::move(callback),
+      blink::mojom::FallbackFamilyAndStyle::New("",
+                                                /* weight */ 0,
+                                                /* width */ 0,
+                                                /* slant */ 0));
+
+  if (!codepoint || !collection_ || !factory_)
+    return;
+
+  sk_sp<SkFontMgr> font_mgr(
+      SkFontMgr_New_DirectWrite(factory_.Get(), collection_.Get()));
+
+  if (!font_mgr)
+    return;
+
+  const char* bcp47_locales[] = {locale_name.c_str()};
+  int num_locales = locale_name.empty() ? 0 : 1;
+  const char** locales = locale_name.empty() ? nullptr : bcp47_locales;
+
+  sk_sp<SkTypeface> typeface(font_mgr->matchFamilyStyleCharacter(
+      base_family_name.c_str(), SkFontStyle(), locales, num_locales,
+      codepoint));
+
+  if (!typeface)
+    return;
+
+  SkString family_name;
+  typeface->getFamilyName(&family_name);
+
+  SkFontStyle font_style = typeface->fontStyle();
+
+  auto result_fallback_and_style = blink::mojom::FallbackFamilyAndStyle::New(
+      family_name.c_str(), font_style.weight(), font_style.width(),
+      font_style.slant());
+  std::move(callback).Run(std::move(result_fallback_and_style));
+}
+
 void DWriteFontProxyImpl::InitializeDirectWrite() {
+  HRESULT hr;
   if (direct_write_initialized_)
     return;
   direct_write_initialized_ = true;
@@ -556,20 +638,30 @@ void DWriteFontProxyImpl::InitializeDirectWrite() {
     return;
   }
 
-  // QueryInterface for IDWriteFactory2. This should succeed since we only
-  // support >= Win10.
+  // QueryInterface for IDWriteFactory2. It's ok for this to fail if we are
+  // running an older version of DirectWrite (earlier than Win8.1).
   factory_.As<IDWriteFactory2>(&factory2_);
-  DCHECK(factory2_);
 
-  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows.
-  // This should succeed since we only support >= Win10.
+  // QueryInterface for IDwriteFactory3, needed for MatchUniqueFont on Windows
+  // 10. May fail on older versions, in which case, unique font matching must be
+  // done through indexing system fonts using DWriteFontLookupTableBuilder.
   factory_.As<IDWriteFactory3>(&factory3_);
-  DCHECK(factory3_);
 
-  // Normally identical to factory_->GetSystemFontCollection() unless a
-  // sideloaded font has been added using SideLoadFontForTesting().
-  HRESULT hr = GetLocalFontCollection(factory3_, &collection_);
+  // On Windows 10 and up (or Vista exkernel/Windows 8.x with modified dwrite.dll from 1809)
+  // you can take advantage of the extended DirectWrite APIs to sideload local fonts in
+  // addition to system fonts. But if IDWriteFactory3 is unavailable, fall back to
+  // GetSystemFontCollection.
+  // TODO: make DirectWrite optional for the benefit of the NT 5 users.
+
+  if(factory3_  == nullptr) {
+  hr = factory_->GetSystemFontCollection(&collection_);
+  DCHECK(SUCCEEDED(hr));
+  }
+  else {
+  hr = GetLocalFontCollection(factory3_, &collection_);
   DCHECK(SUCCEEDED(hr));
+  }
+  
 
   if (!collection_) {
     return;
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
index 421d471aaa6e1..3beaa0fb58fef 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win.h
@@ -14,6 +14,7 @@
 #include <vector>
 
 #include "base/memory/read_only_shared_memory_region.h"
+#include "content/browser/renderer_host/dwrite_font_lookup_table_builder_win.h"
 #include "content/common/content_export.h"
 #include "content/public/browser/browser_message_filter.h"
 #include "content/public/browser/browser_thread.h"
@@ -63,6 +64,20 @@ class CONTENT_EXPORT DWriteFontProxyImpl
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void GetUniqueFontLookupMode(
+      GetUniqueFontLookupModeCallback callback) override;
+
+  void GetUniqueNameLookupTableIfAvailable(
+      GetUniqueNameLookupTableIfAvailableCallback callback) override;
+
+  void GetUniqueNameLookupTable(
+      GetUniqueNameLookupTableCallback callback) override;
+
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
   void InitializeDirectWrite();
 
diff --git a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
index 5f8c1b00295ce..152f73280e000 100644
--- a/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
+++ b/content/browser/renderer_host/dwrite_font_proxy_impl_win_unittest.cc
@@ -25,6 +25,7 @@
 #include "testing/gtest/include/gtest/gtest.h"
 #include "third_party/blink/public/common/font_unique_name_lookup/font_table_matcher.h"
 #include "third_party/icu/source/common/unicode/umachine.h"
+#include "ui/gfx/test/font_fallback_test_data.h"
 
 namespace content {
 
@@ -182,6 +183,32 @@ TEST_F(DWriteFontProxyImplUnitTest, TestCustomFontFiles) {
   }
 }
 
+TEST_F(DWriteFontProxyImplUnitTest, FallbackFamily) {
+  for (auto& fallback_request : gfx::kGetFontFallbackTests) {
+    blink::mojom::FallbackFamilyAndStylePtr fallback_family_and_style;
+    UChar32 codepoint;
+    U16_GET(fallback_request.text.c_str(), 0, 0, fallback_request.text.size(),
+            codepoint);
+    dwrite_font_proxy().FallbackFamilyAndStyleForCodepoint(
+        "Times New Roman", fallback_request.language_tag, codepoint,
+        &fallback_family_and_style);
+
+    EXPECT_TRUE(base::Contains(fallback_request.fallback_fonts,
+                               fallback_family_and_style->fallback_family_name))
+        << "Did not find expected fallback font for language: "
+        << fallback_request.language_tag << ", codepoint U+" << std::hex
+        << codepoint << " DWrite returned font name: \""
+        << fallback_family_and_style->fallback_family_name << "\""
+        << ", expected: "
+        << base::JoinString(fallback_request.fallback_fonts, ", ");
+    EXPECT_EQ(fallback_family_and_style->weight, 400u);
+    EXPECT_EQ(fallback_family_and_style->width,
+              5u);  // SkFontStyle::Width::kNormal_Width
+    EXPECT_EQ(fallback_family_and_style->slant,
+              0u);  // SkFontStyle::Slant::kUpright_Slant
+  }
+}
+
 }  // namespace
 
 }  // namespace content
diff --git a/content/browser/renderer_host/render_process_host_impl.cc b/content/browser/renderer_host/render_process_host_impl.cc
index 44922d6b9f7f7..4d7d83d3d7337 100644
--- a/content/browser/renderer_host/render_process_host_impl.cc
+++ b/content/browser/renderer_host/render_process_host_impl.cc
@@ -3461,6 +3461,7 @@ void RenderProcessHostImpl::PropagateBrowserCommandLineToRenderer(
     switches::kRendererWaitForJavaDebugger,
 #endif
 #if BUILDFLAG(IS_WIN)
+    switches::kDisableDirectWrite,
     switches::kDisableHighResTimer,
     switches::kTrySupportedChannelLayouts,
     switches::kRaiseTimerFrequency,
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
index a529ad9aac0b9..90c0ff972bda5 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_init_impl_win.cc
@@ -41,9 +41,19 @@ base::RepeatingCallback<mojo::PendingRemote<blink::mojom::DWriteFontProxy>(
 void CreateDirectWriteFactory(IDWriteFactory** factory) {
   // This shouldn't be necessary, but not having this causes breakage in
   // content_browsertests, and possibly other high-stress cases.
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+
+  HMODULE dwrite_dll = GetModuleHandleW(L"dwrite.dll");
+  
   PatchServiceManagerCalls();
 
-  CHECK(SUCCEEDED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_ISOLATED,
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc)
+    return;
+
+  CHECK(SUCCEEDED(dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_ISOLATED,
                                       __uuidof(IDWriteFactory),
                                       reinterpret_cast<IUnknown**>(factory))));
 }
@@ -53,7 +63,11 @@ void CreateDirectWriteFactory(IDWriteFactory** factory) {
 void InitializeDWriteFontProxy() {
   TRACE_EVENT0("dwrite,fonts", "InitializeDWriteFontProxy");
   mswr::ComPtr<IDWriteFactory> factory;
-
+  // Halt the init process if the DLL is not there.
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll)
+    return;
+ 
   CreateDirectWriteFactory(&factory);
 
   if (!g_font_collection) {
@@ -79,7 +93,7 @@ void InitializeDWriteFontProxy() {
 
   skia::OverrideDefaultSkFontMgr(std::move(skia_font_manager));
 
-  DCHECK(g_font_fallback);
+  blink::WebFontRendering::SetUseSkiaFontFallback(g_font_fallback ? true : false);
 }
 
 void UninitializeDWriteFontProxy() {
diff --git a/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc b/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
index 163d1ecca00c1..0186a5a3d8b8d 100644
--- a/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
+++ b/content/child/dwrite_font_proxy/dwrite_font_proxy_win_unittest.cc
@@ -52,8 +52,18 @@ class DWriteFontProxyUnitTest : public testing::Test {
   }
 
   static void SetUpTestCase() {
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
-                        &factory);
+    using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+    HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+    if (!dwrite_dll)
+      return;
+
+    DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+    if (!dwrite_create_factory_proc)
+      return;
+    dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+                               &factory);
 
     std::vector<wchar_t> font_path;
     font_path.resize(MAX_PATH);
diff --git a/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc b/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
index 90a04f1deef7f..3f40491a80b7b 100644
--- a/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
+++ b/content/child/dwrite_font_proxy/font_fallback_win_unittest.cc
@@ -27,7 +27,17 @@ namespace {
 class FontFallbackUnitTest : public testing::Test {
  public:
   FontFallbackUnitTest() {
-    DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+	using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+    HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+	if (!dwrite_dll)
+		return;
+
+	DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+	if (!dwrite_create_factory_proc)
+		return;
+    dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                         &factory_);
 
     factory_->CreateNumberSubstitution(DWRITE_NUMBER_SUBSTITUTION_METHOD_NONE,
diff --git a/content/child/font_warmup_win_unittest.cc b/content/child/font_warmup_win_unittest.cc
index 051af55e65a2c..5a6cece424703 100644
--- a/content/child/font_warmup_win_unittest.cc
+++ b/content/child/font_warmup_win_unittest.cc
@@ -69,6 +69,16 @@ class GDIFontEmulationTest : public testing::Test {
   }
 
   static void SetUpTestCase() {
+	using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+	HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+	if (!dwrite_dll)
+		return;
+
+    DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+    if (!dwrite_create_factory_proc)
+		return;
     DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                         &factory);
   }
diff --git a/content/common/sandbox_init_win.cc b/content/common/sandbox_init_win.cc
index 498f60227d13e..724ce1120b720 100644
--- a/content/common/sandbox_init_win.cc
+++ b/content/common/sandbox_init_win.cc
@@ -17,6 +17,7 @@
 #include "sandbox/policy/win/sandbox_win.h"
 #include "sandbox/win/src/sandbox.h"
 #include "sandbox/win/src/sandbox_types.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace content {
 
diff --git a/content/ppapi_plugin/ppapi_plugin_main.cc b/content/ppapi_plugin/ppapi_plugin_main.cc
index 89e84b2c25c52..8af071d123a33 100644
--- a/content/ppapi_plugin/ppapi_plugin_main.cc
+++ b/content/ppapi_plugin/ppapi_plugin_main.cc
@@ -172,7 +172,12 @@ int PpapiPluginMain(MainFunctionParams parameters) {
 #if BUILDFLAG(IS_WIN)
   if (!base::win::IsUser32AndGdi32Available())
     gfx::win::InitializeDirectWrite();
-  InitializeDWriteFontProxy();
+  bool use_direct_write = gfx::win::IsDirectWriteEnabled();
+  if (use_direct_write) {
+    InitializeDWriteFontProxy();
+  }
+
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   int antialiasing_enabled = 1;
   base::StringToInt(
diff --git a/content/public/browser/content_browser_client.cc b/content/public/browser/content_browser_client.cc
index 5733e6d1ea77f..c72a6ec828e7b 100644
--- a/content/public/browser/content_browser_client.cc
+++ b/content/public/browser/content_browser_client.cc
@@ -744,6 +744,10 @@ std::string ContentBrowserClient::GetDefaultDownloadName() {
   return std::string();
 }
 
+base::FilePath ContentBrowserClient::GetFontLookupTableCacheDir() {
+  return base::FilePath();
+}
+
 base::FilePath ContentBrowserClient::GetShaderDiskCacheDirectory() {
   return base::FilePath();
 }
diff --git a/content/public/browser/content_browser_client.h b/content/public/browser/content_browser_client.h
index 8b4b26ed9f976..fc1754dad223f 100644
--- a/content/public/browser/content_browser_client.h
+++ b/content/public/browser/content_browser_client.h
@@ -1182,6 +1182,11 @@ class CONTENT_EXPORT ContentBrowserClient {
   // else we should do with the file.
   virtual std::string GetDefaultDownloadName();
 
+  // Returns the path to the font lookup table cache directory in which - on
+  // Windows 7 & 8 - we cache font name meta information to perform @font-face {
+  // src: local() } lookups.
+  virtual base::FilePath GetFontLookupTableCacheDir();
+
   // Returns the path to the browser shader disk cache root.
   virtual base::FilePath GetShaderDiskCacheDirectory();
 
diff --git a/content/renderer/renderer_main.cc b/content/renderer/renderer_main.cc
index 364f4b8c67b49..ce17776bcea93 100644
--- a/content/renderer/renderer_main.cc
+++ b/content/renderer/renderer_main.cc
@@ -93,6 +93,11 @@
 #include "mojo/public/cpp/bindings/lib/test_random_mojo_delays.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace content {
 namespace {
 
@@ -240,8 +245,18 @@ int RendererMain(MainFunctionParams parameters) {
   {
     content::ContentRendererClient* client = GetContentClient()->renderer();
     bool should_run_loop = true;
-    bool need_sandbox =
+#if BUILDFLAG(IS_WIN)
+    bool need_sandbox = true;
+    if(base::win::GetVersion() >= base::win::Version::WIN8) {
+	// Windows 8+ specific limitations required renderer sandbox disabled for GDI
+    need_sandbox = gfx::win::ShouldUseDirectWrite() && 
         !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+	}
+	else
+	need_sandbox = !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+#else
+    bool need_sandbox = !command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+#endif
 
     if (!need_sandbox) {
       // The post-sandbox actions still need to happen at some point.
diff --git a/content/renderer/renderer_main_platform_delegate_win.cc b/content/renderer/renderer_main_platform_delegate_win.cc
index e7b8caa9ab118..430b6371d4f00 100644
--- a/content/renderer/renderer_main_platform_delegate_win.cc
+++ b/content/renderer/renderer_main_platform_delegate_win.cc
@@ -27,6 +27,18 @@
 #include "ui/gfx/win/direct_write.h"
 
 namespace content {
+namespace {
+
+// Windows-only skia sandbox support
+// These are used for GDI-path rendering.
+void SkiaPreCacheFont(const LOGFONT& logfont) {
+  RenderThread* render_thread = RenderThread::Get();
+  if (render_thread) {
+    render_thread->PreCacheFont(logfont);
+  }
+}
+
+}  // namespace
 
 RendererMainPlatformDelegate::RendererMainPlatformDelegate(
     const MainFunctionParams& parameters)
@@ -40,8 +52,16 @@ void RendererMainPlatformDelegate::PlatformInitialize() {
 
   // Be mindful of what resources you acquire here. They can be used by
   // malicious code if the renderer gets compromised.
-  bool no_sandbox =
-      command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+  bool no_sandbox =command_line.HasSwitch(sandbox::policy::switches::kNoSandbox);
+	  
+  bool use_direct_write = gfx::win::ShouldUseDirectWrite();
+  
+  if (use_direct_write) {
+      InitializeDWriteFontProxy();
+    } else {
+      SkTypeface_SetEnsureLOGFONTAccessibleProc(SkiaPreCacheFont);
+    }
+  blink::WebFontRendering::setUseDirectWrite(use_direct_write);
 
   if (!no_sandbox) {
     // ICU DateFormat class (used in base/time_format.cc) needs to get the
diff --git a/content/shell/browser/shell_content_browser_client.cc b/content/shell/browser/shell_content_browser_client.cc
index 0008e3c7c9600..c56d6991da655 100644
--- a/content/shell/browser/shell_content_browser_client.cc
+++ b/content/shell/browser/shell_content_browser_client.cc
@@ -14,6 +14,7 @@
 
 #include "base/base_switches.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/containers/cxx20_erase.h"
 #include "base/containers/flat_set.h"
 #include "base/feature_list.h"
@@ -450,6 +450,11 @@ std::string ShellContentBrowserClient::GetDefaultDownloadName() {
   return "download";
 }
 
+base::FilePath ShellContentBrowserClient::GetFontLookupTableCacheDir() {
+  return browser_context()->GetPath().Append(
+      FILE_PATH_LITERAL("FontLookupTableCache"));
+}
+
 std::unique_ptr<WebContentsViewDelegate>
 ShellContentBrowserClient::GetWebContentsViewDelegate(
     WebContents* web_contents) {
@@ -525,7 +530,7 @@ void ShellContentBrowserClient::OverrideWebkitPrefs(
     WebContents* web_contents,
     blink::web_pref::WebPreferences* prefs) {
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode)) {
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag)) {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kDark;
   } else {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kLight;
diff --git a/content/shell/browser/shell_content_browser_client.h b/content/shell/browser/shell_content_browser_client.h
index b33300b6da3ea..ae1480d23acc9 100644
--- a/content/shell/browser/shell_content_browser_client.h
+++ b/content/shell/browser/shell_content_browser_client.h
@@ -93,6 +93,7 @@ class ShellContentBrowserClient : public ContentBrowserClient {
       override;
   void OverrideWebkitPrefs(WebContents* web_contents,
                            blink::web_pref::WebPreferences* prefs) override;
+  base::FilePath GetFontLookupTableCacheDir() override;
   std::unique_ptr<content::DevToolsManagerDelegate>
   CreateDevToolsManagerDelegate() override;
   void ExposeInterfacesToRenderer(
diff --git a/content/test/dwrite_font_fake_sender_win.cc b/content/test/dwrite_font_fake_sender_win.cc
index bed299f10f56f..3d1b5f57984d6 100644
--- a/content/test/dwrite_font_fake_sender_win.cc
+++ b/content/test/dwrite_font_fake_sender_win.cc
@@ -146,6 +146,12 @@ void FakeFontCollection::MapCharacters(
 void FakeFontCollection::MatchUniqueFont(const std::u16string& unique_font_name,
                                          MatchUniqueFontCallback callback) {}
 
+void FakeFontCollection::FallbackFamilyAndStyleForCodepoint(
+    const std::string& base_family_name,
+    const std::string& locale_name,
+    uint32_t codepoint,
+    FallbackFamilyAndStyleForCodepointCallback callback) {}
+
 FakeFontCollection::~FakeFontCollection() = default;
 
 }  // namespace content
diff --git a/content/test/dwrite_font_fake_sender_win.h b/content/test/dwrite_font_fake_sender_win.h
index e5c7230ffcaad..3906ff44e64a6 100644
--- a/content/test/dwrite_font_fake_sender_win.h
+++ b/content/test/dwrite_font_fake_sender_win.h
@@ -125,6 +125,11 @@ class FakeFontCollection : public blink::mojom::DWriteFontProxy {
                      MapCharactersCallback callback) override;
   void MatchUniqueFont(const std::u16string& unique_font_name,
                        MatchUniqueFontCallback callback) override;
+  void FallbackFamilyAndStyleForCodepoint(
+      const std::string& base_family_name,
+      const std::string& locale_name,
+      uint32_t codepoint,
+      FallbackFamilyAndStyleForCodepointCallback callback) override;
 
  private:
   std::vector<FakeFont> fonts_;
diff --git a/content/web_test/browser/web_test_control_host.cc b/content/web_test/browser/web_test_control_host.cc
index 645c22bc8340b..d82ce2567048a 100644
--- a/content/web_test/browser/web_test_control_host.cc
+++ b/content/web_test/browser/web_test_control_host.cc
@@ -19,6 +19,7 @@
 #include "base/barrier_closure.h"
 #include "base/base64.h"
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/containers/contains.h"
 #include "base/functional/bind.h"
 #include "base/functional/callback.h"
@@ -772,7 +773,7 @@ void WebTestControlHost::OverrideWebkitPrefs(
     ApplyWebTestDefaultPreferences(prefs);
   }
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode)) {
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag)) {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kDark;
   } else {
     prefs->preferred_color_scheme = blink::mojom::PreferredColorScheme::kLight;
diff --git a/device/bluetooth/bluetooth_adapter_winrt.cc b/device/bluetooth/bluetooth_adapter_winrt.cc
index a2ba812053fa5..195ec4ee6afe8 100644
--- a/device/bluetooth/bluetooth_adapter_winrt.cc
+++ b/device/bluetooth/bluetooth_adapter_winrt.cc
@@ -105,6 +105,11 @@ using ABI::Windows::Storage::Streams::IDataReaderStatics;
 using Microsoft::WRL::Callback;
 using Microsoft::WRL::ComPtr;
 
+bool ResolveCoreWinRT() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 // Query string for powered Bluetooth radios. GUID Reference:
 // https://docs.microsoft.com/en-us/windows-hardware/drivers/install/guid-bthport-device-interface
 // TODO(https://crbug.com/821766): Consider adding WindowsCreateStringReference
@@ -666,6 +671,14 @@ void BluetoothAdapterWinrt::InitForTests(
     ComPtr<IBluetoothAdapterStatics> bluetooth_adapter_statics,
     ComPtr<IDeviceInformationStatics> device_information_statics,
     ComPtr<IRadioStatics> radio_statics) {
+
+  if (!ResolveCoreWinRT()) {
+    CompleteInit(std::move(init_callback), std::move(bluetooth_adapter_statics),
+                 std::move(device_information_statics),
+                 std::move(radio_statics));
+    return;
+  }
+
   auto statics = PerformSlowInitTasks();
 
   // This allows any passed in values (which would be fakes) to replace
@@ -689,6 +702,8 @@ void BluetoothAdapterWinrt::InitForTests(
 BluetoothAdapterWinrt::StaticsInterfaces
 BluetoothAdapterWinrt::PerformSlowInitTasks() {
   base::win::AssertComApartmentType(base::win::ComApartmentType::MTA);
+  if (!ResolveCoreWinRT())
+    return BluetoothAdapterWinrt::StaticsInterfaces();
   ComPtr<IBluetoothAdapterStatics> adapter_statics;
   HRESULT hr = base::win::GetActivationFactory<
       IBluetoothAdapterStatics,
diff --git a/device/gamepad/wgi_data_fetcher_win.cc b/device/gamepad/wgi_data_fetcher_win.cc
index a215ae7f06fc7..5c685f7deea47 100644
--- a/device/gamepad/wgi_data_fetcher_win.cc
+++ b/device/gamepad/wgi_data_fetcher_win.cc
@@ -210,6 +210,11 @@ GamepadSource WgiDataFetcherWin::source() {
 
 void WgiDataFetcherWin::OnAddedToProvider() {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
+  if (!base::win::HStringReference::ResolveCoreWinRTStringDelayload()) {
+    initialization_state_ =
+        InitializationState::kCoreWinrtStringDelayLoadFailed;
+    return;
+  }
   HRESULT hr = get_activation_factory_function_(
       base::win::HStringReference(RuntimeClass_Windows_Gaming_Input_Gamepad)
           .Get(),
diff --git a/device/gamepad/wgi_data_fetcher_win.h b/device/gamepad/wgi_data_fetcher_win.h
index a5a27848749a2..450ad10130f76 100644
--- a/device/gamepad/wgi_data_fetcher_win.h
+++ b/device/gamepad/wgi_data_fetcher_win.h
@@ -36,6 +36,7 @@ class DEVICE_GAMEPAD_EXPORT WgiDataFetcherWin final
     kAddGamepadAddedFailed,
     kAddGamepadRemovedFailed,
     kRoGetActivationFactoryFailed,
+    kCoreWinrtStringDelayLoadFailed,
   };
 
   using Factory =
diff --git a/docs/README.md b/docs/README.md
index c1aaa629166a0..feefd6d75875c 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -1,20 +1,33 @@
-# Chromium docs
+# Supermium - an up-to-date, open-source browser for legacy Windows users
 
-This directory contains [chromium project](https://www.chromium.org/Home/)
-documentation in [Gitiles-flavored Markdown]. It is automatically
-[rendered by Gitiles].
+The aim of Supermium is to provide the latest Chromium features, support for rendering the web and security patches to users
+of Windows Vista (with extended kernel), Windows 7 and Windows 8.x.
 
-[Gitiles-flavored Markdown]: https://gerrit.googlesource.com/gitiles/+/master/Documentation/markdown.md
-[rendered by Gitiles]: https://chromium.googlesource.com/chromium/src/+/main/docs/
+Releases are expected every one to two months.
 
-**If you add new documents, please also add a link to them in the Document Index
-below.**
+# Support this and other legacy software projects at: http://paypal.me/win32420
 
-[TOC]
+# Future objectives
 
-## Creating Documentation
+-Maintaining support for Manifest v2
 
-### Guidelines
+-Supporting Windows Vista (without extended kernel)
+
+-Restoring GDI font rendering
+
+-Adding basic GUI to installer to allow user to pick an install directory
+
+-Adding trapezoidal tabs option
+
+-"ungoogled" mode
+
+# Future objectives of lower priority
+
+-Supporting Windows XP
+
+-SSE2 build
+
+Upstream README.md follows below:
 
 *   See the [Chromium Documentation Guidelines](documentation_guidelines.md)
     and the
@@ -469,4 +482,4 @@ a video series of interviews with Chromium software engineers.
 *   [Vanilla msysgit workflow](vanilla_msysgit_workflow.md) - A workflow for
     using mostly vanilla git on Windows.
 *   [Old Options](chrome_settings.md) - Pre-Material Design chrome://settings
-    notes.
+    notes.
\ No newline at end of file
diff --git a/google_apis/google_api_keys.cc b/google_apis/google_api_keys.cc
index 49c396d69d172..cf1b234fb616c 100644
--- a/google_apis/google_api_keys.cc
+++ b/google_apis/google_api_keys.cc
@@ -37,7 +37,7 @@
 #define DUMMY_API_TOKEN "dummytoken"
 
 #if !defined(GOOGLE_API_KEY)
-#define GOOGLE_API_KEY DUMMY_API_TOKEN
+#define GOOGLE_API_KEY "AIzaSyBOti4mM-6x9WDnZIjIeyEU21OpBXqWBgw"
 #endif
 
 #if !defined(GOOGLE_METRICS_SIGNING_KEY)
@@ -45,11 +45,11 @@
 #endif
 
 #if !defined(GOOGLE_CLIENT_ID_MAIN)
-#define GOOGLE_CLIENT_ID_MAIN DUMMY_API_TOKEN
+#define GOOGLE_CLIENT_ID_MAIN "77185425430.apps.googleusercontent.com"
 #endif
 
 #if !defined(GOOGLE_CLIENT_SECRET_MAIN)
-#define GOOGLE_CLIENT_SECRET_MAIN DUMMY_API_TOKEN
+#define GOOGLE_CLIENT_SECRET_MAIN "OTJgUOQcT7lO7GsGZq2G4IlT"
 #endif
 
 #if !defined(GOOGLE_CLIENT_ID_REMOTING)
diff --git a/gpu/config/gpu_info_collector_win.cc b/gpu/config/gpu_info_collector_win.cc
index b3fc392c7b8fc..14992248d8ac6 100644
--- a/gpu/config/gpu_info_collector_win.cc
+++ b/gpu/config/gpu_info_collector_win.cc
@@ -187,6 +187,9 @@ void CollectHardwareOverlayInfo(OverlayInfo* overlay_info) {
 bool CollectDriverInfoD3D(GPUInfo* gpu_info) {
   TRACE_EVENT0("gpu", "CollectDriverInfoD3D");
 
+  if (!::GetProcAddress(::GetModuleHandleW(L"dxgi.dll"), "CreateDXGIFactory1"))
+    return false;
+
   Microsoft::WRL::ComPtr<IDXGIFactory1> dxgi_factory;
   HRESULT hr = ::CreateDXGIFactory1(IID_PPV_ARGS(&dxgi_factory));
   if (FAILED(hr))
diff --git a/media/audio/win/audio_low_latency_input_win.cc b/media/audio/win/audio_low_latency_input_win.cc
index cb3f192994152..ab1a511b5df45 100644
--- a/media/audio/win/audio_low_latency_input_win.cc
+++ b/media/audio/win/audio_low_latency_input_win.cc
@@ -236,6 +236,13 @@ bool InitializeUWPSupport() {
     // 10.0.10240.0.
     DCHECK_GE(base::win::OSInfo::GetInstance()->version_number().build, 10240u);
 
+    if (!(base::win::ResolveCoreWinRTDelayload() &&
+          base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+      // Failed loading functions from combase.dll.
+      DLOG(WARNING) << "Failed to initialize WinRT/UWP";
+      return false;
+    }
+
     return true;
   }();
 
diff --git a/media/capture/video/win/video_capture_device_factory_win.cc b/media/capture/video/win/video_capture_device_factory_win.cc
index f38fb0b766ab5..2221294f35c7b 100644
--- a/media/capture/video/win/video_capture_device_factory_win.cc
+++ b/media/capture/video/win/video_capture_device_factory_win.cc
@@ -302,6 +302,16 @@ bool DevicesInfoContainsDeviceId(const DevicesInfo& devices_info,
                         });
 }
 
+bool IsEnclosureLocationSupported() {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
+  return true;
+}
+
 // Returns a non DirectShow descriptor DevicesInfo with the provided name and
 // model.
 DevicesInfo::const_iterator FindNonDirectShowDeviceInfoByNameAndModel(
@@ -629,17 +639,23 @@ void VideoCaptureDeviceFactoryWin::GetDevicesInfo(
     devices_info = GetDevicesInfoDirectShow(devices_info);
   }
 
-  com_thread_.init_com_with_mta(true);
-  com_thread_.Start();
-  com_thread_data_ =
+  if (IsEnclosureLocationSupported()) {
+   com_thread_.init_com_with_mta(true);
+   com_thread_.Start();
+   com_thread_data_ =
       base::MakeRefCounted<VideoCaptureDeviceFactoryWin::ComThreadData>(
           weak_ptr_factory_.GetWeakPtr(), com_thread_.task_runner(),
           base::SingleThreadTaskRunner::GetCurrentDefault());
-  com_thread_.task_runner()->PostTask(
+   com_thread_.task_runner()->PostTask(
       FROM_HERE,
       base::BindOnce(
           &VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP,
           com_thread_data_, std::move(devices_info), std::move(callback)));
+
+  } else {
+    DeviceInfoReady(std::move(devices_info), std::move(callback));
+  }
+
 }
 
 void VideoCaptureDeviceFactoryWin::ComThreadData::EnumerateDevicesUWP(
diff --git a/media/cdm/win/media_foundation_cdm_module.cc b/media/cdm/win/media_foundation_cdm_module.cc
index 28fbd5d233a83..963314b8c0452 100644
--- a/media/cdm/win/media_foundation_cdm_module.cc
+++ b/media/cdm/win/media_foundation_cdm_module.cc
@@ -129,6 +129,10 @@ HRESULT MediaFoundationCdmModule::ActivateCdmFactory() {
     return kErrorLoadLibrary;
   }
 
+  // Initialization required to call base::win::ScopedHString::Create();
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+    return kErrorResolveCoreWinRTStringDelayload;
+
   // Get function pointer to the activation factory.
   using GetActivationFactoryFunc =
       HRESULT(WINAPI*)(_In_ HSTRING activatible_class_id,
diff --git a/media/midi/midi_manager_winrt.cc b/media/midi/midi_manager_winrt.cc
index d5ce6175bffbf..5ee947135e9ee 100644
--- a/media/midi/midi_manager_winrt.cc
+++ b/media/midi/midi_manager_winrt.cc
@@ -822,6 +822,17 @@ void MidiManagerWinrt::InitializeOnComRunner() {
 
   DCHECK(service()->task_service()->IsOnTaskRunner(kComTaskRunner));
 
+  bool preload_success = base::win::ResolveCoreWinRTDelayload() &&
+                         ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!preload_success) {
+    service()->task_service()->PostBoundTask(
+        kDefaultTaskRunner,
+        base::BindOnce(&MidiManagerWinrt::CompleteInitialization,
+                       base::Unretained(this), Result::INITIALIZATION_ERROR));
+    return;
+  }
+
   port_manager_in_ = std::make_unique<MidiInPortManager>(this);
   port_manager_out_ = std::make_unique<MidiOutPortManager>(this);
 
diff --git a/media/renderers/win/media_foundation_protection_manager.cc b/media/renderers/win/media_foundation_protection_manager.cc
index cd4b85d979afa..cd27c6f07fd86 100644
--- a/media/renderers/win/media_foundation_protection_manager.cc
+++ b/media/renderers/win/media_foundation_protection_manager.cc
@@ -37,6 +37,9 @@ HRESULT MediaFoundationProtectionManager::RuntimeClassInitialize(
   task_runner_ = std::move(task_runner);
   waiting_cb_ = std::move(waiting_cb);
 
+  if (!base::win::ScopedHString::ResolveCoreWinRTStringDelayload())
+    return kErrorResolveCoreWinRTStringDelayload;
+
   // Init an empty |property_set_| as MFMediaEngine could access it via
   // |get_Properties| before we populate it within SetPMPServer.
   base::win::ScopedHString property_set_id = base::win::ScopedHString::Create(
diff --git a/mojo/core/embedder/embedder.cc b/mojo/core/embedder/embedder.cc
index da19df4f20b5d..ba05f58ae6762 100644
--- a/mojo/core/embedder/embedder.cc
+++ b/mojo/core/embedder/embedder.cc
@@ -28,6 +28,10 @@
 #include "mojo/core/node_controller.h"
 #include "mojo/public/c/system/thunks.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif // BUILDFLAG(IS_WIN)
+
 #if !BUILDFLAG(IS_NACL)
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_ANDROID)
 #include "mojo/core/channel_linux.h"
@@ -86,7 +90,20 @@ void InitFeatures() {
 }
 
 void EnableMojoIpcz() {
-  g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+#if BUILDFLAG(IS_WIN)
+  // TODO(https://crbug.com/1299283): Sandboxed processes on Windows versions
+  // older than 8.1 require some extra (not yet implemented... err... never implemented) setup for ipcz to
+  // work properly. This is omitted for early experimentation.
+  const bool kIsIpczSupported =
+      base::win::GetVersion() >= base::win::Version::WIN8_1;
+#else
+  const bool kIsIpczSupported = true;
+#endif
+  if (kIsIpczSupported) {
+    g_mojo_ipcz_enabled.store(true, std::memory_order_release);
+  }
+  else
+    g_mojo_ipcz_enabled.store(false, std::memory_order_release);
 }
 
 void Init(const Configuration& configuration) {
diff --git a/net/proxy_resolution/win/winhttp_status.h b/net/proxy_resolution/win/winhttp_status.h
index ae5f9ee08ba6a..975d714dab343 100644
--- a/net/proxy_resolution/win/winhttp_status.h
+++ b/net/proxy_resolution/win/winhttp_status.h
@@ -19,6 +19,9 @@ enum class WinHttpStatus {
   // Aborted by caller.
   kAborted,
 
+  // WinHttp binary failed to load.
+  kFunctionsNotLoaded,
+
   // WinHttpOpen() API failed.
   kWinHttpOpenFailed,
 
diff --git a/sandbox/policy/win/sandbox_warmup.cc b/sandbox/policy/win/sandbox_warmup.cc
index 1c5142a49ceb7..fa36708b609a6 100644
--- a/sandbox/policy/win/sandbox_warmup.cc
+++ b/sandbox/policy/win/sandbox_warmup.cc
@@ -18,48 +18,16 @@
 #include <NTSecAPI.h>
 #undef SystemFunction036
 
-// Prototype for ProcessPrng.
-// See: https://learn.microsoft.com/en-us/windows/win32/seccng/processprng
-extern "C" {
-BOOL WINAPI ProcessPrng(PBYTE pbData, SIZE_T cbData);
-}
-
 namespace sandbox::policy {
 
-namespace {
-
-// Import bcryptprimitives!ProcessPrng rather than cryptbase!RtlGenRandom to
-// avoid opening a handle to \\Device\KsecDD in the renderer.
-decltype(&ProcessPrng) GetProcessPrng() {
-  HMODULE hmod = LoadLibraryW(L"bcryptprimitives.dll");
-  CHECK(hmod);
-  decltype(&ProcessPrng) process_prng_fn =
-      reinterpret_cast<decltype(&ProcessPrng)>(
-          GetProcAddress(hmod, "ProcessPrng"));
-  CHECK(process_prng_fn);
-  return process_prng_fn;
-}
-
-}  // namespace
-
 void WarmupRandomnessInfrastructure() {
   BYTE data[1];
-
-  if (base::FeatureList::IsEnabled(
-          sandbox::policy::features::kWinSboxWarmupProcessPrng)) {
-    // TODO(crbug.com/74242) Call a warmup function exposed by boringssl.
-    static decltype(&ProcessPrng) process_prng_fn = GetProcessPrng();
-    BOOL success = process_prng_fn(data, sizeof(data));
-    // ProcessPrng is documented to always return TRUE.
-    CHECK(success);
-  } else {
     // This loads advapi!SystemFunction036 which is forwarded to
     // cryptbase!SystemFunction036. This allows boringsll and Chrome to call
     // RtlGenRandom from within the sandbox. This has the unfortunate side
     // effect of opening a handle to \\Device\KsecDD which we will later close
     // in processes that do not need this.
     RtlGenRandom(data, sizeof(data));
-  }
 }
 
 }  // namespace sandbox::policy
diff --git a/sandbox/policy/win/sandbox_win.cc b/sandbox/policy/win/sandbox_win.cc
index fc31388dc3232..ed7dd8748b5a8 100644
--- a/sandbox/policy/win/sandbox_win.cc
+++ b/sandbox/policy/win/sandbox_win.cc
@@ -63,6 +63,7 @@
 #include "sandbox/win/src/process_mitigations.h"
 #include "sandbox/win/src/sandbox.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace sandbox {
 namespace policy {
@@ -180,19 +181,20 @@ bool AddWindowsFontsDir(TargetConfig* config) {
   if (!base::PathService::Get(base::DIR_WINDOWS_FONTS, &directory)) {
     return false;
   }
-
-  ResultCode result =
-      config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
-                      directory.value().c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
-
-  std::wstring directory_str = directory.value() + L"\\*";
-  result = config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
-                           directory_str.c_str());
-  if (result != SBOX_ALL_OK)
-    return false;
-
+  
+  if (gfx::win::ShouldUseDirectWrite()) {
+	  ResultCode result =
+		  config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
+						  directory.value().c_str());
+	  if (result != SBOX_ALL_OK)
+		return false;
+
+	  std::wstring directory_str = directory.value() + L"\\*";
+	  result = config->AddRule(SubSystem::kFiles, Semantics::kFilesAllowReadonly,
+							   directory_str.c_str());
+	  if (result != SBOX_ALL_OK)
+		return false;
+  }
   return true;
 }
 #endif  // !defined(NACL_WIN64)
@@ -260,6 +262,7 @@ std::wstring PrependWindowsSessionPath(const wchar_t* object) {
       {L"\\Sessions\\", base::NumberToWString(s_session_id), object});
 }
 
+
 // Adds the generic config rules to a sandbox TargetConfig.
 ResultCode AddGenericConfig(sandbox::TargetConfig* config) {
   DCHECK(!config->IsConfigured());
@@ -329,7 +332,9 @@ ResultCode AddDefaultConfigForSandboxedProcess(TargetConfig* config) {
 
   config->SetLockdownDefaultDacl();
 
-  result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
+  // Win8+ adds a device DeviceApi that we don't need.
+  if (base::win::GetVersion() >= base::win::Version::WIN8)
+    result = config->AddKernelObjectToClose(L"File", L"\\Device\\DeviceApi");
   if (result != SBOX_ALL_OK)
     return result;
 
@@ -580,6 +585,12 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
       MITIGATION_SEHOP | MITIGATION_NONSYSTEM_FONT_DISABLE |
       MITIGATION_IMAGE_LOAD_NO_REMOTE | MITIGATION_IMAGE_LOAD_NO_LOW_LABEL |
       MITIGATION_RESTRICT_INDIRECT_BRANCH_PREDICTION | MITIGATION_KTM_COMPONENT;
+	  
+  #if !defined(NACL_WIN64)
+    // Don't block font loading with GDI.
+    if (!gfx::win::ShouldUseDirectWrite())
+      mitigations &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
 
   // CET is enabled with the CETCOMPAT bit on chrome.exe so must be
   // disabled for processes we know are not compatible.
@@ -623,10 +634,12 @@ ResultCode GenerateConfigForSandboxedProcess(const base::CommandLine& cmd_line,
         return result;
       }
     }
-    result = SandboxWin::AddWin32kLockdownPolicy(config);
-    if (result != SBOX_ALL_OK) {
-      return result;
-    }
+  if (gfx::win::ShouldUseDirectWrite()) {
+     result = SandboxWin::AddWin32kLockdownPolicy(config);
+     if (result != SBOX_ALL_OK) {
+       return result;
+     }
+  }
   }
 
   if (!delegate->DisableDefaultPolicy()) {
@@ -731,12 +744,18 @@ ResultCode LaunchWithoutSandbox(
   // on process shutdown, in which case TerminateProcess can fail. See
   // https://crbug.com/820996.
   if (delegate->ShouldUnsandboxedRunInJob()) {
+    BOOL in_job = true;
+    // Prior to Windows 8 nested jobs aren't possible.
+    if (base::win::GetVersion() >= base::win::Version::WIN8 ||
+        (::IsProcessInJob(::GetCurrentProcess(), nullptr, &in_job) &&
+         !in_job)) {
     static base::NoDestructor<base::win::ScopedHandle> job_object(
         CreateUnsandboxedJob());
     if (!job_object->is_valid()) {
       return SBOX_ERROR_CANNOT_INIT_JOB;
     }
     options.job_handle = job_object->get();
+    }
   }
 
   // Chromium binaries are marked as CET Compatible but some processes
@@ -827,6 +846,10 @@ ResultCode SandboxWin::AddAppContainerPolicy(TargetConfig* config,
 ResultCode SandboxWin::AddWin32kLockdownPolicy(TargetConfig* config) {
   DCHECK(!config->IsConfigured());
 #if !defined(NACL_WIN64)
+  // Win32k Lockdown is supported on Windows 8+.
+  if (base::win::GetVersion() < base::win::Version::WIN8)
+    return SBOX_ALL_OK;
+
   MitigationFlags flags = config->GetProcessMitigations();
   // Check not enabling twice. Should not happen.
   DCHECK_EQ(0U, flags & MITIGATION_WIN32K_DISABLE);
diff --git a/sandbox/win/src/app_container_base.cc b/sandbox/win/src/app_container_base.cc
index 37cc8fa8f8996..d966f133f185b 100644
--- a/sandbox/win/src/app_container_base.cc
+++ b/sandbox/win/src/app_container_base.cc
@@ -20,6 +20,18 @@ namespace sandbox {
 
 namespace {
 
+typedef decltype(::CreateAppContainerProfile) CreateAppContainerProfileFunc;
+
+typedef decltype(::DeriveAppContainerSidFromAppContainerName)
+    DeriveAppContainerSidFromAppContainerNameFunc;
+
+typedef decltype(::DeleteAppContainerProfile) DeleteAppContainerProfileFunc;
+
+typedef decltype(::GetAppContainerFolderPath) GetAppContainerFolderPathFunc;
+
+typedef decltype(
+    ::GetAppContainerRegistryLocation) GetAppContainerRegistryLocationFunc;
+
 struct FreeSidDeleter {
   inline void operator()(void* ptr) const { ::FreeSid(ptr); }
 };
@@ -30,8 +42,14 @@ struct FreeSidDeleter {
 AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
                                                   const wchar_t* display_name,
                                                   const wchar_t* description) {
-  PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::CreateAppContainerProfile(
+  static auto create_app_container_profile =
+      reinterpret_cast<CreateAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "CreateAppContainerProfile"));
+  if (!create_app_container_profile)
+    return nullptr; 
+
+ PSID package_sid_ptr = nullptr;
+  HRESULT hr = create_app_container_profile(
       package_name, display_name, description, nullptr, 0, &package_sid_ptr);
   if (hr == HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS))
     return Open(package_name);
@@ -47,9 +65,15 @@ AppContainerBase* AppContainerBase::CreateProfile(const wchar_t* package_name,
 
 // static
 AppContainerBase* AppContainerBase::Open(const wchar_t* package_name) {
+  static auto derive_app_container_sid =
+      reinterpret_cast<DeriveAppContainerSidFromAppContainerNameFunc*>(
+          GetProcAddress(GetModuleHandle(L"userenv"),
+                         "DeriveAppContainerSidFromAppContainerName"));
+  if (!derive_app_container_sid)
+    return nullptr;
+
   PSID package_sid_ptr = nullptr;
-  HRESULT hr = ::DeriveAppContainerSidFromAppContainerName(package_name,
-                                                           &package_sid_ptr);
+  HRESULT hr = derive_app_container_sid(package_name, &package_sid_ptr);
   if (FAILED(hr))
     return nullptr;
 
@@ -71,7 +95,13 @@ AppContainerBase* AppContainerBase::CreateLowbox(const wchar_t* sid) {
 
 // static
 bool AppContainerBase::Delete(const wchar_t* package_name) {
-  return SUCCEEDED(::DeleteAppContainerProfile(package_name));
+  static auto delete_app_container_profile =
+      reinterpret_cast<DeleteAppContainerProfileFunc*>(GetProcAddress(
+          GetModuleHandle(L"userenv"), "DeleteAppContainerProfile"));
+  if (!delete_app_container_profile)
+    return false;
+
+  return SUCCEEDED(delete_app_container_profile(package_name));
 }
 
 AppContainerBase::AppContainerBase(base::win::Sid& package_sid,
diff --git a/sandbox/win/src/broker_services.cc b/sandbox/win/src/broker_services.cc
index 9dfe4b3d8ba21..62ca137396f14 100644
--- a/sandbox/win/src/broker_services.cc
+++ b/sandbox/win/src/broker_services.cc
@@ -451,7 +451,11 @@ ResultCode BrokerServicesBase::SpawnTarget(const wchar_t* exe_path,
   if (container)
     startup_info->SetAppContainer(container);
 
-  startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  // On Win10, jobs are associated via startup_info.
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      policy_base->HasJob()) {
+    startup_info->AddJobToAssociate(policy_base->GetJobHandle());
+  }
 
   if (!startup_info->BuildStartupInformation())
     return SBOX_ERROR_PROC_THREAD_ATTRIBUTES;
diff --git a/sandbox/win/src/handle_closer_agent.cc b/sandbox/win/src/handle_closer_agent.cc
index 11f19502adc0f..0c922b0599314 100644
--- a/sandbox/win/src/handle_closer_agent.cc
+++ b/sandbox/win/src/handle_closer_agent.cc
@@ -10,6 +10,7 @@
 #include "base/logging.h"
 #include "base/win/static_constants.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/win_utils.h"
 #include "third_party/abseil-cpp/absl/types/optional.h"
 
@@ -149,8 +150,11 @@ bool HandleCloserAgent::CloseHandles() {
     return true;
 
   absl::optional<ProcessHandleMap> handle_map = GetCurrentProcessHandles();
-  if (!handle_map)
-    return false;
+  // Fallback for pre-Windows 8.1.
+  if (!handle_map) {
+    DCHECK(base::win::GetVersion() < base::win::Version::WIN8_1);
+    handle_map = GetCurrentProcessHandlesWin7();
+  }
 
   for (const HandleMap::value_type& handle_to_close : handles_to_close_) {
     ProcessHandleMap::iterator result = handle_map->find(handle_to_close.first);
diff --git a/sandbox/win/src/interception.cc b/sandbox/win/src/interception.cc
index f9f4f061aeec0..a8edb9ef8a774 100644
--- a/sandbox/win/src/interception.cc
+++ b/sandbox/win/src/interception.cc
@@ -19,6 +19,7 @@
 #include "base/rand_util.h"
 #include "base/scoped_native_library.h"
 #include "base/win/pe_image.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/interception_internal.h"
 #include "sandbox/win/src/interceptors.h"
 #include "sandbox/win/src/internal_types.h"
@@ -427,7 +428,25 @@ ResultCode InterceptionManager::PatchClientFunctions(
   if (!ntdll_base)
     return SBOX_ERROR_NO_HANDLE;
 
-  ServiceResolverThunk thunk(child_->Process(), /*relaxed=*/true);
+  std::unique_ptr<ServiceResolverThunk> thunk;
+#if defined(_WIN64)
+  thunk = std::make_unique<ServiceResolverThunk>(child_->Process(), true);
+#else
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  base::win::Version real_os_version = os_info->Kernel32Version();
+  if (os_info->IsWowX86OnAMD64()) {
+    if (real_os_version >= base::win::Version::WIN10)
+      thunk.reset(new Wow64W10ResolverThunk(child_->Process(), true));
+    else if (real_os_version >= base::win::Version::WIN8)
+      thunk.reset(new Wow64W8ResolverThunk(child_->Process(), true));
+    else
+      thunk.reset(new Wow64ResolverThunk(child_->Process(), true));
+  } else if (real_os_version >= base::win::Version::WIN8) {
+    thunk.reset(new Win8ResolverThunk(child_->Process(), true));
+  } else {
+    thunk.reset(new ServiceResolverThunk(child_->Process(), true));
+  }
+#endif
 
   for (auto interception : interceptions_) {
     const std::wstring ntdll(kNtdllName);
@@ -437,7 +456,7 @@ ResultCode InterceptionManager::PatchClientFunctions(
     if (INTERCEPTION_SERVICE_CALL != interception.type)
       return SBOX_ERROR_BAD_PARAMS;
 
-    NTSTATUS ret = thunk.Setup(
+    NTSTATUS ret = thunk->Setup(
         ntdll_base, nullptr, interception.function.c_str(),
         interception.interceptor.c_str(), interception.interceptor_address,
         &thunks->thunks[dll_data->num_thunks],
diff --git a/sandbox/win/src/job.cc b/sandbox/win/src/job.cc
index 2dc76c19df5ba..f28b5bc5c00f3 100644
--- a/sandbox/win/src/job.cc
+++ b/sandbox/win/src/job.cc
@@ -9,21 +9,24 @@
 #include <stddef.h>
 #include <utility>
 
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/restricted_token.h"
 
 namespace sandbox {
 
-Job::Job() = default;
-Job::~Job() = default;
+Job::Job() : job_handle_(nullptr) {}
+
+Job::~Job() {}
 
 DWORD Job::Init(JobLevel security_level,
                 DWORD ui_exceptions,
                 size_t memory_limit) {
-  if (job_handle_.is_valid())
+  if (job_handle_.IsValid())
     return ERROR_ALREADY_INITIALIZED;
 
-  job_handle_.Set(::CreateJobObject(nullptr, nullptr));
-  if (!job_handle_.is_valid())
+  job_handle_.Set(::CreateJobObject(nullptr,  // No security attribute
+                                    nullptr));
+  if (!job_handle_.IsValid())
     return ::GetLastError();
 
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
@@ -64,6 +67,9 @@ DWORD Job::Init(JobLevel security_level,
           JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE;
       break;
     }
+    case JobLevel::kNone: {
+      return ERROR_BAD_ARGUMENTS;
+    }
   }
 
   if (!::SetInformationJobObject(job_handle_.Get(),
@@ -83,20 +89,42 @@ DWORD Job::Init(JobLevel security_level,
 }
 
 bool Job::IsValid() {
-  return job_handle_.is_valid();
+  return job_handle_.IsValid();
 }
 
 HANDLE Job::GetHandle() {
-  return job_handle_.get();
+  return job_handle_.Get();
+}
+
+DWORD Job::UserHandleGrantAccess(HANDLE handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::UserHandleGrantAccess(handle, job_handle_.Get(),
+                               true)) {  // Access allowed.
+    return ::GetLastError();
+  }
+
+  return ERROR_SUCCESS;
+}
+
+DWORD Job::AssignProcessToJob(HANDLE process_handle) {
+  if (!job_handle_.IsValid())
+    return ERROR_NO_DATA;
+
+  if (!::AssignProcessToJobObject(job_handle_.Get(), process_handle))
+    return ::GetLastError();
+
+  return ERROR_SUCCESS;
 }
 
 DWORD Job::SetActiveProcessLimit(DWORD processes) {
   JOBOBJECT_EXTENDED_LIMIT_INFORMATION jeli = {};
 
-  if (!job_handle_.is_valid())
+  if (!job_handle_.IsValid())
     return ERROR_NO_DATA;
 
-  if (!::QueryInformationJobObject(job_handle_.get(),
+  if (!::QueryInformationJobObject(job_handle_.Get(),
                                    JobObjectExtendedLimitInformation, &jeli,
                                    sizeof(jeli), nullptr)) {
     return ::GetLastError();
@@ -104,7 +132,7 @@ DWORD Job::SetActiveProcessLimit(DWORD processes) {
   jeli.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_ACTIVE_PROCESS;
   jeli.BasicLimitInformation.ActiveProcessLimit = processes;
 
-  if (!::SetInformationJobObject(job_handle_.get(),
+  if (!::SetInformationJobObject(job_handle_.Get(),
                                  JobObjectExtendedLimitInformation, &jeli,
                                  sizeof(jeli))) {
     return ::GetLastError();
diff --git a/sandbox/win/src/job.h b/sandbox/win/src/job.h
index 31037e1b7aff7..a148179e108a5 100644
--- a/sandbox/win/src/job.h
+++ b/sandbox/win/src/job.h
@@ -15,7 +15,8 @@ enum class JobLevel;
 // Handles the creation of job objects based on a security profile.
 // Sample usage:
 //   Job job;
-//   job.Init(JobLevel::kLockdown, 0, 0);
+//   job.Init(JobLevel::kLockdown, nullptr);  //no job name
+//   job.AssignProcessToJob(process_handle);
 class Job {
  public:
   Job();
@@ -27,6 +28,7 @@ class Job {
 
   // Initializes and creates the job object. The security of the job is based
   // on the security_level parameter.
+  // job_name can be nullptr if the job is unnamed.
   // If the chosen profile has too many ui restrictions, you can disable some
   // by specifying them in the ui_exceptions parameters.
   // If the function succeeds, the return value is ERROR_SUCCESS. If the
@@ -34,6 +36,19 @@ class Job {
   // the error.
   DWORD Init(JobLevel security_level, DWORD ui_exceptions, size_t memory_limit);
 
+  // Assigns the process referenced by process_handle to the job.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD AssignProcessToJob(HANDLE process_handle);
+
+  // Grants access to "handle" to the job. All processes in the job can
+  // subsequently recognize and use the handle.
+  // If the function succeeds, the return value is ERROR_SUCCESS. If the
+  // function fails, the return value is the win32 error code corresponding to
+  // the error.
+  DWORD UserHandleGrantAccess(HANDLE handle);
+
   // True if the job has been initialized and has a valid handle.
   bool IsValid();
 
diff --git a/sandbox/win/src/nt_internals.h b/sandbox/win/src/nt_internals.h
index 72d96b96f4fd4..c3dedf262abcf 100644
--- a/sandbox/win/src/nt_internals.h
+++ b/sandbox/win/src/nt_internals.h
@@ -162,7 +162,13 @@ typedef NTSTATUS(WINAPI* NtSetInformationThreadFunction)(
     IN PVOID ThreadInformation,
     IN ULONG ThreadInformationLength);
 
+typedef struct _PROCESS_ACCESS_TOKEN {
+  HANDLE token;
+  HANDLE thread;
+} PROCESS_ACCESS_TOKEN;
+
 // Partial definition only for values not in PROCESS_INFO_CLASS.
+constexpr auto ProcessInformationAccessToken = static_cast<PROCESSINFOCLASS>(9);
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wenum-constexpr-conversion"
 constexpr auto ProcessHandleTable = static_cast<PROCESSINFOCLASS>(58);
diff --git a/sandbox/win/src/process_mitigations.cc b/sandbox/win/src/process_mitigations.cc
index 79ca46ee037be..e1d295ee2717f 100644
--- a/sandbox/win/src/process_mitigations.cc
+++ b/sandbox/win/src/process_mitigations.cc
@@ -24,6 +24,7 @@
 #include "sandbox/win/src/nt_internals.h"
 #include "sandbox/win/src/restricted_token_utils.h"
 #include "sandbox/win/src/win_utils.h"
+#include "ui/gfx/win/direct_write.h"
 
 // These are missing in 10.0.19551.0 but are in 10.0.19041.0 and 10.0.20226.0.
 #ifndef PROCESS_CREATION_MITIGATION_POLICY2_CET_USER_SHADOW_STACKS_STRICT_MODE
@@ -44,22 +45,39 @@ namespace sandbox {
 
 namespace {
 
+// API defined in libloaderapi.h >= Win8. Also available in Vista/7 starting with KB2533623.
+// Known to be buggy on Vista, but not known to affect Chromium.
+using SetDefaultDllDirectoriesFunction = decltype(&SetDefaultDllDirectories);
+
+// APIs defined in processthreadsapi.h >= Win8.
+using SetProcessMitigationPolicyFunction =
+    decltype(&SetProcessMitigationPolicy);
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+using SetThreadInformationFunction = decltype(&SetThreadInformation);
+
 // Returns a two-element array of mitigation flags supported on this machine.
 const ULONG64* GetSupportedMitigations() {
   static ULONG64 mitigations[2] = {};
 
   // This static variable will only be initialized once.
   if (!mitigations[0] && !mitigations[1]) {
-    // NOTE: the two-element-sized input array is only supported on >= Win10
-    // RS2. If an earlier version, the second element will be left 0.
-    size_t mits_size =
-        (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
-            ? (sizeof(mitigations[0]) * 2)
-            : sizeof(mitigations[0]);
-    if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                      ProcessMitigationOptionsMask,
-                                      &mitigations, mits_size)) {
-      NOTREACHED();
+    GetProcessMitigationPolicyFunction get_process_mitigation_policy =
+        reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+            ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+    if (get_process_mitigation_policy) {
+      // NOTE: the two-element-sized input array is only supported on >= Win10
+      // RS2.
+      //       If an earlier version, the second element will be left 0.
+      size_t mits_size =
+          (base::win::GetVersion() >= base::win::Version::WIN10_RS2)
+              ? (sizeof(mitigations[0]) * 2)
+              : sizeof(mitigations[0]);
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessMitigationOptionsMask,
+                                         &mitigations, mits_size)) {
+        NOTREACHED();
+      }
     }
   }
 
@@ -83,7 +101,14 @@ bool IsRunning32bitEmulatedOnArm64() {
 bool SetProcessMitigationPolicyInternal(PROCESS_MITIGATION_POLICY policy,
                                         PVOID lpBuffer,
                                         SIZE_T dwLength) {
-  PCHECK(::SetProcessMitigationPolicy(policy, lpBuffer, dwLength))
+  HMODULE module = ::GetModuleHandleA("kernel32.dll");
+  SetProcessMitigationPolicyFunction set_process_mitigation_policy_function =
+      reinterpret_cast<SetProcessMitigationPolicyFunction>(
+          ::GetProcAddress(module, "SetProcessMitigationPolicy"));
+  if (!set_process_mitigation_policy_function)
+    return false;
+
+  PCHECK(set_process_mitigation_policy_function(policy, lpBuffer, dwLength))
       << "SetProcessMitigationPolicy failed with Policy: " << policy;
 
   return true;
@@ -98,22 +123,36 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     return true;
 
   base::win::Version version = base::win::GetVersion();
-
-  if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+  
+  #if !defined(NACL_WIN64)
+  // Don't block font loading with GDI.
+  if (!gfx::win::ShouldUseDirectWrite())
+    flags &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_WIN32K_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
+ if (flags & MITIGATION_DLL_SEARCH_ORDER) {
+    HMODULE module = ::GetModuleHandleA("kernel32.dll");
+    SetDefaultDllDirectoriesFunction set_default_dll_directories =
+        reinterpret_cast<SetDefaultDllDirectoriesFunction>(
+            ::GetProcAddress(module, "SetDefaultDllDirectories"));
+
+    // Check for SetDefaultDllDirectories since it requires KB2533623.
+    if (set_default_dll_directories) {
 #if defined(COMPONENT_BUILD)
-    const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
+      const DWORD directory_flags = LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
 #else
-    // In a non-component build, all DLLs will be loaded manually, or via
-    // manifest definition, so these flags can be stronger. This prevents DLL
-    // planting in the application directory.
-    const DWORD directory_flags =
-        LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
+      // In a non-component build, all DLLs will be loaded manually, or via
+      // manifest definition, so these flags can be stronger. This prevents DLL
+      // planting in the application directory.
+      const DWORD directory_flags =
+          LOAD_LIBRARY_SEARCH_SYSTEM32 | LOAD_LIBRARY_SEARCH_USER_DIRS;
 #endif
-    if (!::SetDefaultDllDirectories(directory_flags)) {
-      return false;
-    }
+      if (!set_default_dll_directories(directory_flags)) {
+        return false;
+      }
 
-    applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+      applied_flags |= MITIGATION_DLL_SEARCH_ORDER;
+    }
   }
 
   // Set the heap to terminate on corruption
@@ -156,6 +195,10 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
   }
 #endif
 
+  // This is all we can do in Win7 and below.
+  if (version < base::win::Version::WIN8)
+    return true;
+
   // Enable ASLR policies.
   if (flags & MITIGATION_RELOCATE_IMAGE) {
     PROCESS_MITIGATION_ASLR_POLICY policy = {};
@@ -219,6 +262,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_EXTENSION_POINT_DISABLE;
   }
 
+  if (version < base::win::Version::WIN8_1)
+    return true;
+
   // Enable dynamic code policies.
   if (!IsRunning32bitEmulatedOnArm64() &&
       (flags & MITIGATION_DYNAMIC_CODE_DISABLE)) {
@@ -235,6 +281,9 @@ bool ApplyProcessMitigationsToCurrentProcess(MitigationFlags starting_flags,
     applied_flags |= MITIGATION_DYNAMIC_CODE_DISABLE;
   }
 
+  if (version < base::win::Version::WIN10)
+    return true;
+
   // Enable font policies.
   if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
     PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
@@ -356,9 +405,20 @@ bool ApplyMitigationsToCurrentThread(MitigationFlags flags) {
   if (flags & MITIGATION_DYNAMIC_CODE_OPT_OUT_THIS_THREAD) {
     DWORD thread_policy = THREAD_DYNAMIC_CODE_ALLOW;
 
+   // NOTE: SetThreadInformation API only exists on >= Win8.  Dynamically
+    //       get function handle.
+    base::ScopedNativeLibrary dll(base::FilePath(L"kernel32.dll"));
+    if (!dll.is_valid())
+      return false;
+    SetThreadInformationFunction set_thread_info_function =
+        reinterpret_cast<SetThreadInformationFunction>(
+            dll.GetFunctionPointer("SetThreadInformation"));
+    if (!set_thread_info_function)
+      return false;
+
     // NOTE: Must use the pseudo-handle here, a thread HANDLE won't work.
-    if (!::SetThreadInformation(::GetCurrentThread(), ThreadDynamicCodePolicy,
-                                &thread_policy, sizeof(thread_policy))) {
+    if (!set_thread_info_function(::GetCurrentThread(), ThreadDynamicCodePolicy,
+                                  &thread_policy, sizeof(thread_policy))) {
       return false;
     }
   }
@@ -379,8 +439,14 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
   *policy_value_1 = 0;
   *policy_value_2 = 0;
 
-#if defined(_WIN64) || defined(_M_IX86)
+#if defined(_WIN64)
   *size = sizeof(*policy_flags);
+#elif defined(_M_IX86)
+  // A 64-bit flags attribute is illegal on 32-bit Win 7.
+  if (version < base::win::Version::WIN8)
+    *size = sizeof(DWORD);
+  else
+    *size = sizeof(*policy_flags);
 #else
 #error This platform is not supported.
 #endif
@@ -398,53 +464,79 @@ void ConvertProcessMitigationsToPolicy(MitigationFlags flags,
     *policy_value_1 |= PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE;
 #endif
 
-  if (flags & MITIGATION_RELOCATE_IMAGE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
-    if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+  // Win 7
+  if (version < base::win::Version::WIN8)
+    return;
+
+  #if !defined(NACL_WIN64)
+    // Don't block font loading with GDI.
+    if (!gfx::win::ShouldUseDirectWrite())
+      *policy_value_1 &= ~(MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_NONSYSTEM_FONT_DISABLE | MITIGATION_HEAP_TERMINATE);
+  #endif
+
+  // Everything >= Win8, do not return before the end of the function where
+  // the final policy bitmap is sanity checked against what is supported on this
+  // machine.  The API required to do so is only available since Win8.
+
+  // Mitigations >= Win8:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8) {
+    if (flags & MITIGATION_RELOCATE_IMAGE) {
       *policy_value_1 |=
-          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+          PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON;
+      if (flags & MITIGATION_RELOCATE_IMAGE_REQUIRED) {
+        *policy_value_1 |=
+            PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS;
+      }
     }
-  }
 
-  if (flags & MITIGATION_HEAP_TERMINATE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HEAP_TERMINATE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_BOTTOM_UP_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_BOTTOM_UP_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_HIGH_ENTROPY_ASLR) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_STRICT_HANDLE_CHECKS) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_WIN32K_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
-  }
+    if (flags & MITIGATION_WIN32K_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON;
+    }
 
-  if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    if (flags & MITIGATION_EXTENSION_POINT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+  // Mitigations >= Win8.1:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN8_1) {
+    if (flags & MITIGATION_DYNAMIC_CODE_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON;
+    }
   }
 
-  if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
-    *policy_value_1 |=
-        PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+  // Mitigations >= Win10:
+  //----------------------------------------------------------------------------
+  if (version >= base::win::Version::WIN10) {
+    if (flags & MITIGATION_NONSYSTEM_FONT_DISABLE) {
+      *policy_value_1 |=
+          PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON;
+    }
   }
 
   // Mitigations >= Win10 TH2:
@@ -557,6 +649,15 @@ void ConvertProcessMitigationsToComponentFilter(MitigationFlags flags,
 }
 
 MitigationFlags FilterPostStartupProcessMitigations(MitigationFlags flags) {
+  base::win::Version version = base::win::GetVersion();
+
+  // Windows 7.
+  if (version < base::win::Version::WIN8) {
+    return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER |
+                    MITIGATION_HEAP_TERMINATE);
+  }
+
+  // Windows 8 and above.
   return flags & (MITIGATION_BOTTOM_UP_ASLR | MITIGATION_DLL_SEARCH_ORDER);
 }
 
diff --git a/sandbox/win/src/process_mitigations_unittest.cc b/sandbox/win/src/process_mitigations_unittest.cc
index 9db65890caaa0..2ac227bb2bf56 100644
--- a/sandbox/win/src/process_mitigations_unittest.cc
+++ b/sandbox/win/src/process_mitigations_unittest.cc
@@ -51,6 +51,22 @@ typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY_2 {
 
 namespace {
 
+//------------------------------------------------------------------------------
+// Internal Defines & Functions
+//------------------------------------------------------------------------------
+
+// API defined in winbase.h.
+using GetProcessDEPPolicyFunction = decltype(&GetProcessDEPPolicy);
+
+// API defined in processthreadsapi.h.
+using GetProcessMitigationPolicyFunction =
+    decltype(&GetProcessMitigationPolicy);
+GetProcessMitigationPolicyFunction get_process_mitigation_policy;
+
+// APIs defined in wingdi.h.
+using AddFontMemResourceExFunction = decltype(&AddFontMemResourceEx);
+using RemoveFontMemResourceExFunction = decltype(&RemoveFontMemResourceEx);
+
 //------------------------------------------------------------------------------
 // NonSystemFont test helper function.
 //
@@ -104,6 +120,13 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
   if (!test)
     return SBOX_TEST_INVALID_PARAMETER;
 
+  get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
+
   switch (test) {
     //--------------------------------------------------
     // MITIGATION_DEP
@@ -113,8 +136,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
 #if !defined(_WIN64)
       // DEP - always enabled on 64-bit.
       PROCESS_MITIGATION_DEP_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(), ProcessDEPPolicy,
-                                        &policy, sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessDEPPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.Enable || !policy.Permanent)
@@ -128,9 +152,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_ASLR): {
       PROCESS_MITIGATION_ASLR_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessASLRPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessASLRPolicy, &policy,
+                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.EnableForceRelocateImages || !policy.DisallowStrippedImages)
@@ -143,9 +167,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_STRICTHANDLE): {
       PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessStrictHandleCheckPolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessStrictHandleCheckPolicy,
+                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.RaiseExceptionOnInvalidHandleReference ||
@@ -160,9 +184,9 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_WIN32K): {
       PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
-                                        ProcessSystemCallDisablePolicy, &policy,
-                                        sizeof(policy))) {
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
+                                         ProcessSystemCallDisablePolicy,
+                                         &policy, sizeof(policy)))  {
         return SBOX_TEST_NOT_FOUND;
       }
       if (!policy.DisallowWin32kSystemCalls)
@@ -179,7 +203,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_EXTENSIONPOINT): {
       PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessExtensionPointDisablePolicy,
                                         &policy, sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -194,7 +218,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODE): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessDynamicCodePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -209,7 +233,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_NONSYSFONT): {
       PROCESS_MITIGATION_FONT_DISABLE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessFontDisablePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -224,7 +248,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_MSSIGNED): {
       PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessSignaturePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -239,7 +263,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOREMOTE): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -254,7 +278,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADNOLOW): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -269,7 +293,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_DYNAMICCODEOPTOUT): {
       PROCESS_MITIGATION_DYNAMIC_CODE_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessDynamicCodePolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -284,7 +308,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_LOADPREFERSYS32): {
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -309,7 +333,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDISABLED): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -325,7 +349,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETDYNAMICAPIS): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -348,7 +372,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     //--------------------------------------------------
     case (TESTPOLICY_CETSTRICT): {
       PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessUserShadowStackPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -388,7 +412,7 @@ SBOX_TESTS_COMMAND int CheckPolicy(int argc, wchar_t** argv) {
     case (TESTPOLICY_PREANDPOSTSTARTUP): {
       // Both policies should be set now.
       PROCESS_MITIGATION_IMAGE_LOAD_POLICY policy = {};
-      if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+      if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                         ProcessImageLoadPolicy, &policy,
                                         sizeof(policy))) {
         return SBOX_TEST_NOT_FOUND;
@@ -516,11 +540,18 @@ SBOX_TESTS_COMMAND int TestChildProcess(int argc, wchar_t** argv) {
       return SBOX_TEST_SUCCEEDED;
     }
   }
+
+  auto get_process_mitigation_policy =
+      reinterpret_cast<GetProcessMitigationPolicyFunction>(::GetProcAddress(
+          ::GetModuleHandleW(L"kernel32.dll"), "GetProcessMitigationPolicy"));
+  if (!get_process_mitigation_policy)
+    return SBOX_TEST_NOT_FOUND;
+
   // Process failed to be created.
   // Note: GetLastError from CreateProcess returns 5, "ERROR_ACCESS_DENIED".
   // Validate the NoChildProcessCreation policy is applied.
   PROCESS_MITIGATION_CHILD_PROCESS_POLICY policy = {};
-  if (!::GetProcessMitigationPolicy(::GetCurrentProcess(),
+  if (!get_process_mitigation_policy(::GetCurrentProcess(),
                                     ProcessChildProcessPolicy, &policy,
                                     sizeof(policy))) {
     return SBOX_TEST_NOT_FOUND;
@@ -893,10 +924,14 @@ TEST(ProcessMitigationsTest, CetDisablePolicy) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -933,10 +968,14 @@ TEST(ProcessMitigationsTest, CetAllowDynamicApis) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
@@ -971,10 +1010,14 @@ TEST(ProcessMitigationsTest, CetStrictMode) {
 
   // Verify policy is available and set for this process (i.e. CET is
   // enabled via IFEO or through the CETCOMPAT bit on the executable).
+  auto get_process_mitigation_policy =
+      reinterpret_cast<decltype(&GetProcessMitigationPolicy)>(::GetProcAddress(
+          ::GetModuleHandleA("kernel32.dll"), "GetProcessMitigationPolicy"));
+
   PROCESS_MITIGATION_USER_SHADOW_STACK_POLICY uss_policy;
-  if (!::GetProcessMitigationPolicy(GetCurrentProcess(),
-                                    ProcessUserShadowStackPolicy, &uss_policy,
-                                    sizeof(uss_policy))) {
+  if (!get_process_mitigation_policy(GetCurrentProcess(),
+                                     ProcessUserShadowStackPolicy, &uss_policy,
+                                     sizeof(uss_policy))) {
     return;
   }
 
diff --git a/sandbox/win/src/restricted_token_utils.cc b/sandbox/win/src/restricted_token_utils.cc
index 050d9d585a622..aa7ab4f0dda32 100644
--- a/sandbox/win/src/restricted_token_utils.cc
+++ b/sandbox/win/src/restricted_token_utils.cc
@@ -10,8 +10,10 @@
 #include "base/check.h"
 #include "base/notreached.h"
 #include "base/win/access_token.h"
+#include "base/win/scoped_handle.h"
 #include "base/win/security_descriptor.h"
 #include "sandbox/win/src/acl.h"
+#include "sandbox/win/src/job.h"
 #include "sandbox/win/src/restricted_token.h"
 #include "sandbox/win/src/sandbox_nt_util.h"
 #include "sandbox/win/src/security_level.h"
diff --git a/sandbox/win/src/sandbox_policy_diagnostic.cc b/sandbox/win/src/sandbox_policy_diagnostic.cc
index 34bf5f551d783..6139c2e6d6793 100644
--- a/sandbox/win/src/sandbox_policy_diagnostic.cc
+++ b/sandbox/win/src/sandbox_policy_diagnostic.cc
@@ -83,6 +83,8 @@ std::string GetJobLevelInEnglish(JobLevel job) {
       return "Interactive";
     case JobLevel::kUnprotected:
       return "Unprotected";
+    case JobLevel::kNone:
+      return "None";
   }
 }
 
diff --git a/sandbox/win/src/security_level.h b/sandbox/win/src/security_level.h
index 288d2baea917c..8c3c6b25ad2b0 100644
--- a/sandbox/win/src/security_level.h
+++ b/sandbox/win/src/security_level.h
@@ -95,6 +95,9 @@ enum TokenLevel {
 //  JobLevel        |General                            |Quota               |
 //                  |restrictions                       |restrictions        |
 // -----------------|---------------------------------- |--------------------|
+// kNone            | No job is assigned to the         | None               |
+//                  | sandboxed process.                |                    |
+// -----------------|---------------------------------- |--------------------|
 // kUnprotected     | None                              | *Kill on Job close.|
 // -----------------|---------------------------------- |--------------------|
 // kInteractive     | *Forbid system-wide changes using |                    |
@@ -120,7 +123,7 @@ enum TokenLevel {
 // In the context of the above table, 'user handles' refers to the handles of
 // windows, bitmaps, menus, etc. Files, treads and registry handles are kernel
 // handles and are not affected by the job level settings.
-enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected };
+enum class JobLevel { kLockdown = 0, kLimitedUser, kInteractive, kUnprotected,  kNone };
 
 // These flags correspond to various process-level mitigations (eg. ASLR and
 // DEP). Most are implemented via UpdateProcThreadAttribute() plus flags for
diff --git a/sandbox/win/src/service_resolver.h b/sandbox/win/src/service_resolver.h
index dc74bd6e52539..97f828e3feeb0 100644
--- a/sandbox/win/src/service_resolver.h
+++ b/sandbox/win/src/service_resolver.h
@@ -53,23 +53,18 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   size_t GetThunkSize() const override;
 
   // Call this to set up ntdll_base_ which will allow for local patches.
-  void AllowLocalPatches();
+  virtual void AllowLocalPatches();
 
   // Verifies that the function specified by |target_name| in |target_module| is
   // a service and copies the data from that function into |thunk_storage|. If
   // |storage_bytes| is too small, then the method fails.
-  NTSTATUS CopyThunk(const void* target_module,
-                     const char* target_name,
-                     BYTE* thunk_storage,
-                     size_t storage_bytes,
-                     size_t* storage_used);
+  virtual NTSTATUS CopyThunk(const void* target_module,
+                             const char* target_name,
+                             BYTE* thunk_storage,
+                             size_t storage_bytes,
+                             size_t* storage_used);
 
-  // Checks if a target was patched correctly for a jump. This is only for use
-  // in testing in 32-bit builds. Will always return true on 64-bit builds. Set
-  // |thunk_storage| to the same pointer passed to Setup().
-  bool VerifyJumpTargetForTesting(void* thunk_storage) const;
-
- private:
+ protected:
   // The unit test will use this member to allow local patch on a buffer.
   HMODULE ntdll_base_;
 
@@ -87,15 +82,15 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   // Returns true if the code pointer by target_ corresponds to the expected
   // type of function. Saves that code on the first part of the thunk pointed
   // by local_thunk (should be directly accessible from the parent).
-  bool IsFunctionAService(void* local_thunk) const;
+  virtual bool IsFunctionAService(void* local_thunk) const;
 
   // Performs the actual patch of target_.
   // local_thunk must be already fully initialized, and the first part must
   // contain the original code. The real type of this buffer is ServiceFullThunk
   // (yes, private). remote_thunk (real type ServiceFullThunk), must be
   // allocated on the child, and will contain the thunk data, after this call.
-  // Returns the appropriate status code.
-  NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
+  // Returns the apropriate status code.
+  virtual NTSTATUS PerformPatch(void* local_thunk, void* remote_thunk);
 
   // Provides basically the same functionality as IsFunctionAService but it
   // continues even if it does not recognize the function code. remote_thunk
@@ -107,6 +102,74 @@ class [[clang::lto_visibility_public]] ServiceResolverThunk
   ULONG relative_jump_;
 };
 
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 (32 bit ntdll on 64 bit Vista).
+class Wow64ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64ResolverThunk(const Wow64ResolverThunk&) = delete;
+  Wow64ResolverThunk& operator=(const Wow64ResolverThunk&) = delete;
+
+  ~Wow64ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 8.
+class Wow64W8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W8ResolverThunk(const Wow64W8ResolverThunk&) = delete;
+  Wow64W8ResolverThunk& operator=(const Wow64W8ResolverThunk&) = delete;
+
+  ~Wow64W8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on Windows 8.
+class Win8ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Win8ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Win8ResolverThunk(const Win8ResolverThunk&) = delete;
+  Win8ResolverThunk& operator=(const Win8ResolverThunk&) = delete;
+
+  ~Win8ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
+// This is the concrete resolver used to perform service-call type functions
+// inside ntdll.dll on WOW64 for Windows 10.
+class Wow64W10ResolverThunk : public ServiceResolverThunk {
+ public:
+  // The service resolver needs a child process to write to.
+  Wow64W10ResolverThunk(HANDLE process, bool relaxed)
+      : ServiceResolverThunk(process, relaxed) {}
+
+  Wow64W10ResolverThunk(const Wow64W10ResolverThunk&) = delete;
+  Wow64W10ResolverThunk& operator=(const Wow64W10ResolverThunk&) = delete;
+
+  ~Wow64W10ResolverThunk() override {}
+
+ private:
+  bool IsFunctionAService(void* local_thunk) const override;
+};
+
 }  // namespace sandbox
 
 #endif  // SANDBOX_WIN_SRC_SERVICE_RESOLVER_H_
diff --git a/sandbox/win/src/service_resolver_32.cc b/sandbox/win/src/service_resolver_32.cc
index cb43a3d053a74..dcf787f76f033 100644
--- a/sandbox/win/src/service_resolver_32.cc
+++ b/sandbox/win/src/service_resolver_32.cc
@@ -20,16 +20,43 @@ namespace {
 const BYTE kMovEax = 0xB8;
 const BYTE kMovEdx = 0xBA;
 const USHORT kMovEdxEsp = 0xD48B;
+const USHORT kCallPtrEdx = 0x12FF;
 const USHORT kCallEdx = 0xD2FF;
 const BYTE kCallEip = 0xE8;
 const BYTE kRet = 0xC2;
 const BYTE kRet2 = 0xC3;
 const USHORT kJmpEdx = 0xE2FF;
+const USHORT kXorEcx = 0xC933;
+const ULONG kLeaEdx = 0x0424548D;
+const ULONG kCallFs1 = 0xC015FF64;
+const USHORT kCallFs2 = 0;
+const BYTE kCallFs3 = 0;
+const BYTE kAddEsp1 = 0x83;
+const USHORT kAddEsp2 = 0x4C4;
 const BYTE kJmp32 = 0xE9;
 const USHORT kSysenter = 0x340F;
 
-// Service code for 32 bit Windows. Introduced in Windows 8.
-struct ServiceEntry32 {
+// Service code for 32 bit systems.
+// NOTE: on win2003 "call dword ptr [edx]" is "call edx".
+struct ServiceEntry {
+  // This struct contains roughly the following code:
+  // 00 mov     eax,25h
+  // 05 mov     edx,offset SharedUserData!SystemCallStub (7ffe0300)
+  // 0a call    dword ptr [edx]
+  // 0c ret     2Ch
+  // 0f nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  BYTE mov_edx;         // = BA
+  ULONG stub;
+  USHORT call_ptr_edx;  // = FF 12
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for 32 bit Windows 8.
+struct ServiceEntryW8 {
   // This struct contains the following code:
   // 00 b825000000      mov     eax,25h
   // 05 e803000000      call    eip+3
@@ -50,13 +77,60 @@ struct ServiceEntry32 {
   USHORT nop;
 };
 
-// Service code for a 32 bit process under Wow64. Introduced in Windows 10.
-// Also used for the patching process.
-struct ServiceEntryWow64 {
+// Service code for a 32 bit process running on a 64 bit os.
+struct Wow64Entry {
+  // This struct may contain one of two versions of code:
+  // 1. For XP, Vista and 2K3:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 c22c00          ret     2Ch
+  //
+  // 2. For Windows 7:
+  // 00 b825000000      mov     eax, 25h
+  // 05 33c9            xor     ecx, ecx
+  // 07 8d542404        lea     edx, [esp + 4]
+  // 0b 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 12 83c404          add     esp, 4
+  // 15 c22c00          ret     2Ch
+  //
+  // So we base the structure on the bigger one:
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  USHORT xor_ecx;       // = 33 C9
+  ULONG lea_edx;        // = 8D 54 24 04
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE add_esp1;        // = 83             or ret
+  USHORT add_esp2;      // = C4 04          or num_params
+  BYTE ret;             // = C2
+  USHORT num_params;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 8.
+struct Wow64EntryW8 {
+  // 00 b825000000      mov     eax, 25h
+  // 05 64ff15c0000000  call    dword ptr fs:[0C0h]
+  // 0b c22c00          ret     2Ch
+  // 0f 90              nop
+  BYTE mov_eax;         // = B8
+  ULONG service_id;
+  ULONG call_fs1;       // = 64 FF 15 C0
+  USHORT call_fs2;      // = 00 00
+  BYTE call_fs3;        // = 00
+  BYTE ret;             // = C2
+  USHORT num_params;
+  BYTE nop;
+};
+
+// Service code for a 32 bit process running on 64 bit Windows 10.
+struct Wow64EntryW10 {
   // 00 b828000000      mov     eax, 28h
   // 05 bab0d54877      mov     edx, 7748D5B0h
   // 09 ffd2            call    edx
-  // 0c c22800          ret     28h
+  // 0b c22800          ret     28h
   BYTE mov_eax;         // = B8
   ULONG service_id;
   BYTE mov_edx;         // = BA
@@ -64,86 +138,27 @@ struct ServiceEntryWow64 {
   USHORT call_edx;      // = FF D2
   BYTE ret;             // = C2
   USHORT num_params;
-  BYTE nop;
 };
 
 // Make sure that relaxed patching works as expected.
-const size_t kMinServiceSize = offsetof(ServiceEntryWow64, ret);
-// Maximum size of the entry, was the size of the Windows Vista WoW64 entry.
-// Keep this fixed for compatibility reasons.
-const size_t kMaxServiceSize = 24;
-static_assert(sizeof(ServiceEntry32) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntry32) < kMaxServiceSize,
-              "wrong maximum service length");
-static_assert(sizeof(ServiceEntryWow64) >= kMinServiceSize,
-              "wrong minimum service length");
-static_assert(sizeof(ServiceEntryWow64) < kMaxServiceSize,
-              "wrong maximum service length");
+const size_t kMinServiceSize = offsetof(ServiceEntry, ret);
+static_assert(sizeof(ServiceEntryW8) >= kMinServiceSize,
+              "wrong service length");
+static_assert(sizeof(Wow64Entry) >= kMinServiceSize, "wrong service length");
+static_assert(sizeof(Wow64EntryW8) >= kMinServiceSize, "wrong service length");
 
 struct ServiceFullThunk {
   union {
-    ServiceEntryWow64 original;
-    // Pad the entry to the maximum size.
-    char dummy[kMaxServiceSize];
+    ServiceEntry original;
+    ServiceEntryW8 original_w8;
+    Wow64Entry wow_64;
+    Wow64EntryW8 wow_64_w8;
   };
   int internal_thunk;  // Dummy member to the beginning of the internal thunk.
 };
 
 #pragma pack(pop)
 
-bool IsWow64Process() {
-  // We don't need to use IsWow64Process2 as this returns the expected result
-  // when running in the ARM64 x86 emulator.
-  BOOL is_wow64 = FALSE;
-  return ::IsWow64Process(::GetCurrentProcess(), &is_wow64) && is_wow64;
-}
-
-bool IsFunctionAService32(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntry32 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
-      function_code.call_offset != 3 || kRet != function_code.ret_p ||
-      kMovEdxEsp != function_code.mov_edx_esp ||
-      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-
-  return true;
-}
-
-bool IsFunctionAServiceWow64(HANDLE process, void* target, void* local_thunk) {
-  ServiceEntryWow64 function_code;
-  SIZE_T read;
-  if (!::ReadProcessMemory(process, target, &function_code,
-                           sizeof(function_code), &read)) {
-    return false;
-  }
-
-  if (sizeof(function_code) != read)
-    return false;
-
-  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
-      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
-    return false;
-  }
-
-  // Save the verified code
-  memcpy(local_thunk, &function_code, sizeof(function_code));
-  return true;
-}
-
 }  // namespace
 
 namespace sandbox {
@@ -212,14 +227,69 @@ NTSTATUS ServiceResolverThunk::CopyThunk(const void* target_module,
 }
 
 bool ServiceResolverThunk::IsFunctionAService(void* local_thunk) const {
-  static bool is_wow64 = IsWow64Process();
-  return is_wow64 ? IsFunctionAServiceWow64(process_, target_, local_thunk)
-                  : IsFunctionAService32(process_, target_, local_thunk);
+  ServiceEntry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      (kCallPtrEdx != function_code.call_ptr_edx &&
+       kCallEdx != function_code.call_ptr_edx) ||
+      kRet != function_code.ret) {
+    return false;
+  }
+
+  // Find the system call pointer if we don't already have it.
+  if (kCallEdx != function_code.call_ptr_edx) {
+    DWORD ki_system_call;
+    if (!::ReadProcessMemory(process_,
+                             base::bit_cast<const void*>(function_code.stub),
+                             &ki_system_call, sizeof(ki_system_call), &read)) {
+      return false;
+    }
+
+    if (sizeof(ki_system_call) != read)
+      return false;
+
+    HMODULE module_1, module_2;
+    // last check, call_stub should point to a KiXXSystemCall function on ntdll
+    if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                               GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                           base::bit_cast<const wchar_t*>(ki_system_call),
+                           &module_1)) {
+      return false;
+    }
+
+    if (ntdll_base_) {
+      // This path is only taken when running the unit tests. We want to be
+      // able to patch a buffer in memory, so target_ is not inside ntdll.
+      module_2 = ntdll_base_;
+    } else {
+      if (!GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS |
+                                 GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
+                             reinterpret_cast<const wchar_t*>(target_),
+                             &module_2))
+        return false;
+    }
+
+    if (module_1 != module_2)
+      return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
 }
 
 NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
                                             void* remote_thunk) {
-  ServiceEntryWow64 intercepted_code;
+  ServiceEntry intercepted_code;
   size_t bytes_to_write = sizeof(intercepted_code);
   ServiceFullThunk* full_local_thunk =
       reinterpret_cast<ServiceFullThunk*>(local_thunk);
@@ -232,15 +302,15 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   intercepted_code.mov_eax = kMovEax;
   intercepted_code.service_id = full_local_thunk->original.service_id;
   intercepted_code.mov_edx = kMovEdx;
-  intercepted_code.mov_edx_param =
+  intercepted_code.stub =
       base::bit_cast<ULONG>(&full_remote_thunk->internal_thunk);
-  intercepted_code.call_edx = kJmpEdx;
+  intercepted_code.call_ptr_edx = kJmpEdx;
   bytes_to_write = kMinServiceSize;
 
   if (relative_jump_) {
     intercepted_code.mov_eax = kJmp32;
     intercepted_code.service_id = relative_jump_;
-    bytes_to_write = offsetof(ServiceEntryWow64, mov_edx);
+    bytes_to_write = offsetof(ServiceEntry, mov_edx);
   }
 
   // setup the thunk
@@ -276,7 +346,7 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
 
 bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
                                                 void* remote_thunk) {
-  ServiceEntryWow64 function_code;
+  ServiceEntry function_code;
   SIZE_T read;
   if (!::ReadProcessMemory(process_, target_, &function_code,
                            sizeof(function_code), &read)) {
@@ -312,18 +382,100 @@ bool ServiceResolverThunk::SaveOriginalFunction(void* local_thunk,
   return true;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(
-    void* thunk_storage) const {
-  const size_t kJmp32Size = 5;
-  ServiceEntryWow64* patched = static_cast<ServiceEntryWow64*>(target_);
-  if (kJmp32 != patched->mov_eax) {
+bool Wow64ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64Entry function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kXorEcx != function_code.xor_ecx ||
+      kLeaEdx != function_code.lea_edx || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3) {
+    return false;
+  }
+
+  if ((kAddEsp1 == function_code.add_esp1 &&
+       kAddEsp2 == function_code.add_esp2 && kRet == function_code.ret) ||
+      kRet == function_code.add_esp1) {
+    // Save the verified code
+    memcpy(local_thunk, &function_code, sizeof(function_code));
+    return true;
+  }
+
+  return false;
+}
+
+bool Wow64W8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
     return false;
   }
 
-  ULONG source_addr = base::bit_cast<ULONG>(target_);
-  ULONG target_addr = base::bit_cast<ULONG>(thunk_storage);
-  return target_addr + kMaxServiceSize - kJmp32Size - source_addr ==
-         patched->service_id;
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallFs1 != function_code.call_fs1 ||
+      kCallFs2 != function_code.call_fs2 ||
+      kCallFs3 != function_code.call_fs3 || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
+}
+
+bool Win8ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  ServiceEntryW8 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kCallEip != function_code.call_eip ||
+      function_code.call_offset != 3 || kRet != function_code.ret_p ||
+      kMovEdxEsp != function_code.mov_edx_esp ||
+      kSysenter != function_code.sysenter || kRet2 != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+
+  return true;
+}
+
+bool Wow64W10ResolverThunk::IsFunctionAService(void* local_thunk) const {
+  Wow64EntryW10 function_code;
+  SIZE_T read;
+  if (!::ReadProcessMemory(process_, target_, &function_code,
+                           sizeof(function_code), &read)) {
+    return false;
+  }
+
+  if (sizeof(function_code) != read)
+    return false;
+
+  if (kMovEax != function_code.mov_eax || kMovEdx != function_code.mov_edx ||
+      kCallEdx != function_code.call_edx || kRet != function_code.ret) {
+    return false;
+  }
+
+  // Save the verified code
+  memcpy(local_thunk, &function_code, sizeof(function_code));
+  return true;
 }
 
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_64.cc b/sandbox/win/src/service_resolver_64.cc
index 33b91d04ad114..38e451da143a3 100644
--- a/sandbox/win/src/service_resolver_64.cc
+++ b/sandbox/win/src/service_resolver_64.cc
@@ -282,8 +282,4 @@ NTSTATUS ServiceResolverThunk::PerformPatch(void* local_thunk,
   return STATUS_SUCCESS;
 }
 
-bool ServiceResolverThunk::VerifyJumpTargetForTesting(void*) const {
-  return true;
-}
-
 }  // namespace sandbox
diff --git a/sandbox/win/src/service_resolver_unittest.cc b/sandbox/win/src/service_resolver_unittest.cc
index aa05e37c0c0e0..01d0fee18b17d 100644
--- a/sandbox/win/src/service_resolver_unittest.cc
+++ b/sandbox/win/src/service_resolver_unittest.cc
@@ -13,53 +13,98 @@
 
 #include "base/bit_cast.h"
 #include "base/memory/raw_ptr.h"
-#include "sandbox/win/src/nt_internals.h"
+#include "base/win/windows_version.h"
 #include "sandbox/win/src/resolver.h"
 #include "testing/gtest/include/gtest/gtest.h"
 
 namespace {
 
+class ResolverThunkTest {
+ public:
+  virtual ~ResolverThunkTest() {}
+
+  virtual sandbox::ServiceResolverThunk* resolver() = 0;
+
+  // Sets the interception target to the desired address.
+  void set_target(void* target) { fake_target_ = target; }
+
+ protected:
+  // Holds the address of the fake target.
+  raw_ptr<void> fake_target_;
+};
+
 // This is the concrete resolver used to perform service-call type functions
 // inside ntdll.dll.
-class ServiceResolverTest : public sandbox::ServiceResolverThunk {
+template <typename T>
+class ResolverThunkTestImpl : public T, public ResolverThunkTest {
  public:
   // The service resolver needs a child process to write to.
-  explicit ServiceResolverTest(bool relaxed)
-      : sandbox::ServiceResolverThunk(::GetCurrentProcess(), relaxed) {}
+  explicit ResolverThunkTestImpl(bool relaxed)
+      : T(::GetCurrentProcess(), relaxed) {}
 
-  ServiceResolverTest(const ServiceResolverTest&) = delete;
-  ServiceResolverTest& operator=(const ServiceResolverTest&) = delete;
+  ResolverThunkTestImpl(const ResolverThunkTestImpl&) = delete;
+  ResolverThunkTestImpl& operator=(const ResolverThunkTestImpl&) = delete;
 
-  // Sets the interception target to the desired address.
-  void set_target(void* target) { fake_target_ = target; }
+  sandbox::ServiceResolverThunk* resolver() { return this; }
 
  protected:
   // Overrides Resolver::Init
-  NTSTATUS Init(const void* target_module,
-                const void* interceptor_module,
-                const char* target_name,
-                const char* interceptor_name,
-                const void* interceptor_entry_point,
-                void* thunk_storage,
-                size_t storage_bytes) final {
+  virtual NTSTATUS Init(const void* target_module,
+                        const void* interceptor_module,
+                        const char* target_name,
+                        const char* interceptor_name,
+                        const void* interceptor_entry_point,
+                        void* thunk_storage,
+                        size_t storage_bytes) {
     NTSTATUS ret = STATUS_SUCCESS;
-    ret = sandbox::ServiceResolverThunk::Init(
-        target_module, interceptor_module, target_name, interceptor_name,
-        interceptor_entry_point, thunk_storage, storage_bytes);
+    ret = T::Init(target_module, interceptor_module, target_name,
+                  interceptor_name, interceptor_entry_point, thunk_storage,
+                  storage_bytes);
     EXPECT_EQ(STATUS_SUCCESS, ret);
 
     this->target_ = fake_target_;
 
     return ret;
   }
-
-  // Holds the address of the fake target.
-  raw_ptr<void> fake_target_;
 };
 
+typedef ResolverThunkTestImpl<sandbox::ServiceResolverThunk> WinXpResolverTest;
+
+#if !defined(_WIN64)
+typedef ResolverThunkTestImpl<sandbox::Win8ResolverThunk> Win8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64ResolverThunk> Wow64ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W8ResolverThunk>
+    Wow64W8ResolverTest;
+typedef ResolverThunkTestImpl<sandbox::Wow64W10ResolverThunk>
+    Wow64W10ResolverTest;
+#endif
+
+const BYTE kJump32 = 0xE9;
+
+void CheckJump(void* source, void* target) {
+#pragma pack(push)
+#pragma pack(1)
+  struct Code {
+    BYTE jump;
+    ULONG delta;
+  };
+#pragma pack(pop)
+
+#if defined(_WIN64)
+  FAIL() << "Running 32-bit codepath";
+#else
+  Code* patched = reinterpret_cast<Code*>(source);
+  EXPECT_EQ(kJump32, patched->jump);
+
+  ULONG source_addr = base::bit_cast<ULONG>(source);
+  ULONG target_addr = base::bit_cast<ULONG>(target);
+  EXPECT_EQ(target_addr + 19 - source_addr, patched->delta);
+#endif
+}
+
 NTSTATUS PatchNtdllWithResolver(const char* function,
                                 bool relaxed,
-                                ServiceResolverTest& resolver) {
+                                ResolverThunkTest* thunk_test) {
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   EXPECT_TRUE(ntdll_base);
 
@@ -72,20 +117,21 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
   BYTE service[50];
   memcpy(service, target, sizeof(service));
 
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
-  resolver.AllowLocalPatches();
+  resolver->AllowLocalPatches();
 
-  NTSTATUS ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                                function_entry, thunk.get(), thunk_size, &used);
+  NTSTATUS ret =
+      resolver->Setup(ntdll_base, nullptr, function, nullptr, function_entry,
+                      thunk.get(), thunk_size, &used);
   if (NT_SUCCESS(ret)) {
-    const BYTE kJump32 = 0xE9;
     EXPECT_EQ(thunk_size, used);
     EXPECT_NE(0, memcmp(service, target, sizeof(service)));
     EXPECT_NE(kJump32, service[0]);
@@ -93,18 +139,30 @@ NTSTATUS PatchNtdllWithResolver(const char* function,
     if (relaxed) {
       // It's already patched, let's patch again, and simulate a direct patch.
       service[0] = kJump32;
-      ret = resolver.Setup(ntdll_base, nullptr, function, nullptr,
-                           function_entry, thunk.get(), thunk_size, &used);
-      EXPECT_TRUE(resolver.VerifyJumpTargetForTesting(thunk.get()));
+      ret = resolver->Setup(ntdll_base, nullptr, function, nullptr,
+                            function_entry, thunk.get(), thunk_size, &used);
+      CheckJump(service, thunk.get());
     }
   }
 
   return ret;
 }
 
+std::unique_ptr<ResolverThunkTest> GetTestResolver(bool relaxed) {
+#if defined(_WIN64)
+  return std::make_unique<WinXpResolverTest>(relaxed);
+#else
+  base::win::OSInfo* os_info = base::win::OSInfo::GetInstance();
+  if (os_info->IsWowX86OnAMD64())
+    return std::make_unique<Wow64W10ResolverTest>(relaxed);
+
+  return std::make_unique<Win8ResolverTest>(relaxed);
+#endif
+}
+
 NTSTATUS PatchNtdll(const char* function, bool relaxed) {
-  ServiceResolverTest resolver(relaxed);
-  return PatchNtdllWithResolver(function, relaxed, resolver);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(relaxed);
+  return PatchNtdllWithResolver(function, relaxed, thunk_test.get());
 }
 
 TEST(ServiceResolverTest, PatchesServices) {
@@ -155,26 +213,26 @@ TEST(ServiceResolverTest, PatchesPatchedServices) {
 TEST(ServiceResolverTest, MultiplePatchedServices) {
 // We don't support "relaxed mode" for Win64 apps.
 #if !defined(_WIN64)
-  ServiceResolverTest thunk_test(true);
-  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
+  NTSTATUS ret = PatchNtdllWithResolver("NtClose", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret) << "NtClose, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateFile", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateFile, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtCreateMutant", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtCreateMutant, last error: " << ::GetLastError();
 
-  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test);
+  ret = PatchNtdllWithResolver("NtMapViewOfSection", true, thunk_test.get());
   EXPECT_EQ(STATUS_SUCCESS, ret)
       << "NtMapViewOfSection, last error: " << ::GetLastError();
 #endif
 }
 
 TEST(ServiceResolverTest, LocalPatchesAllowed) {
-  ServiceResolverTest resolver(true);
+  std::unique_ptr<ResolverThunkTest> thunk_test = GetTestResolver(true);
 
   HMODULE ntdll_base = ::GetModuleHandle(L"ntdll.dll");
   ASSERT_TRUE(ntdll_base);
@@ -187,25 +245,26 @@ TEST(ServiceResolverTest, LocalPatchesAllowed) {
 
   BYTE service[50];
   memcpy(service, target, sizeof(service));
-  resolver.set_target(service);
+  thunk_test->set_target(service);
 
+  sandbox::ServiceResolverThunk* resolver = thunk_test->resolver();
   // Any pointer will do as an interception_entry_point
-  void* function_entry = &resolver;
-  size_t thunk_size = resolver.GetThunkSize();
-  std::unique_ptr<char[]> thunk = std::make_unique<char[]>(thunk_size);
+  void* function_entry = resolver;
+  size_t thunk_size = resolver->GetThunkSize();
+  std::unique_ptr<char[]> thunk(new char[thunk_size]);
   size_t used;
 
   NTSTATUS ret = STATUS_UNSUCCESSFUL;
 
   // First try patching without having allowed local patches.
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_FALSE(NT_SUCCESS(ret));
 
   // Now allow local patches and check that things work.
-  resolver.AllowLocalPatches();
-  ret = resolver.Setup(ntdll_base, nullptr, kFunctionName, nullptr,
-                       function_entry, thunk.get(), thunk_size, &used);
+  resolver->AllowLocalPatches();
+  ret = resolver->Setup(ntdll_base, nullptr, kFunctionName, nullptr,
+                        function_entry, thunk.get(), thunk_size, &used);
   EXPECT_EQ(STATUS_SUCCESS, ret);
 }
 
diff --git a/sandbox/win/src/startup_information_helper.cc b/sandbox/win/src/startup_information_helper.cc
index b7688c6b74d9c..dab303f872b1e 100644
--- a/sandbox/win/src/startup_information_helper.cc
+++ b/sandbox/win/src/startup_information_helper.cc
@@ -115,6 +115,8 @@ bool StartupInformationHelper::BuildStartupInformation() {
   if (!startup_info_.InitializeProcThreadAttributeList(expected_attributes))
     return false;
 
+  if (base::win::GetVersion() >= base::win::Version::WIN7) {
+
   if (mitigations_[0] || mitigations_[1]) {
     if (!startup_info_.UpdateProcThreadAttribute(
             PROC_THREAD_ATTRIBUTE_MITIGATION_POLICY, &mitigations_[0],
@@ -133,7 +135,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
     }
     expected_attributes--;
   }
-
+  }
   if (restrict_child_process_creation_) {
     child_process_creation_ = PROCESS_CREATION_CHILD_PROCESS_RESTRICTED;
     if (!startup_info_.UpdateProcThreadAttribute(
@@ -159,7 +161,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
     inherit_handles_ = true;
     expected_attributes--;
   }
-
+  if (base::win::GetVersion() >= base::win::Version::WIN7) {
   if (!job_handle_list_.empty()) {
     if (!startup_info_.UpdateProcThreadAttribute(
             PROC_THREAD_ATTRIBUTE_JOB_LIST, &job_handle_list_[0],
@@ -191,6 +193,7 @@ bool StartupInformationHelper::BuildStartupInformation() {
   }
 
   CHECK(expected_attributes == 0);
+  }
   return true;
 }
 
diff --git a/sandbox/win/src/win_utils.cc b/sandbox/win/src/win_utils.cc
index afdddac091985..35c9cf95fb772 100644
--- a/sandbox/win/src/win_utils.cc
+++ b/sandbox/win/src/win_utils.cc
@@ -570,6 +570,36 @@ absl::optional<ProcessHandleMap> GetCurrentProcessHandles() {
   return handle_map;
 }
 
+absl::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7() {
+  DWORD handle_count = UINT_MAX;
+  const int kInvalidHandleThreshold = 100;
+  const size_t kHandleOffset = 4;  // Handles are always a multiple of 4.
+
+  if (!::GetProcessHandleCount(::GetCurrentProcess(), &handle_count))
+    return absl::nullopt;
+  ProcessHandleMap handle_map;
+
+  uint32_t handle_value = 0;
+  int invalid_count = 0;
+
+  // Keep incrementing until we hit the number of handles reported by
+  // GetProcessHandleCount(). If we hit a very long sequence of invalid
+  // handles we assume that we've run past the end of the table.
+  while (handle_count && invalid_count < kInvalidHandleThreshold) {
+    handle_value += kHandleOffset;
+    HANDLE handle = base::win::Uint32ToHandle(handle_value);
+    auto type_name = GetTypeNameFromHandle(handle);
+    if (!type_name) {
+      ++invalid_count;
+      continue;
+    }
+
+    --handle_count;
+    handle_map[type_name.value()].push_back(handle);
+  }
+  return handle_map;
+}
+
 }  // namespace sandbox
 
 void ResolveNTFunctionPtr(const char* name, void* ptr) {
diff --git a/sandbox/win/src/win_utils.h b/sandbox/win/src/win_utils.h
index e416d6cda9979..7f199feb9d8c1 100644
--- a/sandbox/win/src/win_utils.h
+++ b/sandbox/win/src/win_utils.h
@@ -115,6 +115,12 @@ void* GetProcessBaseAddress(HANDLE process);
 // use them.
 absl::optional<ProcessHandleMap> GetCurrentProcessHandles();
 
+// Fallback function for GetCurrentProcessHandles. Should only be needed on
+// Windows 7 which doesn't support the API to query all process handles. This
+// uses a brute force method to get the process handles.
+absl::optional<ProcessHandleMap> GetCurrentProcessHandlesWin7();
+
+
 }  // namespace sandbox
 
 // Resolves a function name in NTDLL to a function pointer. The second parameter
diff --git a/services/device/geolocation/win/location_provider_winrt.cc b/services/device/geolocation/win/location_provider_winrt.cc
index 2c2b868a5294a..86e517a332692 100644
--- a/services/device/geolocation/win/location_provider_winrt.cc
+++ b/services/device/geolocation/win/location_provider_winrt.cc
@@ -70,6 +70,11 @@ void RecordUmaEvent(WindowsRTLocationRequestEvent event) {
   base::UmaHistogramEnumeration("Windows.RT.LocationRequest.Event", event);
 }
 
+bool IsWinRTSupported() {
+  return base::win::ResolveCoreWinRTDelayload() &&
+         base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+}
+
 template <typename F>
 absl::optional<DOUBLE> GetOptionalDouble(F&& getter) {
   DOUBLE value = 0;
@@ -506,6 +511,7 @@ std::unique_ptr<LocationProvider> NewSystemLocationProvider(
     GeolocationManager* geolocation_manager) {
   if (!base::FeatureList::IsEnabled(
           features::kWinrtGeolocationImplementation) ||
+	!IsWinRTSupported() ||
       !IsSystemLocationSettingEnabled()) {
     return nullptr;
   }
diff --git a/services/proxy_resolver_win/BUILD.gn b/services/proxy_resolver_win/BUILD.gn
index ed4b004f06350..c3fa7ec452180 100644
--- a/services/proxy_resolver_win/BUILD.gn
+++ b/services/proxy_resolver_win/BUILD.gn
@@ -11,6 +11,8 @@ component("proxy_resolver_win") {
     "winhttp_api_wrapper.h",
     "winhttp_api_wrapper_impl.cc",
     "winhttp_api_wrapper_impl.h",
+    "winhttp_proxy_resolver_functions.cc",
+    "winhttp_proxy_resolver_functions.h",
   ]
 
   libs = [ "winhttp.lib" ]
diff --git a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
index 68801e4636cab..e22cdfbb1fa0e 100644
--- a/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
+++ b/services/proxy_resolver_win/public/cpp/proxy_resolver_win_mojom_traits.cc
@@ -15,6 +15,8 @@ EnumTraits<proxy_resolver_win::mojom::WinHttpStatus,
       return proxy_resolver_win::mojom::WinHttpStatus::kOk;
     case net::WinHttpStatus::kAborted:
       return proxy_resolver_win::mojom::WinHttpStatus::kAborted;
+   case net::WinHttpStatus::kFunctionsNotLoaded:
+      return proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded;
     case net::WinHttpStatus::kWinHttpOpenFailed:
       return proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed;
     case net::WinHttpStatus::kWinHttpSetTimeoutsFailed:
@@ -55,6 +57,9 @@ bool EnumTraits<proxy_resolver_win::mojom::WinHttpStatus, net::WinHttpStatus>::
     case proxy_resolver_win::mojom::WinHttpStatus::kAborted:
       *output = net::WinHttpStatus::kAborted;
       return true;
+    case proxy_resolver_win::mojom::WinHttpStatus::kFunctionsNotLoaded:
+      *output = net::WinHttpStatus::kFunctionsNotLoaded;
+      return true;
     case proxy_resolver_win::mojom::WinHttpStatus::kWinHttpOpenFailed:
       *output = net::WinHttpStatus::kWinHttpOpenFailed;
       return true;
diff --git a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
index c05d1f63d7d9b..ff3447e285e46 100644
--- a/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
+++ b/services/proxy_resolver_win/public/mojom/proxy_resolver_win.mojom
@@ -12,6 +12,7 @@ import "url/mojom/url.mojom";
 enum WinHttpStatus {
   kOk,
   kAborted,
+  kFunctionsNotLoaded,
   kWinHttpOpenFailed,
   kWinHttpSetTimeoutsFailed,
   kWinHttpSetStatusCallbackFailed,
diff --git a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
index 54baece710f7a..78e4538bd2ded 100644
--- a/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
+++ b/services/proxy_resolver_win/winhttp_api_wrapper_impl.cc
@@ -9,6 +9,7 @@
 #include <utility>
 
 #include "base/check_op.h"
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
 
 namespace proxy_resolver_win {
 
@@ -34,9 +35,9 @@ WinHttpAPIWrapperImpl::~WinHttpAPIWrapperImpl() {
 
 bool WinHttpAPIWrapperImpl::CallWinHttpOpen() {
   DCHECK_EQ(nullptr, session_handle_);
-  session_handle_ = ::WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY,
-                                  WINHTTP_NO_PROXY_NAME,
-                                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
+  session_handle_ =
+      WinHttpOpen(nullptr, WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME,
+                  WINHTTP_NO_PROXY_BYPASS, WINHTTP_FLAG_ASYNC);
   return (session_handle_ != nullptr);
 }
 
@@ -45,16 +46,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetTimeouts(int resolve_timeout,
                                                    int send_timeout,
                                                    int receive_timeout) {
   DCHECK_NE(nullptr, session_handle_);
-  return (!!::WinHttpSetTimeouts(session_handle_, resolve_timeout,
-                                 connect_timeout, send_timeout,
-                                 receive_timeout));
+  return (!!WinHttpSetTimeouts(session_handle_, resolve_timeout,
+                               connect_timeout, send_timeout, receive_timeout));
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
     WINHTTP_STATUS_CALLBACK internet_callback) {
   DCHECK_NE(nullptr, session_handle_);
   const WINHTTP_STATUS_CALLBACK winhttp_status_callback =
-      ::WinHttpSetStatusCallback(
+      WinHttpSetStatusCallback(
           session_handle_, internet_callback,
           WINHTTP_CALLBACK_FLAG_REQUEST_ERROR |
               WINHTTP_CALLBACK_FLAG_GETPROXYFORURL_COMPLETE,
@@ -64,14 +64,15 @@ bool WinHttpAPIWrapperImpl::CallWinHttpSetStatusCallback(
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetIEProxyConfigForCurrentUser(
     WINHTTP_CURRENT_USER_IE_PROXY_CONFIG* ie_proxy_config) {
-  return !!::WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
+  return !!WinHttpGetIEProxyConfigForCurrentUser(ie_proxy_config);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpCreateProxyResolver(
     HINTERNET* out_resolver_handle) {
   DCHECK_NE(nullptr, session_handle_);
   const DWORD result =
-      ::WinHttpCreateProxyResolver(session_handle_, out_resolver_handle);
+      WinHttpProxyResolverFunctions::GetInstance().create_proxy_resolver(
+          session_handle_, out_resolver_handle);
   return (result == ERROR_SUCCESS);
 }
 
@@ -83,25 +84,28 @@ bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyForUrlEx(
   const std::wstring wide_url(url.begin(), url.end());
   // TODO(https://crbug.com/1032820): Upgrade to WinHttpGetProxyForUrlEx2()
   // if there is a clear reason to do so.
-  const DWORD result = ::WinHttpGetProxyForUrlEx(
-      resolver_handle, wide_url.data(), autoproxy_options, context);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_for_url_ex(
+          resolver_handle, wide_url.data(), autoproxy_options, context);
   return (result == ERROR_IO_PENDING);
 }
 
 bool WinHttpAPIWrapperImpl::CallWinHttpGetProxyResult(
     HINTERNET resolver_handle,
     WINHTTP_PROXY_RESULT* proxy_result) {
-  const DWORD result = ::WinHttpGetProxyResult(resolver_handle, proxy_result);
+  const DWORD result =
+      WinHttpProxyResolverFunctions::GetInstance().get_proxy_result(
+          resolver_handle, proxy_result);
   return (result == ERROR_SUCCESS);
 }
 
 VOID WinHttpAPIWrapperImpl::CallWinHttpFreeProxyResult(
     WINHTTP_PROXY_RESULT* proxy_result) {
-  WinHttpFreeProxyResult(proxy_result);
+  WinHttpProxyResolverFunctions::GetInstance().free_proxy_result(proxy_result);
 }
 
 void WinHttpAPIWrapperImpl::CallWinHttpCloseHandle(HINTERNET internet_handle) {
-  ::WinHttpCloseHandle(internet_handle);
+  WinHttpCloseHandle(internet_handle);
 }
 
 void WinHttpAPIWrapperImpl::CloseSessionHandle() {
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
new file mode 100644
index 0000000000000..b00c5670bb517
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.cc
@@ -0,0 +1,43 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "services/proxy_resolver_win/winhttp_proxy_resolver_functions.h"
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+WinHttpProxyResolverFunctions::WinHttpProxyResolverFunctions() {
+  HMODULE winhttp_module =
+      LoadLibraryEx(L"winhttp.dll", nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
+  if (winhttp_module) {
+    create_proxy_resolver = reinterpret_cast<WinHttpCreateProxyResolverFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpCreateProxyResolver"));
+    get_proxy_for_url_ex = reinterpret_cast<WinHttpGetProxyForUrlExFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyForUrlEx"));
+    get_proxy_result = reinterpret_cast<WinHttpGetProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpGetProxyResult"));
+    free_proxy_result = reinterpret_cast<WinHttpFreeProxyResultFunc>(
+        ::GetProcAddress(winhttp_module, "WinHttpFreeProxyResult"));
+  }
+}
+
+// Never called due to base::NoDestructor.
+WinHttpProxyResolverFunctions::~WinHttpProxyResolverFunctions() = default;
+
+bool WinHttpProxyResolverFunctions::are_all_functions_loaded() const {
+  return create_proxy_resolver && get_proxy_for_url_ex && get_proxy_result &&
+         free_proxy_result;
+}
+
+// static
+const WinHttpProxyResolverFunctions&
+WinHttpProxyResolverFunctions::GetInstance() {
+  // This is a singleton for performance reasons. This avoids having to load
+  // proxy resolver functions multiple times.
+  static base::NoDestructor<WinHttpProxyResolverFunctions> instance;
+  return *instance;
+}
+
+}  // namespace proxy_resolver_win
\ No newline at end of file
diff --git a/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
new file mode 100644
index 0000000000000..768269019cd0e
--- /dev/null
+++ b/services/proxy_resolver_win/winhttp_proxy_resolver_functions.h
@@ -0,0 +1,47 @@
+// Copyright 2020 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+#define SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
+
+#include <windows.h>
+#include <winhttp.h>
+
+#include "base/no_destructor.h"
+
+namespace proxy_resolver_win {
+
+// Not all WinHttp APIs we'll be using exist in all versions of Windows.
+// Several only exist in Windows 8+. Thus, each function entry point must be
+// loaded dynamically.
+struct WinHttpProxyResolverFunctions {
+ public:
+  WinHttpProxyResolverFunctions(const WinHttpProxyResolverFunctions&) = delete;
+  WinHttpProxyResolverFunctions& operator=(
+      const WinHttpProxyResolverFunctions&) = delete;
+
+  bool are_all_functions_loaded() const;
+
+  static const WinHttpProxyResolverFunctions& GetInstance();
+
+  using WinHttpCreateProxyResolverFunc = decltype(WinHttpCreateProxyResolver)*;
+  using WinHttpGetProxyForUrlExFunc = decltype(WinHttpGetProxyForUrlEx)*;
+  using WinHttpGetProxyResultFunc = decltype(WinHttpGetProxyResult)*;
+  using WinHttpFreeProxyResultFunc = decltype(WinHttpFreeProxyResult)*;
+
+  WinHttpCreateProxyResolverFunc create_proxy_resolver = nullptr;
+  WinHttpGetProxyForUrlExFunc get_proxy_for_url_ex = nullptr;
+  WinHttpGetProxyResultFunc get_proxy_result = nullptr;
+  WinHttpFreeProxyResultFunc free_proxy_result = nullptr;
+
+ private:
+  friend class base::NoDestructor<WinHttpProxyResolverFunctions>;
+
+  WinHttpProxyResolverFunctions();
+  ~WinHttpProxyResolverFunctions();
+};
+
+}  // namespace proxy_resolver_win
+
+#endif  // SERVICES_PROXY_RESOLVER_WIN_WINHTTP_PROXY_RESOLVER_FUNCTIONS_H_
\ No newline at end of file
diff --git a/services/shape_detection/face_detection_provider_win.cc b/services/shape_detection/face_detection_provider_win.cc
index 59e9eb36d95a5..dbe49923cf948 100644
--- a/services/shape_detection/face_detection_provider_win.cc
+++ b/services/shape_detection/face_detection_provider_win.cc
@@ -49,6 +49,11 @@ BitmapPixelFormat GetPreferredPixelFormat(IFaceDetectorStatics* factory) {
 void FaceDetectionProviderWin::CreateFaceDetection(
     mojo::PendingReceiver<shape_detection::mojom::FaceDetection> receiver,
     shape_detection::mojom::FaceDetectorOptionsPtr options) {
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
   ComPtr<IFaceDetectorStatics> factory;
   HRESULT hr = GetActivationFactory<
       IFaceDetectorStatics,
diff --git a/services/shape_detection/text_detection_impl_win.cc b/services/shape_detection/text_detection_impl_win.cc
index a442dced19ad6..ca4d116a84863 100644
--- a/services/shape_detection/text_detection_impl_win.cc
+++ b/services/shape_detection/text_detection_impl_win.cc
@@ -42,6 +42,13 @@ using Microsoft::WRL::ComPtr;
 // static
 void TextDetectionImpl::Create(
     mojo::PendingReceiver<mojom::TextDetection> receiver) {
+
+if (!(base::win::ResolveCoreWinRTDelayload() &&
+        ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return;
+  }
+
   // Text Detection specification only supports Latin-1 text as documented in
   // https://wicg.github.io/shape-detection-api/text.html#text-detection-api.
   // TODO(junwei.fu): https://crbug.com/794097 consider supporting other Latin
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index b5d93532e6198..916749554634c 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -464,6 +464,7 @@ component("skia") {
   if (is_win) {
     # See SK_TYPEFACE_FACTORY_DIRECTWRITE
     sources += [
+      "//third_party/skia/src/ports/SkFontHost_win.cpp",
       "//third_party/skia/src/ports/SkFontMgr_win_dw.cpp",
       "//third_party/skia/src/ports/SkOSFile_win.cpp",
       "//third_party/skia/src/ports/SkRemotableFontMgr_win_dw.cpp",
diff --git a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
index a66ddcf4d9031..c6ddb5b7e6061 100644
--- a/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
+++ b/third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom
@@ -20,6 +20,13 @@ struct DWriteFontStyle {
   uint8 font_stretch;
 };
 
+struct FallbackFamilyAndStyle {
+  string fallback_family_name;
+  uint16 weight;
+  uint8 width;
+  uint8 slant;
+};
+
 struct MapCharactersResult {
   uint32 family_index;
   mojo_base.mojom.String16 family_name;
@@ -28,6 +35,11 @@ struct MapCharactersResult {
   DWriteFontStyle font_style;
 };
 
+enum UniqueFontLookupMode {
+    kRetrieveTable,
+    kSingleLookups
+};
+
 interface DWriteFontProxy {
   // Locates the index of the specified font family within the system
   // collection.
@@ -51,14 +63,47 @@ interface DWriteFontProxy {
   GetFontFileHandles(uint32 family_index)
      => (array<mojo_base.mojom.ReadOnlyFile> file_handles);
 
-  // Matches a unique PostScript or full font name against the installed fonts
-  // using DirectWrite API. Returns a pre-opened file handle and ttc_index from
-  // which the unique font can be instantiated. Returns null handle and 0 ttc
-  // index if no font is found.
+  // Returns which font unique name matching lookup mode is to be used on the
+  // current machine. On DirectWrite 10 and above, single lookups can be
+  // performed directly against DirectWrite API. On older DirectWrite (Windows
+  // 7-8.1), unique font lookups need to be performed against a shared memory
+  // region which contains the lookup table. Compare GetUniqueFontLookupTable()
+  // for lookup mode kRetrieveTable and MatchUniqueFont for
+  // lookup mode kSingleLookups.
+  [Sync]
+  GetUniqueFontLookupMode() => (UniqueFontLookupMode lookup_mode);
+
+  // On supported Windows versions, matches a unique PostScript or full font
+  // name against the installed fonts using DirectWrite API. Returns a
+  // pre-opened file handle and ttc_index from which the unique font can be
+  // instantiated.  Check which mode is supported using
+  // GetFontUniqueNameLookupMode().  Returns null handle and 0 ttc index
+  // if no font is found. Must not be called if GetUniqueFontLookupMode()
+  // returned kRetrieveTable.
   [Sync]
   MatchUniqueFont(mojo_base.mojom.String16 font_unique_name)
       => (mojo_base.mojom.ReadOnlyFile? file_handle, uint32 ttc_index);
 
+  // Synchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion if it is available
+  // immediately without any blocking operations. Use FontTableMatcher to
+  // perform searches in it. If it is not available without blocking operations,
+  // sync_available is false and no shared memory region is provided.
+  [Sync]
+  GetUniqueNameLookupTableIfAvailable()
+      => (bool sync_available,
+          mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
+  // Asynchronously returns a protobuf structured lookup list of
+  // (full_font_name|postscript_name) => (font_file + ttc_index) to the
+  // renderer process as a ReadOnlySharedMemoryRegion. The lookup list is built
+  // on the first renderer call to retrieving this list. Use FontTableMatcher
+  // to perform searches in it. Retrieval may take up to several seconds if the
+  // table needs rebuilding on browser side.
+  GetUniqueNameLookupTable() =>
+  (mojo_base.mojom.ReadOnlySharedMemoryRegion? font_lookup_table);
+
   // Locates a font family that is able to render the specified text using the
   // specified style. If successful, the family_index and family_name will
   // indicate which family in the system font collection can render the
@@ -73,4 +118,18 @@ interface DWriteFontProxy {
                 uint32 reading_direction,
                 mojo_base.mojom.String16 base_family_name)
       => (MapCharactersResult out);
+
+  // For a given base family name, bcp47 language tag, and codepoint to look up,
+  // return a font family name that is available on the system to display the
+  // given codepoint. This internally calls Skia's
+  // SkFontMgr_DirectWrite::matchFamilyStyleCharacter which executes
+  // IDWriteTextLayout based fallback code, which cannot be run in the renderer
+  // due triggering loading the DWrite system font collection.
+  // Use only on Windows 8.0 and earlier - otherwise better fallback API is
+  // available through using a proxies IDWriteFontFallback.
+  [Sync]
+  FallbackFamilyAndStyleForCodepoint(string base_family_name,
+                                     string bcp47_language_tag,
+                                     uint32 codepoint)
+      => (FallbackFamilyAndStyle fallback_result);
 };
diff --git a/third_party/blink/public/web/win/web_font_rendering.h b/third_party/blink/public/web/win/web_font_rendering.h
index 851b6c95d0c69..1c3135b59201f 100644
--- a/third_party/blink/public/web/win/web_font_rendering.h
+++ b/third_party/blink/public/web/win/web_font_rendering.h
@@ -18,6 +18,7 @@ class WebFontRenderingClient;
 
 class BLINK_EXPORT WebFontRendering {
  public:
+  static void setUseDirectWrite(bool);
   static void SetSkiaFontManager(sk_sp<SkFontMgr>);
   // Set an instance of |WebFontPrewarmer|. The instance must be kept alive
   // until the process exits.
@@ -34,6 +35,7 @@ class BLINK_EXPORT WebFontRendering {
                                    int32_t font_height);
   static void SetAntialiasedTextEnabled(bool);
   static void SetLCDTextEnabled(bool);
+  static void SetUseSkiaFontFallback(bool);
 };
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
index 178b04c75c258..de8cc3fcdc8ed 100644
--- a/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
+++ b/third_party/blink/renderer/core/layout/web_font_rendering_win.cc
@@ -9,6 +9,12 @@
 
 namespace blink {
 
+// static
+void WebFontRendering::setUseDirectWrite(bool useDirectWrite)
+{
+    FontCache::setUseDirectWrite(useDirectWrite);
+}
+
 // static
 void WebFontRendering::SetSkiaFontManager(sk_sp<SkFontMgr> font_mgr) {
   FontCache::SetFontManager(std::move(font_mgr));
@@ -59,4 +65,9 @@ void WebFontRendering::SetLCDTextEnabled(bool enabled) {
   FontCache::SetLCDTextEnabled(enabled);
 }
 
+// static
+void WebFontRendering::SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+  FontCache::SetUseSkiaFontFallback(use_skia_font_fallback);
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index 8c710aafbf4a0..93419e64b7e00 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1630,6 +1630,8 @@ component("platform") {
     sources += [
       "fonts/win/dwrite_font_format_support.cc",
       "fonts/win/dwrite_font_format_support.h",
+      "fonts/win/fallback_family_style_cache_win.cc",
+      "fonts/win/fallback_family_style_cache_win.h",
       "fonts/win/font_cache_skia_win.cc",
       "fonts/win/font_fallback_win.cc",
       "fonts/win/font_fallback_win.h",
@@ -2215,7 +2217,10 @@ source_set("blink_platform_unittests_sources") {
   if (is_android) {
     sources += [ "fonts/android/font_cache_android_test.cc" ]
   } else if (is_win) {
-    sources += [ "text/locale_win_test.cc" ]
+    sources += [
+      "fonts/win/fallback_lru_cache_win_test.cc",
+      "text/locale_win_test.cc",
+    ]
   } else if (is_mac) {
     sources += [
       "fonts/mac/font_matcher_mac_test.mm",
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.cc b/third_party/blink/renderer/platform/fonts/font_cache.cc
index 2d160f4de81ce..6ae70902e71ae 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_cache.cc
@@ -59,6 +59,7 @@
 #include "ui/gfx/font_list.h"
 
 #if BUILDFLAG(IS_WIN)
+#include <Windows.h>
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 #endif
 
@@ -77,8 +78,10 @@ float FontCache::device_scale_factor_ = 1.0;
 #endif
 
 #if BUILDFLAG(IS_WIN)
+bool FontCache::s_useDirectWrite = false;
 bool FontCache::antialiased_text_enabled_ = false;
 bool FontCache::lcd_text_enabled_ = false;
+bool FontCache::use_skia_font_fallback_ = false;
 static bool should_use_test_font_mgr = false;
 #endif  // BUILDFLAG(IS_WIN)
 
@@ -91,11 +94,15 @@ FontCache::FontCache()
       font_platform_data_cache_(FontPlatformDataCache::Create()),
       font_data_cache_(FontDataCache::Create()) {
 #if BUILDFLAG(IS_WIN)
+  if(!s_useDirectWrite) {
+	  font_manager_ = SkFontMgr_New_GDI();
+  }
+
   if (!font_manager_ || should_use_test_font_mgr) {
     // This code path is only for unit tests. This SkFontMgr does not work in
     // sandboxed environments, but injecting this initialization code to all
     // unit tests isn't easy.
-    font_manager_ = SkFontMgr_New_DirectWrite();
+		font_manager_ = SkFontMgr_New_DirectWrite();
     // Set |is_test_font_mgr_| to capture if this is not happening in the
     // production code. crbug.com/561873
     is_test_font_mgr_ = true;
diff --git a/third_party/blink/renderer/platform/fonts/font_cache.h b/third_party/blink/renderer/platform/fonts/font_cache.h
index ae5cee24b4c49..7da0d5c0da219 100644
--- a/third_party/blink/renderer/platform/fonts/font_cache.h
+++ b/third_party/blink/renderer/platform/fonts/font_cache.h
@@ -38,6 +38,7 @@
 #include "base/gtest_prod_util.h"
 #include "base/memory/scoped_refptr.h"
 #include "build/build_config.h"
+#include "mojo/public/cpp/bindings/remote.h"
 #include "third_party/blink/renderer/platform/fonts/fallback_list_composite_key.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache_client.h"
 #include "third_party/blink/renderer/platform/fonts/font_data_cache.h"
@@ -60,6 +61,11 @@
 #include "ui/gfx/font_fallback_linux.h"
 #endif
 
+#if BUILDFLAG(IS_WIN)
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+#endif
+
 class SkString;
 class SkTypeface;
 
@@ -197,8 +203,10 @@ class PLATFORM_EXPORT FontCache final {
 #if BUILDFLAG(IS_WIN)
   // TODO(https://crbug.com/808221) System font style configuration is not
   // related to FontCache. Move it somewhere else, e.g. to WebThemeEngine.
+  static bool useDirectWrite() { return s_useDirectWrite; }
   static bool AntialiasedTextEnabled() { return antialiased_text_enabled_; }
   static bool LcdTextEnabled() { return lcd_text_enabled_; }
+  static void setUseDirectWrite(bool useDirectWrite) { s_useDirectWrite = useDirectWrite; }
   static void SetAntialiasedTextEnabled(bool enabled) {
     antialiased_text_enabled_ = enabled;
   }
@@ -222,6 +230,13 @@ class PLATFORM_EXPORT FontCache final {
   static const AtomicString& StatusFontFamily() {
     return *status_font_family_name_;
   }
+  static void SetUseSkiaFontFallback(bool use_skia_font_fallback) {
+    use_skia_font_fallback_ = use_skia_font_fallback;
+  }
+
+  // On Windows pre 8.1 establish a connection to the DWriteFontProxy service in
+  // order to retrieve family names for fallback lookup.
+  void EnsureServiceConnected();
 
   scoped_refptr<SimpleFontData> GetFallbackFamilyNameFromHardcodedChoices(
       const FontDescription&,
@@ -352,6 +367,7 @@ class PLATFORM_EXPORT FontCache final {
   static SkFontMgr* static_font_manager_;
 
 #if BUILDFLAG(IS_WIN)
+  static bool s_useDirectWrite;
   static WebFontPrewarmer* prewarmer_;
   static bool antialiased_text_enabled_;
   static bool lcd_text_enabled_;
@@ -362,10 +378,13 @@ class PLATFORM_EXPORT FontCache final {
   static int32_t small_caption_font_height_;
   static AtomicString* status_font_family_name_;
   static int32_t status_font_height_;
+  static bool use_skia_font_fallback_;
 
   // Windows creates an SkFontMgr for unit testing automatically. This flag is
   // to ensure it's not happening in the production from the crash log.
   bool is_test_font_mgr_ = false;
+  mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  std::unique_ptr<FallbackFamilyStyleCache> fallback_params_cache_;
 #endif  // BUILDFLAG(IS_WIN)
 
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
diff --git a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
index 2a1f2357dbe6c..05fbad33b180a 100644
--- a/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
+++ b/third_party/blink/renderer/platform/fonts/font_custom_platform_data.cc
@@ -45,6 +45,9 @@
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/shared_buffer.h"
 #include "third_party/blink/renderer/platform/wtf/wtf_size_t.h"
+#if BUILDFLAG(IS_WIN)
+#include "third_party/skia/include/ports/SkTypeface_win.h"
+#endif
 #include "third_party/skia/include/core/SkTypeface.h"
 #include "v8/include/v8.h"
 
@@ -128,6 +131,34 @@ FontPlatformData FontCustomPlatformData::GetFontPlatformData(
   // now, going with a reasonable upper limit. Deduplication is
   // handled by Skia with priority given to the last occuring
   // assignment.
+  #if BUILDFLAG(IS_WIN)
+    if (!FontCache::useDirectWrite()) {
+        // FIXME: Skia currently renders synthetic bold and italics with
+        // hinting and without linear metrics on the windows GDI backend
+        // while the DirectWrite backend does the right thing. Using
+        // legacyCreateTypeface and specifying the bold/italics style allows
+        // for proper rendering of synthetic style. Once Skia has been
+        // updated this workaround will no longer be needed.
+        // http://crbug.com/332958
+        bool syntheticBold = bold && !return_typeface->isBold();
+        bool syntheticItalic = italic && !return_typeface->isItalic();
+        if (syntheticBold || syntheticItalic) {
+            SkString name;
+			sk_sp<SkFontMgr> font_mgr(SkFontMgr_New_GDI());
+            return_typeface->getFamilyName(&name);
+
+            SkFontStyle realStyle = return_typeface->fontStyle();
+            SkFontStyle syntheticStyle = SkFontStyle(
+                realStyle.weight() + (syntheticBold ? 200 : 0),
+                realStyle.width(),
+                syntheticItalic ? SkFontStyle::kItalic_Slant : realStyle.slant());
+            sk_sp<SkTypeface> typeface = font_mgr->legacyMakeTypeface(name.c_str(), syntheticStyle);
+            syntheticBold = false;
+            syntheticItalic = false;
+            return FontPlatformData(typeface, "", size, syntheticBold, syntheticItalic, text_rendering, resolved_font_features, orientation);
+        }
+    }
+  #endif
   FontFormatCheck::VariableFontSubType font_sub_type =
       FontFormatCheck::ProbeVariableFont(base_typeface_);
   bool synthetic_bold = bold;
diff --git a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
index bb6625fe0df54..7f5945591bee8 100644
--- a/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
+++ b/third_party/blink/renderer/platform/fonts/font_fallback_iterator.cc
@@ -83,8 +83,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::UniqueOrNext(
 
   // Save first candidate to be returned if all other fonts fail, and we need
   // it to render the .notdef glyph.
-  if (!first_candidate_)
+  if (!first_candidate_) {
     first_candidate_ = candidate;
+  }
   return candidate;
 }
 
@@ -153,8 +154,9 @@ scoped_refptr<FontDataForRangeSet> FontFallbackIterator::Next(
 
   if (fallback_stage_ == kFirstCandidateForNotdefGlyph) {
     fallback_stage_ = kOutOfLuck;
-    if (!first_candidate_)
-      FontCache::CrashWithFontInfo(&font_description_);
+    if (!first_candidate_) {
+		FontCache::CrashWithFontInfo(&font_description_);		
+	}
     return first_candidate_;
   }
 
diff --git a/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc b/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
index fae5547d5ef83..33cc33aaa4424 100644
--- a/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
+++ b/third_party/blink/renderer/platform/fonts/font_platform_data_cache.cc
@@ -116,6 +116,7 @@ FontPlatformData* FontPlatformDataCache::GetOrCreateFontPlatformData(
   FontPlatformData* const platform_data = GetOrCreateFontPlatformData(
       font_cache, font_description, create_by_alternate_family,
       AlternateFontName::kNoAlternate);
+  
   if (!platform_data)
     return nullptr;
 
diff --git a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
index 29d1d81729d81..5e3c4455d6ffd 100644
--- a/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/font_cache_skia.cc
@@ -193,7 +193,6 @@ scoped_refptr<SimpleFontData> FontCache::GetLastResortFallbackFont(
                             AlternateFontName::kLastResort);
   }
 #endif
-
   DCHECK(font_platform_data);
   return FontDataFromFontPlatformData(font_platform_data, should_retain);
 }
@@ -219,7 +218,6 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   DCHECK_NE(family, font_family_names::kSystemUi);
   // convert the name to utf8
   name = family.Utf8();
-
 #if BUILDFLAG(IS_ANDROID)
   // If this is a locale-specific family, try looking up locale-specific
   // typeface first.
@@ -233,6 +231,12 @@ sk_sp<SkTypeface> FontCache::CreateTypeface(
   // TODO(https://crbug.com/1425390: Assign FontCache::font_manager_ in the
   // ctor.
   auto font_manager = font_manager_ ? font_manager_ : SkFontMgr::RefDefault();
+#if BUILDFLAG(IS_WIN)
+  if(!useDirectWrite()) {
+	return sk_sp<SkTypeface>(font_manager->legacyMakeTypeface(
+      name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));	  
+  }
+#endif
   return sk_sp<SkTypeface>(font_manager->matchFamilyStyle(
       name.empty() ? nullptr : name.c_str(), font_description.SkiaFontStyle()));
 }
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
new file mode 100644
index 0000000000000..2e8c855270541
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.cc
@@ -0,0 +1,90 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "third_party/blink/renderer/platform/fonts/font_platform_data.h"
+
+namespace blink {
+
+namespace {
+
+const wtf_size_t kMaxCacheSlots = 16;
+
+String makeCacheKey(FontDescription::GenericFamilyType generic_family,
+                    String bcp47_language_tag,
+                    FontFallbackPriority fallback_priority) {
+  StringBuilder cache_key;
+  cache_key.Append(bcp47_language_tag);
+  cache_key.AppendNumber(
+      static_cast<
+          std::underlying_type<FontDescription::GenericFamilyType>::type>(
+          generic_family));
+  cache_key.AppendNumber(
+      static_cast<std::underlying_type<FontFallbackPriority>::type>(
+          fallback_priority));
+  return cache_key.ToString();
+}
+
+void getFallbackFamilyAndStyle(SkTypeface* typeface,
+                               String* fallback_family,
+                               SkFontStyle* fallback_style) {
+  SkString family;
+  typeface->getFamilyName(&family);
+  *fallback_family = family.c_str();
+
+  *fallback_style = typeface->fontStyle();
+}
+}  // namespace
+
+FallbackFamilyStyleCache::FallbackFamilyStyleCache()
+    : recent_fallback_fonts_(kMaxCacheSlots) {}
+
+void FallbackFamilyStyleCache::Put(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    SkTypeface* typeface) {
+  String cache_key =
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority);
+
+  auto it = recent_fallback_fonts_.Get(cache_key);
+  if (it != recent_fallback_fonts_.end()) {
+    it->second.insert(0, sk_ref_sp(typeface));
+  } else {
+    TypefaceVector typefaces;
+    typefaces.push_back(sk_ref_sp(typeface));
+    recent_fallback_fonts_.Put(std::move(cache_key), std::move(typefaces));
+  }
+}
+
+void FallbackFamilyStyleCache::Get(
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority fallback_priority,
+    UChar32 character,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  auto it = recent_fallback_fonts_.Get(
+      makeCacheKey(generic_family, bcp47_language_tag, fallback_priority));
+  if (it == recent_fallback_fonts_.end())
+    return;
+  TypefaceVector& typefaces = it->second;
+  for (wtf_size_t i = 0; i < typefaces.size(); ++i) {
+    sk_sp<SkTypeface>& typeface = typefaces.at(i);
+    if (typeface->unicharToGlyph(character)) {
+      getFallbackFamilyAndStyle(typeface.get(), fallback_family,
+                                fallback_style);
+      sk_sp<SkTypeface> tmp_typeface(typeface);
+      // For the vector of typefaces for this specific language tag, since this
+      // SkTypeface had a glyph, move it to the beginning to accelerate
+      // subsequent lookups.
+      typefaces.EraseAt(i);
+      typefaces.insert(0, std::move(tmp_typeface));
+      return;
+    }
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
new file mode 100644
index 0000000000000..72e27fa69b27f
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h
@@ -0,0 +1,59 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+#define THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
+
+#include "base/containers/lru_cache.h"
+#include "third_party/blink/renderer/platform/fonts/font_description.h"
+#include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace blink {
+
+using TypefaceVector = Vector<sk_sp<SkTypeface>>;
+using FallbackLruCache = base::HashingLRUCache<String, TypefaceVector>;
+
+class FallbackFamilyStyleCache {
+  USING_FAST_MALLOC(FallbackFamilyStyleCache);
+
+ public:
+  FallbackFamilyStyleCache();
+  FallbackFamilyStyleCache(const FallbackFamilyStyleCache&) = delete;
+  FallbackFamilyStyleCache& operator=(const FallbackFamilyStyleCache&) = delete;
+
+  // Places a SkTypeface object in the cache for specified language tag and
+  // fallback priority, taking a reference on SkTypeface. Adds the |SkTypeface|
+  // to the beginning of a list of typefaces if previous |SkTypefaces| objects
+  // where added for this set of parameters. Note, the internal list of
+  // typefaces for a language tag and fallback priority is not checked for
+  // duplicates when adding a |typeface| object.
+  void Put(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           SkTypeface* typeface);
+
+  // Fetches a |fallback_family| and |fallback_style| for a given language tag,
+  // fallback priority and codepoint. Checks the internal cache for whether a
+  // fallback font with glyph coverage for |character| is available for the
+  // given parameters, then returns its family name and style.
+  void Get(FontDescription::GenericFamilyType generic_family,
+           String bcp47_language_tag,
+           FontFallbackPriority fallback_priority,
+           UChar32 character,
+           String* fallback_family,
+           SkFontStyle* fallback_style);
+
+  // Empties the internal cache, deleting keys and unrefing the typefaces that
+  // were placed in the cache.
+  void Clear();
+
+ private:
+  FallbackLruCache recent_fallback_fonts_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FALLBACK_FAMILY_STYLE_CACHE_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
new file mode 100644
index 0000000000000..0363fdca92dde
--- /dev/null
+++ b/third_party/blink/renderer/platform/fonts/win/fallback_lru_cache_win_test.cc
@@ -0,0 +1,99 @@
+// Copyright 2019 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/platform/fonts/win/fallback_family_style_cache_win.h"
+
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/renderer/platform/wtf/text/character_names.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontMgr.h"
+#include "third_party/skia/include/core/SkRefCnt.h"
+#include "third_party/skia/include/core/SkTypeface.h"
+
+namespace {
+
+const char kHanSimplifiedLocale[] = "zh-Hans";
+const size_t kLruCacheTestSize = 5;
+const char kFontFamilyNameArial[] = "Arial";
+const UChar32 kFirstCJKIdeograph = 0x4E00;
+const UChar32 kSecondCJKIdeograph = kFirstCJKIdeograph + 1;
+
+sk_sp<SkTypeface> fallbackForLocale(String locale, UChar32 codepoint) {
+  sk_sp<SkFontMgr> font_mgr = SkFontMgr::RefDefault();
+  std::string locale_string(locale.Ascii());
+  const char* locale_char = locale_string.c_str();
+  return sk_sp<SkTypeface>(font_mgr->matchFamilyStyleCharacter(
+      kFontFamilyNameArial, SkFontStyle(), &locale_char, 1, codepoint));
+}
+
+void fillCacheWithDummies(blink::FallbackLruCache& lru_cache,
+                          const char* format_string,
+                          size_t count) {
+  for (size_t i = 0; i < count; ++i) {
+    blink::TypefaceVector dummy_typefaces;
+    dummy_typefaces.push_back(
+        SkTypeface::MakeFromName(kFontFamilyNameArial, SkFontStyle()));
+    lru_cache.Put(String::Format(format_string, i), std::move(dummy_typefaces));
+  }
+}
+
+}  // namespace
+
+namespace blink {
+
+TEST(FallbackLruCacheTest, KeepChineseWhenFetched) {
+  // Put a Chinese font in the cache, add size - 1 more dummy fallback fonts so
+  // that the cache is full. Get() and verify typeface for Chinese to move them
+  // up to the top of the cache. Then fill again with size - 1 items and verify
+  // that Chinese is still in the cache. Then fill with # size items to evict
+  // the Chinese font and ensure it's gone.
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  TypefaceVector fallback_typefaces_zh;
+  fallback_typefaces_zh.push_back(
+      fallbackForLocale(kHanSimplifiedLocale, kFirstCJKIdeograph));
+  lru_cache.Put(kHanSimplifiedLocale, std::move(fallback_typefaces_zh));
+
+  EXPECT_EQ(lru_cache.size(), 1u);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", kLruCacheTestSize - 1);
+  auto it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it != lru_cache.end());
+  TypefaceVector& chinese_typefaces = it->second;
+  EXPECT_TRUE(chinese_typefaces.at(0)->unicharToGlyph(0x4E01));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_2nd_%zu",
+                       kLruCacheTestSize - 1);
+  it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it != lru_cache.end());
+  chinese_typefaces = it->second;
+  EXPECT_EQ(chinese_typefaces.size(), 1u);
+  EXPECT_TRUE(chinese_typefaces.at(0)->unicharToGlyph(kSecondCJKIdeograph));
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+
+  fillCacheWithDummies(lru_cache, "dummy_locale_3rd_%zu", kLruCacheTestSize);
+  it = lru_cache.Get(kHanSimplifiedLocale);
+  EXPECT_TRUE(it == lru_cache.end());
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+}
+
+TEST(FallbackLruCacheTest, LargeFillAndClear) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "dummy_locale_%zu", 1000);
+  EXPECT_EQ(lru_cache.size(), kLruCacheTestSize);
+  lru_cache.Clear();
+  EXPECT_EQ(lru_cache.size(), 0u);
+}
+
+TEST(FallbackLruCacheTest, KeyOverride) {
+  FallbackLruCache lru_cache(kLruCacheTestSize);
+  EXPECT_EQ(lru_cache.size(), 0u);
+  fillCacheWithDummies(lru_cache, "same_locale", 10);
+  EXPECT_EQ(lru_cache.size(), 1u);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
index 01e6acd3c8dbc..3463aecd5cbbe 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_cache_skia_win.cc
@@ -42,6 +42,8 @@
 #include "base/feature_list.h"
 #include "base/metrics/histogram_functions.h"
 #include "base/trace_event/trace_event.h"
+#include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
+#include "third_party/blink/public/platform/platform.h"
 #include "third_party/blink/public/platform/web_font_prewarmer.h"
 #include "third_party/blink/renderer/platform/fonts/bitmap_glyphs_block_list.h"
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
@@ -163,6 +165,13 @@ void FontCache::SetStatusFontMetrics(const AtomicString& family_name,
   status_font_height_ = EnsureMinimumFontHeightIfNeeded(font_height);
 }
 
+void FontCache::EnsureServiceConnected() {
+  if (service_)
+    return;
+  Platform::Current()->GetBrowserInterfaceBroker()->GetInterface(
+      service_.BindNewPipeAndPassReceiver());
+}
+
 // TODO(https://crbug.com/976737): This function is deprecated and only intended
 // to run in parallel with the API based OOP font fallback calls to compare the
 // results and track them in UMA for a while until we decide to remove this
@@ -247,30 +256,90 @@ scoped_refptr<SimpleFontData> FontCache::GetDWriteFallbackFamily(
       font_description, fallback_priority, codepoint);
   DCHECK(fallback_locale);
 
-  const std::string family_name = font_description.Family().FamilyName().Utf8();
+  // On Pre Windows 8.1 (where use_skia_font_fallback_ is false) we cannot call
+  // the Skia version, as there is no IDWriteFontFallback (which is
+  // proxyable). If no IDWriteFontFallback API exists in the DWrite Skia
+  // SkTypeface implemnetation it will proceed to call the layoutFallback method
+  // of SkTypeface DWrite implementation. This method we must not call in the
+  // renderer as it causes stability issues due to reaching a path that will try
+  // to load the system font collection in-process and thus load DLLs that are
+  // blocked in the renderer, see comment in dwrite_font_proxy_init_impl_win.cc
+  // InitializeDWriteFontProxy(). Hence, for Windows pre 8.1 we add a
+  // DWriteFontProxy code path to retrieve a family name as string for a
+  // character + language tag and call matchFamilyStyleCharacter on the browser
+  // side, where we can do that.
+  if (!use_skia_font_fallback_) {
+    String fallback_family;
+    SkFontStyle fallback_style;
+
+    if (UNLIKELY(!fallback_params_cache_)) {
+      fallback_params_cache_ = std::make_unique<FallbackFamilyStyleCache>();
+    }
 
-  Bcp47Vector locales;
-  locales.push_back(fallback_locale->LocaleForSkFontMgr());
-  sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
-      family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
-      locales.size(), codepoint));
+    fallback_params_cache_->Get(
+        font_description.GenericFamily(), fallback_locale->LocaleForSkFontMgr(),
+        fallback_priority, codepoint, &fallback_family, &fallback_style);
+    bool result_from_cache = !fallback_family.IsNull();
 
-  if (!typeface) {
-    return nullptr;
-  }
+    if (!result_from_cache) {
+      EnsureServiceConnected();
+
+      // After Mojo IPC, on the browser side, this ultimately reaches
+      // Skia's matchFamilyStyleCharacter for Windows, which does not implement
+      // traversing the language tag stack but only processes the most important
+      // one, so we use FallbackLocaleForCharacter() to determine what locale to
+      // choose to achieve the best possible result.
+
+      if (!GetOutOfProcessFallbackFamily(
+              codepoint, font_description.GenericFamily(),
+              fallback_locale->LocaleForSkFontMgr(), fallback_priority,
+              service_, &fallback_family, &fallback_style))
+        return nullptr;
+
+      if (fallback_family.empty())
+        return nullptr;
+    }
+
+    FontFaceCreationParams create_by_family((AtomicString(fallback_family)));
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(fallback_style);
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+
+    if (!result_from_cache) {
+      fallback_params_cache_->Put(font_description.GenericFamily(),
+                                  fallback_locale->LocaleForSkFontMgr(),
+                                  fallback_priority, data->Typeface());
+    }
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
+  } else {
+    std::string family_name = font_description.Family().FamilyName().Utf8();
+
+    Bcp47Vector locales;
+    locales.push_back(fallback_locale->LocaleForSkFontMgr());
+    sk_sp<SkTypeface> typeface(font_manager_->matchFamilyStyleCharacter(
+        family_name.c_str(), font_description.SkiaFontStyle(), locales.data(),
+        locales.size(), codepoint));
+
+    if (!typeface)
+      return nullptr;
 
-  SkString skia_family;
-  typeface->getFamilyName(&skia_family);
-  FontDescription fallback_updated_font_description(font_description);
-  fallback_updated_font_description.UpdateFromSkiaFontStyle(
-      typeface->fontStyle());
-  const FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
-  FontPlatformData* data =
-      GetFontPlatformData(fallback_updated_font_description, create_by_family);
-  if (!data || !data->FontContainsCharacter(codepoint)) {
-    return nullptr;
+    SkString skia_family;
+    typeface->getFamilyName(&skia_family);
+    FontDescription fallback_updated_font_description(font_description);
+    fallback_updated_font_description.UpdateFromSkiaFontStyle(
+        typeface->fontStyle());
+    FontFaceCreationParams create_by_family(ToAtomicString(skia_family));
+    FontPlatformData* data = GetFontPlatformData(
+        fallback_updated_font_description, create_by_family);
+    if (!data || !data->FontContainsCharacter(codepoint))
+      return nullptr;
+    return FontDataFromFontPlatformData(data, kDoNotRetain);
   }
-  return FontDataFromFontPlatformData(data, kDoNotRetain);
+  NOTREACHED();
+  return nullptr;
 }
 
 // Given the desired base font, this will create a SimpleFontData for a specific
@@ -296,9 +365,10 @@ scoped_refptr<SimpleFontData> FontCache::PlatformFallbackFontForCharacter(
       GetFallbackFamilyNameFromHardcodedChoices(font_description, character,
                                                 fallback_priority);
 
-  // Fall through to running the API-based fallback.
+  // Fall through to running the API based fallback on Windows 8.1 and above
+  // where API fallback was previously available.
   if (RuntimeEnabledFeatures::LegacyWindowsDWriteFontFallbackEnabled() ||
-      !hardcoded_list_fallback_font) {
+      (!hardcoded_list_fallback_font && use_skia_font_fallback_)) {
     return GetDWriteFallbackFamily(font_description, character,
                                    fallback_priority);
   }
@@ -439,7 +509,7 @@ std::unique_ptr<FontPlatformData> FontCache::CreateFontPlatformData(
 
   } else {
     typeface = CreateTypeface(font_description, creation_params, name);
-
+    
     // For a family match, Windows will always give us a valid pointer here,
     // even if the face name is non-existent. We have to double-check and see if
     // the family name was really used.
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
index fe7c9a5c819bd..12b8e76a39921 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.cc
@@ -48,11 +48,19 @@ namespace blink {
 
 namespace {
 
+const char kArial[] = "Arial";
+const char kCourierNew[] = "Courier New";
+const char kTimesNewRoman[] = "Times New Roman";
+
 static inline bool IsFontPresent(const UChar* font_name,
                                  SkFontMgr* font_manager) {
   String family = font_name;
-  sk_sp<SkTypeface> tf(
-      font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle()));
+  sk_sp<SkTypeface> tf;
+  if(FontCache::useDirectWrite()) {
+	tf = font_manager->matchFamilyStyle(family.Utf8().c_str(), SkFontStyle());
+  } else {
+	tf = font_manager->legacyMakeTypeface(family.Utf8().data(), SkFontStyle());
+  }
   if (!tf)
     return false;
 
@@ -538,4 +546,38 @@ const UChar* GetFallbackFamily(UChar32 character,
   return family;
 }
 
+bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType generic_family,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& service,
+    String* fallback_family,
+    SkFontStyle* fallback_style) {
+  String base_family_name_approximation;
+  switch (generic_family) {
+    case FontDescription::kMonospaceFamily:
+      base_family_name_approximation = kCourierNew;
+      break;
+    case FontDescription::kSansSerifFamily:
+      base_family_name_approximation = kArial;
+      break;
+    default:
+      base_family_name_approximation = kTimesNewRoman;
+  }
+
+  mojom::blink::FallbackFamilyAndStylePtr fallback_family_and_style;
+  bool mojo_result = service->FallbackFamilyAndStyleForCodepoint(
+      base_family_name_approximation, bcp47_language_tag, character,
+      &fallback_family_and_style);
+
+  SECURITY_DCHECK(fallback_family);
+  SECURITY_DCHECK(fallback_style);
+  *fallback_family = fallback_family_and_style->fallback_family_name;
+  *fallback_style = SkFontStyle(
+      fallback_family_and_style->weight, fallback_family_and_style->width,
+      static_cast<SkFontStyle::Slant>(fallback_family_and_style->slant));
+  return mojo_result;
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
index 6a51e150dc5b9..254eba78a3639 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_fallback_win.h
@@ -34,10 +34,13 @@
 #include <unicode/locid.h>
 #include <unicode/uscript.h>
 
+#include "mojo/public/cpp/bindings/remote.h"
+#include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink-forward.h"
 #include "third_party/blink/renderer/platform/fonts/font_description.h"
 #include "third_party/blink/renderer/platform/fonts/font_fallback_priority.h"
 #include "third_party/blink/renderer/platform/platform_export.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
+#include "third_party/skia/include/core/SkFontStyle.h"
 
 class SkFontMgr;
 
@@ -55,6 +58,19 @@ PLATFORM_EXPORT const UChar* GetFallbackFamily(
     FontFallbackPriority,
     SkFontMgr* font_manager);
 
+// Return a font family that can render |character| based on what script
+// that characters belong to by performing an out of process lookup and using
+// system fallback API based on IDWriteTextLayout. This method is only to be
+// used on pre Windows 8.1, as otherwise IDWriteFontFallback API is available.
+PLATFORM_EXPORT bool GetOutOfProcessFallbackFamily(
+    UChar32 character,
+    FontDescription::GenericFamilyType,
+    String bcp47_language_tag,
+    FontFallbackPriority,
+    const mojo::Remote<mojom::blink::DWriteFontProxy>& font_proxy,
+    String* fallback_family,
+    SkFontStyle* fallback_style);
+
 }  // namespace blink
 
 #endif  // THIRD_PARTY_BLINK_RENDERER_PLATFORM_FONTS_WIN_FONT_FALLBACK_WIN_H_
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
index 3b1c3db022fd0..2f825c618b83e 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.cc
@@ -10,6 +10,7 @@
 #include "base/files/file_path.h"
 #include "base/files/file_util.h"
 #include "base/metrics/histogram_macros.h"
+#include "mojo/public/mojom/base/shared_memory.mojom-blink.h"
 #include "third_party/blink/public/common/features.h"
 #include "third_party/blink/public/common/thread_safe_browser_interface_broker_proxy.h"
 #include "third_party/blink/public/mojom/dwrite_font_proxy/dwrite_font_proxy.mojom-blink.h"
@@ -26,11 +27,14 @@ FontUniqueNameLookupWin::~FontUniqueNameLookupWin() = default;
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueName(
     const String& font_unique_name) {
-  return MatchUniqueNameSingleLookup(font_unique_name);
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups)
+    return MatchUniqueNameSingleLookup(font_unique_name);
+  return MatchUniqueNameLookupTable(font_unique_name);
 }
 
 sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
     const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups);
   base::File font_file;
   uint32_t ttc_index = 0;
 
@@ -43,6 +47,31 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameSingleLookup(
   return InstantiateFromFileAndTtcIndex(std::move(font_file), ttc_index);
 }
 
+sk_sp<SkTypeface> FontUniqueNameLookupWin::MatchUniqueNameLookupTable(
+    const String& font_unique_name) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  if (!IsFontUniqueNameLookupReadyForSyncLookup())
+    return nullptr;
+
+  absl::optional<FontTableMatcher::MatchResult> match_result =
+      font_table_matcher_->MatchName(font_unique_name.Utf8());
+  if (!match_result)
+    return nullptr;
+
+  base::FilePath file_path =
+      base::FilePath::FromUTF8Unsafe(match_result->font_path.c_str());
+  return InstantiateFromPathAndTtcIndex(file_path, match_result->ttc_index);
+}
+
+// Used for font matching with table lookup case only.
+sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromPathAndTtcIndex(
+    base::FilePath font_file_path,
+    uint32_t ttc_index) {
+  return SkTypeface::MakeFromFile(font_file_path.AsUTF8Unsafe().c_str(),
+                                  ttc_index);
+}
+
 // Used for font matching with single lookup case only.
 sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
     base::File file_handle,
@@ -60,11 +89,52 @@ sk_sp<SkTypeface> FontUniqueNameLookupWin::InstantiateFromFileAndTtcIndex(
 }
 
 bool FontUniqueNameLookupWin::IsFontUniqueNameLookupReadyForSyncLookup() {
-  if (RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled()) {
-    EnsureServiceConnected();
+  if (!RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled())
+    return true;
+
+  EnsureServiceConnected();
+
+  if (!lookup_mode_.has_value()) {
+    blink::mojom::UniqueFontLookupMode lookup_mode_from_mojo;
+    service_->GetUniqueFontLookupMode(&lookup_mode_from_mojo);
+    lookup_mode_ = lookup_mode_from_mojo;
+  }
+
+  if (lookup_mode_ == blink::mojom::UniqueFontLookupMode::kSingleLookups) {
+    return true;
   }
 
-  return true;
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  // If we have the table already, we're ready for sync lookups.
+  if (font_table_matcher_.get())
+    return true;
+
+  // We have previously determined via IPC whether the table is sync available.
+  // Return what we found out before.
+  if (sync_available_.has_value())
+    return sync_available_.value();
+
+  // If we haven't asked the browser before, probe synchronously - if the table
+  // is available on the browser side, we can continue with sync operation.
+
+  bool sync_available_from_mojo = false;
+  base::ReadOnlySharedMemoryRegion shared_memory_region;
+  service_->GetUniqueNameLookupTableIfAvailable(&sync_available_from_mojo,
+                                                &shared_memory_region);
+  sync_available_ = sync_available_from_mojo;
+
+  if (*sync_available_) {
+    // Adopt the shared memory region, do not notify anyone in callbacks as
+    // PrepareFontUniqueNameLookup must not have been called yet. Just return
+    // true from this function.
+    DCHECK_EQ(pending_callbacks_.size(), 0u);
+    ReceiveReadOnlySharedMemoryRegion(std::move(shared_memory_region));
+  }
+
+  // If it wasn't available synchronously LocalFontFaceSource has to call
+  // PrepareFontUniqueNameLookup.
+  return *sync_available_;
 }
 
 void FontUniqueNameLookupWin::EnsureServiceConnected() {
@@ -74,11 +144,66 @@ void FontUniqueNameLookupWin::EnsureServiceConnected() {
       service_.BindNewPipeAndPassReceiver());
 }
 
+void FontUniqueNameLookupWin::PrepareFontUniqueNameLookup(
+    NotifyFontUniqueNameLookupReady callback) {
+  DCHECK(!font_table_matcher_.get());
+  DCHECK(RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled());
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+
+  pending_callbacks_.push_back(std::move(callback));
+
+  // We bind the service on the first call to PrepareFontUniqueNameLookup. After
+  // that we do not need to make additional IPC requests to retrieve the table.
+  // The observing callback was added to the list, so all clients will be
+  // informed when the lookup table has arrived.
+  if (pending_callbacks_.size() > 1)
+    return;
+
+  EnsureServiceConnected();
+
+  service_->GetUniqueNameLookupTable(base::BindOnce(
+      &FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion,
+      base::Unretained(this)));
+}
+
 void FontUniqueNameLookupWin::Init() {
   if (!base::FeatureList::IsEnabled(features::kPrefetchFontLookupTables))
     return;
 
   EnsureServiceConnected();
+
+  if (lookup_mode_.has_value()) {
+    InitWithLookupMode(lookup_mode_.value());
+    return;
+  }
+
+  service_->GetUniqueFontLookupMode(base::BindOnce(
+      &FontUniqueNameLookupWin::InitWithLookupMode, base::Unretained(this)));
+}
+
+void FontUniqueNameLookupWin::ReceiveReadOnlySharedMemoryRegion(
+    base::ReadOnlySharedMemoryRegion shared_memory_region) {
+  DCHECK(lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable);
+  font_table_matcher_ =
+      std::make_unique<FontTableMatcher>(shared_memory_region.Map());
+  while (!pending_callbacks_.empty()) {
+    NotifyFontUniqueNameLookupReady callback = pending_callbacks_.TakeFirst();
+    std::move(callback).Run();
+  }
+}
+
+void FontUniqueNameLookupWin::InitWithLookupMode(
+    blink::mojom::UniqueFontLookupMode lookup_mode) {
+  lookup_mode_ = lookup_mode;
+
+  if (!font_table_matcher_.get() &&
+      RuntimeEnabledFeatures::FontSrcLocalMatchingEnabled() &&
+      lookup_mode_ == blink::mojom::UniqueFontLookupMode::kRetrieveTable) {
+    // This call primes IsFontUniqueNameLookupReadyForSyncLookup() by
+    // asynchronously fetching the font table so it will be ready when needed.
+    // It isn't needed now, so base::DoNothing() is passed as the callback.
+    PrepareFontUniqueNameLookup(base::DoNothing());
+  }
 }
 
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
index 7b31b5af1cabc..abdf287af3677 100644
--- a/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
+++ b/third_party/blink/renderer/platform/fonts/win/font_unique_name_lookup_win.h
@@ -14,8 +14,14 @@
 namespace blink {
 
 // Performs the IPC towards the browser process for font unique name
-// matching. Direct individual sync Mojo IPC calls are made to lookup fonts,
-// and the class reponds synchronously.
+// matching. This class operates in one of two lookup modes, depending on
+// lookup_mode_. On Windows 10 or when IDWriteFontFactory3 is available, direct
+// individual sync Mojo IPC calls are made too lookup fonts - and the class
+// reponds synchronously.  On Windows Vista, 7 & 8, a shared memory region is retrieved
+// asynchronously, then lookups are performed against that table. When the
+// asynchronous request to retrieve the table completes, the clients are
+// notified. And once the table was retrieved, this class returns to operating
+// in synchronous mode as matching can be performed instantly.
 class FontUniqueNameLookupWin : public FontUniqueNameLookup {
  public:
   FontUniqueNameLookupWin();
@@ -26,17 +32,32 @@ class FontUniqueNameLookupWin : public FontUniqueNameLookup {
 
   bool IsFontUniqueNameLookupReadyForSyncLookup() override;
 
+  void PrepareFontUniqueNameLookup(
+      NotifyFontUniqueNameLookupReady callback) override;
+
   void Init() override;
 
  private:
   void EnsureServiceConnected();
 
+  sk_sp<SkTypeface> MatchUniqueNameLookupTable(const String& font_unique_name);
+
   sk_sp<SkTypeface> MatchUniqueNameSingleLookup(const String& font_unique_name);
 
+  sk_sp<SkTypeface> InstantiateFromPathAndTtcIndex(
+      base::FilePath font_file_path,
+      uint32_t ttc_index);
   sk_sp<SkTypeface> InstantiateFromFileAndTtcIndex(base::File file_handle,
                                                    uint32_t ttc_index);
 
+  void InitWithLookupMode(blink::mojom::UniqueFontLookupMode lookup_mode);
+  WTF::Deque<NotifyFontUniqueNameLookupReady> pending_callbacks_;
   mojo::Remote<mojom::blink::DWriteFontProxy> service_;
+  absl::optional<bool> sync_available_;
+  absl::optional<blink::mojom::UniqueFontLookupMode> lookup_mode_;
+
+  void ReceiveReadOnlySharedMemoryRegion(
+      base::ReadOnlySharedMemoryRegion shared_memory_region);
 };
 
 }  // namespace blink
diff --git a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
index e079f9ccd09d2..ed9cb666ff09b 100644
--- a/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
+++ b/ui/base/ime/win/on_screen_keyboard_display_manager_input_pane.cc
@@ -91,6 +91,11 @@ class OnScreenKeyboardDisplayManagerInputPane::VirtualKeyboardInputPane
     if (input_pane2_)
       return true;
 
+    if (!base::win::ResolveCoreWinRTDelayload() ||
+        !base::win::ScopedHString::ResolveCoreWinRTStringDelayload()) {
+      return false;
+    }
+
     base::win::AssertComApartmentType(base::win::ComApartmentType::STA);
 
     base::win::ScopedHString input_pane_guid = base::win::ScopedHString::Create(
diff --git a/ui/display/win/screen_win.cc b/ui/display/win/screen_win.cc
index 773fbb8e90276..4cb727542c2f9 100644
--- a/ui/display/win/screen_win.cc
+++ b/ui/display/win/screen_win.cc
@@ -47,13 +47,47 @@ namespace {
 // resolved with Desktop Aura and WindowTreeHost.
 ScreenWin* g_instance = nullptr;
 
+bool IsProcessPerMonitorDpiAware() {
+  enum class PerMonitorDpiAware {
+    UNKNOWN = 0,
+    PER_MONITOR_DPI_UNAWARE,
+    PER_MONITOR_DPI_AWARE,
+  };
+  static PerMonitorDpiAware per_monitor_dpi_aware = PerMonitorDpiAware::UNKNOWN;
+  if (per_monitor_dpi_aware == PerMonitorDpiAware::UNKNOWN) {
+    per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_UNAWARE;
+    HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    if (shcore_dll) {
+      auto get_process_dpi_awareness_func =
+          reinterpret_cast<decltype(::GetProcessDpiAwareness)*>(
+              ::GetProcAddress(shcore_dll, "GetProcessDpiAwareness"));
+      if (get_process_dpi_awareness_func) {
+        PROCESS_DPI_AWARENESS awareness;
+        if (SUCCEEDED(get_process_dpi_awareness_func(nullptr, &awareness)) &&
+            awareness == PROCESS_PER_MONITOR_DPI_AWARE)
+          per_monitor_dpi_aware = PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+      }
+    }
+  }
+  return per_monitor_dpi_aware == PerMonitorDpiAware::PER_MONITOR_DPI_AWARE;
+}
+
 // Gets the DPI for a particular monitor.
 absl::optional<int> GetPerMonitorDPI(HMONITOR monitor) {
+  if (!IsProcessPerMonitorDpiAware())
+    return absl::nullopt;
+
+  static auto get_dpi_for_monitor_func = []() {
+    const HMODULE shcore_dll = ::LoadLibrary(L"shcore.dll");
+    return reinterpret_cast<decltype(&::GetDpiForMonitor)>(
+        shcore_dll ? ::GetProcAddress(shcore_dll, "GetDpiForMonitor")
+                   : nullptr);
+  }();
   UINT dpi_x, dpi_y;
-  if (!SUCCEEDED(
-          ::GetDpiForMonitor(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y))) {
+  if (!get_dpi_for_monitor_func ||
+      !SUCCEEDED(
+          get_dpi_for_monitor_func(monitor, MDT_EFFECTIVE_DPI, &dpi_x, &dpi_y)))
     return absl::nullopt;
-  }
 
   DCHECK_EQ(dpi_x, dpi_y);
   return static_cast<int>(dpi_x);
diff --git a/ui/display/win/uwp_text_scale_factor.cc b/ui/display/win/uwp_text_scale_factor.cc
index f6867edea301e..2d2d18c212bca 100644
--- a/ui/display/win/uwp_text_scale_factor.cc
+++ b/ui/display/win/uwp_text_scale_factor.cc
@@ -52,6 +52,13 @@ bool g_default_instance_cleaned_up = false;
 bool CreateUiSettingsComObject(ComPtr<IUISettings2>& ptr) {
   DCHECK(!ptr);
 
+  // This is required setup before using ScopedHString.
+  if (!(base::win::ResolveCoreWinRTDelayload() &&
+        base::win::ScopedHString::ResolveCoreWinRTStringDelayload())) {
+    DLOG(ERROR) << "Failed loading functions from combase.dll";
+    return false;
+  }
+
   // Create the COM object.
   auto hstring = base::win::ScopedHString::Create(
       RuntimeClass_Windows_UI_ViewManagement_UISettings);
diff --git a/ui/gfx/font_render_params_win.cc b/ui/gfx/font_render_params_win.cc
index 4769c5853ee61..825b5f901c60e 100644
--- a/ui/gfx/font_render_params_win.cc
+++ b/ui/gfx/font_render_params_win.cc
@@ -12,6 +12,7 @@
 #include "base/memory/singleton.h"
 #include "base/win/registry.h"
 #include "ui/gfx/win/singleton_hwnd_observer.h"
+#include "ui/gfx/win/direct_write.h"
 
 namespace gfx {
 
@@ -83,7 +84,8 @@ class CachedFontRenderParams {
     BOOL enabled = false;
     if (SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &enabled, 0) && enabled) {
       params_->antialiasing = true;
-      params_->subpixel_positioning = true;
+      // GDI does not support subpixel positioning.
+      params_->subpixel_positioning = win::IsDirectWriteEnabled();
 
       UINT type = 0;
       if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &type, 0) &&
diff --git a/ui/gfx/render_text.cc b/ui/gfx/render_text.cc
index dab8c9be8d902..94d1db4b533ac 100644
--- a/ui/gfx/render_text.cc
+++ b/ui/gfx/render_text.cc
@@ -44,6 +44,10 @@
 #include "ui/gfx/text_utils.h"
 #include "ui/gfx/utf16_indexing.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "base/win/windows_version.h"
+#endif
+
 namespace gfx {
 
 namespace {
@@ -255,23 +259,25 @@ UChar32 ReplaceControlCharacter(UChar32 codepoint) {
     // Support Microsoft defined PUA on Windows.
     // see:
     // https://docs.microsoft.com/en-us/windows/uwp/design/style/segoe-ui-symbol-font
-    switch (codepoint) {
-      case 0xF093:  // ButtonA
-      case 0xF094:  // ButtonB
-      case 0xF095:  // ButtonY
-      case 0xF096:  // ButtonX
-      case 0xF108:  // LeftStick
-      case 0xF109:  // RightStick
-      case 0xF10A:  // TriggerLeft
-      case 0xF10B:  // TriggerRight
-      case 0xF10C:  // BumperLeft
-      case 0xF10D:  // BumperRight
-      case 0xF10E:  // Dpad
-      case 0xEECA:  // ButtonView2
-      case 0xEDE3:  // ButtonMenu
-        return codepoint;
-      default:
-        break;
+  if (base::win::GetVersion() >= base::win::Version::WIN10) {
+      switch (codepoint) {
+        case 0xF093:  // ButtonA
+        case 0xF094:  // ButtonB
+        case 0xF095:  // ButtonY
+        case 0xF096:  // ButtonX
+        case 0xF108:  // LeftStick
+        case 0xF109:  // RightStick
+        case 0xF10A:  // TriggerLeft
+        case 0xF10B:  // TriggerRight
+        case 0xF10C:  // BumperLeft
+        case 0xF10D:  // BumperRight
+        case 0xF10E:  // Dpad
+        case 0xEECA:  // ButtonView2
+        case 0xEDE3:  // ButtonMenu
+          return codepoint;
+        default:
+          break;
+      }
     }
 #endif
     const int8_t codepoint_category = u_charType(codepoint);
@@ -996,12 +1002,14 @@ int RenderText::GetContentWidth() {
 int RenderText::GetBaseline() {
   if (baseline_ == kInvalidBaseline) {
     const int centering_height =
-        (vertical_alignment_ == ALIGN_MIDDLE)
+        (vertical_alignment_ == ALIGN_MIDDLE || vertical_alignment_ == ALIGN_SPECIAL)
             ? display_rect().height()
             : std::max(font_list().GetHeight(), min_line_height());
     baseline_ = DetermineBaselineCenteringText(centering_height, font_list());
     if (vertical_alignment_ == ALIGN_BOTTOM)
       baseline_ += display_rect().height() - centering_height;
+	if (vertical_alignment_ == ALIGN_SPECIAL)
+	  baseline_ *= 1.33; // This will push down the offending labels in GDI to the point that they will appear centred
   }
   DCHECK_NE(kInvalidBaseline, baseline_);
   return baseline_;
@@ -1851,6 +1859,7 @@ Vector2d RenderText::GetAlignmentOffset(size_t line_number) {
       offset.set_y(0);
       break;
     case ALIGN_MIDDLE:
+	case ALIGN_SPECIAL:
       if (multiline_)
         offset.set_y((display_rect_.height() - GetStringSize().height()) / 2);
       else
diff --git a/ui/gfx/switches.cc b/ui/gfx/switches.cc
index 7a4c07887d822..8079de6c60522 100644
--- a/ui/gfx/switches.cc
+++ b/ui/gfx/switches.cc
@@ -8,6 +8,11 @@
 #include "build/build_config.h"
 
 namespace switches {
+	
+#if BUILDFLAG(IS_WIN)
+// Disables the DirectWrite font rendering system on windows.
+const char kDisableDirectWrite[] = "disable-direct-write";
+#endif
 
 // Scale factor to apply to every animation duration. Must be >= 0.0. This will
 // only apply to LinearAnimation and its subclasses.
diff --git a/ui/gfx/switches.h b/ui/gfx/switches.h
index fa6a82887fc5e..fb08789757b67 100644
--- a/ui/gfx/switches.h
+++ b/ui/gfx/switches.h
@@ -18,6 +18,10 @@ GFX_SWITCHES_EXPORT extern const char kEnableNativeGpuMemoryBuffers[];
 GFX_SWITCHES_EXPORT extern const char kForcePrefersReducedMotion[];
 GFX_SWITCHES_EXPORT extern const char kHeadless[];
 
+#if BUILDFLAG(IS_WIN)
+GFX_SWITCHES_EXPORT extern const char kDisableDirectWrite[];
+#endif
+
 #if BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)
 GFX_SWITCHES_EXPORT extern const char kX11Display[];
 GFX_SWITCHES_EXPORT extern const char kNoXshm[];
diff --git a/ui/gfx/text_constants.h b/ui/gfx/text_constants.h
index eaa6ea0c42037..d6eccb0842d51 100644
--- a/ui/gfx/text_constants.h
+++ b/ui/gfx/text_constants.h
@@ -70,6 +70,7 @@ enum VerticalAlignment {
   ALIGN_TOP = 0,  // Align the text's top edge with that of its display area.
   ALIGN_MIDDLE,   // Align the text's center with that of its display area.
   ALIGN_BOTTOM,   // Align the text's bottom edge with that of its display area.
+  ALIGN_SPECIAL,  // Special alignment, equivalent to ALIGN_MIDDLE, but for the GDI renderer.
 };
 
 // The directionality modes used to determine the base text direction.
diff --git a/ui/gfx/win/direct_write.cc b/ui/gfx/win/direct_write.cc
index 6e091a20069c0..e7c3bda983459 100644
--- a/ui/gfx/win/direct_write.cc
+++ b/ui/gfx/win/direct_write.cc
@@ -8,22 +8,43 @@
 
 #include <string>
 
+#include "base/command_line.h"
+#include "base/features.h"
 #include "base/debug/alias.h"
+#include "base/metrics/histogram_functions.h"
 #include "base/metrics/histogram_macros.h"
 #include "base/strings/utf_string_conversions.h"
 #include "base/trace_event/trace_event.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/fontmgr_default.h"
 #include "third_party/skia/include/core/SkFontMgr.h"
 #include "third_party/skia/include/ports/SkTypeface_win.h"
 
 namespace gfx {
 namespace win {
+	
+GFX_EXPORT bool ShouldUseDirectWrite() {
+  // Considering that there are seemingly some decent DirectWrite implementations
+  // out there for XP, we will no longer discriminate by OS version.
+  if (!::LoadLibraryA("dwrite.dll")) {
+    return false;
+  }
+  // If forced off, don't use it.
+  const base::CommandLine& command_line =
+      *base::CommandLine::ForCurrentProcess();
+  return !command_line.HasSwitch("disable-direct-write");;
+}
 
 namespace {
 
+static bool dwrite_enabled = false;
+
 // Pointer to the global IDWriteFactory interface.
 IDWriteFactory* g_direct_write_factory = nullptr;
 
+
+
+
 void SetDirectWriteFactory(IDWriteFactory* factory) {
   DCHECK(!g_direct_write_factory);
   // We grab a reference on the DirectWrite factory. This reference is
@@ -35,9 +56,24 @@ void SetDirectWriteFactory(IDWriteFactory* factory) {
 }  // anonymous namespace
 
 void CreateDWriteFactory(IDWriteFactory** factory) {
+  if (!gfx::win::ShouldUseDirectWrite())
+    return;
+
+  using DWriteCreateFactoryProc = decltype(DWriteCreateFactory)*;
+  HMODULE dwrite_dll = LoadLibraryW(L"dwrite.dll");
+  if (!dwrite_dll)
+    return;
+
+  DWriteCreateFactoryProc dwrite_create_factory_proc =
+      reinterpret_cast<DWriteCreateFactoryProc>(
+          GetProcAddress(dwrite_dll, "DWriteCreateFactory"));
+  if (!dwrite_create_factory_proc)
+    return;
+
   Microsoft::WRL::ComPtr<IUnknown> factory_unknown;
+  
   HRESULT hr =
-      DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
+      dwrite_create_factory_proc(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory),
                           &factory_unknown);
   if (FAILED(hr)) {
     base::debug::Alias(&hr);
@@ -57,12 +93,45 @@ void InitializeDirectWrite() {
 
   Microsoft::WRL::ComPtr<IDWriteFactory> factory;
   CreateDWriteFactory(&factory);
-  CHECK(!!factory);
+  if (factory == nullptr) {
+	  sk_sp<SkFontMgr> direct_write_font_mgr = SkFontMgr_New_GDI();
+	  skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
+	  return;
+  }
   SetDirectWriteFactory(factory.Get());
 
+// The skia call to create a new DirectWrite font manager instance can fail
+  // if we are unable to get the system font collection from the DirectWrite
+  // factory. The GetSystemFontCollection method in the IDWriteFactory
+  // interface fails with E_INVALIDARG on certain Windows 7 gold versions
+  // (6.1.7600.*).
   sk_sp<SkFontMgr> direct_write_font_mgr =
       SkFontMgr_New_DirectWrite(factory.Get());
-  CHECK(!!direct_write_font_mgr);
+
+  int iteration = 0;
+  if (!direct_write_font_mgr &&
+      base::win::GetVersion() == base::win::Version::WIN7) {
+    // Windows (win7_rtm) may fail to map the service sections
+    // (crbug.com/956064).
+    constexpr int kMaxRetries = 5;
+    constexpr base::TimeDelta kRetrySleepTime = base::Microseconds(500);
+    while (iteration < kMaxRetries) {
+      base::PlatformThread::Sleep(kRetrySleepTime);
+      direct_write_font_mgr = SkFontMgr_New_DirectWrite(factory.Get());
+      if (direct_write_font_mgr)
+        break;
+      ++iteration;
+    }
+  }
+  if (!direct_write_font_mgr)
+    iteration = -1;
+  base::UmaHistogramSparse("DirectWrite.Fonts.Gfx.InitializeLoopCount",
+                           iteration);
+  DCHECK(!!direct_write_font_mgr);
+  if (!direct_write_font_mgr)
+    direct_write_font_mgr = SkFontMgr_New_GDI();
+  else
+	dwrite_enabled = true;
 
   // Override the default skia font manager. This must be called before any
   // use of the skia font manager is done (e.g. before any call to
@@ -70,6 +139,10 @@ void InitializeDirectWrite() {
   skia::OverrideDefaultSkFontMgr(std::move(direct_write_font_mgr));
 }
 
+bool IsDirectWriteEnabled() {
+  return dwrite_enabled;
+}
+
 IDWriteFactory* GetDirectWriteFactory() {
   // Some unittests may access this accessor without any previous call to
   // |InitializeDirectWrite|. A call to |InitializeDirectWrite| after this
@@ -143,4 +216,4 @@ absl::optional<std::string> RetrieveLocalizedFontName(
 }
 
 }  // namespace win
-}  // namespace gfx
+}  // namespace gfx
\ No newline at end of file
diff --git a/ui/gfx/win/direct_write.h b/ui/gfx/win/direct_write.h
index 72022056d29c4..6185acdd2c2de 100644
--- a/ui/gfx/win/direct_write.h
+++ b/ui/gfx/win/direct_write.h
@@ -13,10 +13,16 @@
 
 namespace gfx {
 namespace win {
+	
+// Returns whether DirectWrite font rendering should be used.
+GFX_EXPORT bool ShouldUseDirectWrite();
 
 GFX_EXPORT void InitializeDirectWrite();
 
-// Creates a DirectWrite factory.
+// Returns true if we are using DirectWrite for font metrics and rendering.
+GFX_EXPORT bool IsDirectWriteEnabled();
+
+// Creates a DirectWrite factory, if using DirectWrite.
 GFX_EXPORT void CreateDWriteFactory(IDWriteFactory** factory);
 
 // Returns the global DirectWrite factory.
diff --git a/ui/native_theme/caption_style_win.cc b/ui/native_theme/caption_style_win.cc
index 2c27d56f29eaa..9c314a5185c7f 100644
--- a/ui/native_theme/caption_style_win.cc
+++ b/ui/native_theme/caption_style_win.cc
@@ -14,6 +14,7 @@
 #include "base/numerics/safe_conversions.h"
 #include "base/trace_event/trace_event.h"
 #include "base/win/core_winrt_util.h"
+#include "base/win/windows_version.h"
 #include "skia/ext/skia_utils_win.h"
 #include "ui/base/ui_base_features.h"
 #include "ui/gfx/color_utils.h"
@@ -172,8 +173,18 @@ std::string GetCssColorWithAlpha(CC::ClosedCaptionColor caption_color,
 
 absl::optional<CaptionStyle> InitializeFromSystemSettings() {
   TRACE_EVENT0("ui", "InitializeFromSystemSettings");
+  DCHECK_GE(base::win::GetVersion(), base::win::Version::WIN10);
   DCHECK(base::FeatureList::IsEnabled(features::kSystemCaptionStyle));
 
+  // Need to do this check before using ScopedHString.
+  bool can_use_scoped_hstring =
+      base::win::ResolveCoreWinRTDelayload() &&
+      base::win::ScopedHString::ResolveCoreWinRTStringDelayload();
+
+  if (!can_use_scoped_hstring)
+    return absl::nullopt;
+
+
   base::win::ScopedHString closed_caption_properties_string =
       base::win::ScopedHString::Create(
           RuntimeClass_Windows_Media_ClosedCaptioning_ClosedCaptionProperties);
@@ -270,10 +281,12 @@ absl::optional<CaptionStyle> InitializeFromSystemSettings() {
 }  // namespace
 
 absl::optional<CaptionStyle> CaptionStyle::FromSystemSettings() {
-  if (base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
+  if (base::win::GetVersion() >= base::win::Version::WIN10 &&
+      base::FeatureList::IsEnabled(features::kSystemCaptionStyle)) {
     return InitializeFromSystemSettings();
   }
-  // Return default CaptionStyle if kSystemCaptionStyle is not enabled.
+  // Return default CaptionStyle for pre Win10 versions since system settings
+  // don't allow caption styling.
   return absl::nullopt;
 }
 
diff --git a/ui/native_theme/native_theme.cc b/ui/native_theme/native_theme.cc
index 18722961833e4..eacaf4425e410 100644
--- a/ui/native_theme/native_theme.cc
+++ b/ui/native_theme/native_theme.cc
@@ -7,6 +7,7 @@
 #include <cstring>
 
 #include "base/command_line.h"
+#include "base/features.h"
 #include "base/containers/fixed_flat_map.h"
 #include "base/functional/bind.h"
 #include "base/logging.h"
@@ -214,7 +215,7 @@ void NativeTheme::SetPreferredContrast(
 bool NativeTheme::IsForcedDarkMode() {
   static bool kIsForcedDarkMode =
       base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kForceDarkMode);
+          switches::kForceDarkMode) || base::FeatureList::IsEnabled(base::features::kForceDarkModeFlag);
   return kIsForcedDarkMode;
 }
 
diff --git a/ui/snapshot/snapshot_win.cc b/ui/snapshot/snapshot_win.cc
index 74d600db1ea5e..d6b9e8fcadd25 100644
--- a/ui/snapshot/snapshot_win.cc
+++ b/ui/snapshot/snapshot_win.cc
@@ -5,7 +5,6 @@
 #include "ui/snapshot/snapshot_win.h"
 
 #include <memory>
-#include <utility>
 
 #include "base/functional/callback.h"
 #include "base/win/windows_version.h"
@@ -21,6 +20,17 @@
 #include "ui/snapshot/snapshot.h"
 #include "ui/snapshot/snapshot_aura.h"
 
+namespace {
+
+// Windows 8.1 is the first version that supports PW_RENDERFULLCONTENT.
+// Without that flag PrintWindow may not correctly capture what's actually
+// onscreen.
+bool UseAuraSnapshot() {
+  return (base::win::GetVersion() < base::win::Version::WIN8_1);
+}
+
+}  // namespace
+
 namespace ui {
 
 namespace internal {
@@ -29,6 +39,7 @@ bool GrabHwndSnapshot(HWND window_handle,
                       const gfx::Rect& snapshot_bounds_in_pixels,
                       const gfx::Rect& clip_rect_in_pixels,
                       gfx::Image* image) {
+  BOOL result = false;
   gfx::Rect snapshot_bounds_in_window =
       snapshot_bounds_in_pixels + clip_rect_in_pixels.OffsetFromOrigin();
   gfx::Size bitmap_size(snapshot_bounds_in_window.right(),
@@ -43,8 +54,32 @@ bool GrabHwndSnapshot(HWND window_handle,
   // but works starting in Windows 8.1. It allows for capturing the contents of
   // the window that are drawn using DirectComposition.
   UINT flags = PW_CLIENTONLY | PW_RENDERFULLCONTENT;
-
-  BOOL result = PrintWindow(window_handle, mem_hdc, flags);
+  
+  if (base::win::GetVersion() >= base::win::Version::WIN8_1){
+	result = PrintWindow(window_handle, mem_hdc, flags);
+  }
+  else {
+	// PrintWindow does not work for pre-Windows 8.1. So we'll use BitBlt.
+	// Copying from the window's actual HDC doesn't work so let's just use the full screen HDC.
+	// When a snapshot is captured the focus should be on the browser window anyway.
+	HDC window_hdc = GetDC(NULL);
+	
+	RECT window_rect;
+	
+	memset(&window_rect, 0, sizeof(RECT));
+	
+	result = GetWindowRect(window_handle, &window_rect);
+	
+	 if (!result) {
+    PLOG(ERROR) << "Failed to get valid rect for snapshot area.";
+    return false;
+    }
+	// The left of the snapshot "window" rect is offset by 8 pixels to remove a bit of the dark grey showing through.
+	result = BitBlt(mem_hdc, 0, 0, bitmap_size.width(), bitmap_size.height(), 
+					window_hdc, window_rect.left + 8, window_rect.top, SRCCOPY);
+	
+	DeleteDC(window_hdc);
+  }
   if (!result) {
     PLOG(ERROR) << "Failed to print window";
     return false;
@@ -85,6 +120,11 @@ bool GrabViewSnapshot(gfx::NativeView view_handle,
 bool GrabWindowSnapshot(gfx::NativeWindow window_handle,
                         const gfx::Rect& snapshot_bounds,
                         gfx::Image* image) {
+  if (UseAuraSnapshot()) {
+    // Not supported in Aura.  Callers should fall back to the async version.
+    return false;
+  }
+
   DCHECK(window_handle);
   gfx::Rect window_bounds = window_handle->GetBoundsInRootWindow();
   aura::WindowTreeHost* host = window_handle->GetHost();
@@ -109,6 +149,10 @@ bool GrabWindowSnapshot(gfx::NativeWindow window_handle,
 void GrabWindowSnapshotAsync(gfx::NativeWindow window,
                              const gfx::Rect& source_rect,
                              GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAsyncAura(window, source_rect, std::move(callback));
+    return;
+  }
   gfx::Image image;
   GrabWindowSnapshot(window, source_rect, &image);
   std::move(callback).Run(image);
@@ -117,6 +161,10 @@ void GrabWindowSnapshotAsync(gfx::NativeWindow window,
 void GrabViewSnapshotAsync(gfx::NativeView view,
                            const gfx::Rect& source_rect,
                            GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAsyncAura(view, source_rect, std::move(callback));
+    return;
+  }
   NOTIMPLEMENTED();
   std::move(callback).Run(gfx::Image());
 }
@@ -125,8 +173,13 @@ void GrabWindowSnapshotAndScaleAsync(gfx::NativeWindow window,
                                      const gfx::Rect& source_rect,
                                      const gfx::Size& target_size,
                                      GrabWindowSnapshotAsyncCallback callback) {
+  if (UseAuraSnapshot()) {
+    GrabWindowSnapshotAndScaleAsyncAura(window, source_rect, target_size,
+                                        std::move(callback));
+    return;
+  }
   NOTIMPLEMENTED();
   std::move(callback).Run(gfx::Image());
 }
 
-}  // namespace ui
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/views/controls/label.cc b/ui/views/controls/label.cc
index a1a17ca0f4090..c45c6e5b98b4c 100644
--- a/ui/views/controls/label.cc
+++ b/ui/views/controls/label.cc
@@ -41,6 +41,10 @@
 #include "ui/views/style/typography.h"
 #include "ui/views/style/typography_provider.h"
 
+#if BUILDFLAG(IS_WIN)
+#include "ui/gfx/win/direct_write.h"
+#endif
+
 namespace {
 
 // An enum giving different RenderText properties unique keys for the
@@ -1153,6 +1157,13 @@ void Label::Init(const std::u16string& text,
                  gfx::DirectionalityMode directionality_mode) {
   full_text_ = gfx::RenderText::CreateRenderText();
   full_text_->SetHorizontalAlignment(gfx::ALIGN_CENTER);
+  #if BUILDFLAG(IS_WIN)
+  if (!gfx::win::IsDirectWriteEnabled() && 
+  (text_context_ != style::CONTEXT_MENU && text_context_ != style::CONTEXT_DIALOG_TITLE)) {
+	  full_text_->SetVerticalAlignment(gfx::ALIGN_SPECIAL); 
+  } // The bookmark bar labels and some of the side text in the menus are CONTEXT_BUTTON.
+	// The "new tab" labels are CONTEXT_LABEL.
+  #endif
   full_text_->SetFontList(font_list);
   full_text_->SetCursorEnabled(false);
   full_text_->SetWordWrapBehavior(gfx::TRUNCATE_LONG_WORDS);
diff --git a/ui/views/controls/scrollbar/scroll_bar.cc b/ui/views/controls/scrollbar/scroll_bar.cc
index da848fcdc1784..4184e62a9d93f 100644
--- a/ui/views/controls/scrollbar/scroll_bar.cc
+++ b/ui/views/controls/scrollbar/scroll_bar.cc
@@ -438,6 +438,11 @@ void ScrollBar::TrackClicked() {
 
 void ScrollBar::ScrollContentsToOffset() {
   ScrollToPosition(contents_scroll_offset_);
+  // Safeguard against a divide-by-zero bug that happens when separating
+  // multiple tabs into separate windows.
+  contents_size_ = std::max(1, contents_size_);
+  viewport_size_ = std::max(1, viewport_size_);
+  
   thumb_->SetPosition(CalculateThumbPosition(contents_scroll_offset_));
 }
 
@@ -459,6 +464,7 @@ int ScrollBar::CalculateThumbPosition(int contents_scroll_offset) const {
   if (viewport_size_ == contents_size_) {
     return 0;
   }
+
   return (contents_scroll_offset * thumb_max) /
          (contents_size_ - viewport_size_);
 }
diff --git a/ui/views/controls/textfield/textfield.cc b/ui/views/controls/textfield/textfield.cc
index 562d300d13db4..0b72e7ba5a369 100644
--- a/ui/views/controls/textfield/textfield.cc
+++ b/ui/views/controls/textfield/textfield.cc
@@ -79,6 +79,7 @@
 
 #if BUILDFLAG(IS_WIN)
 #include "base/win/win_util.h"
+#include "ui/gfx/win/direct_write.h"
 #endif
 
 #if BUILDFLAG(IS_LINUX)
@@ -615,7 +616,13 @@ void Textfield::FitToLocalBounds() {
   } else {
     // The text will draw with the correct vertical alignment if we don't apply
     // the vertical insets.
+	#if BUILDFLAG(IS_WIN)
+    if (!gfx::win::IsDirectWriteEnabled()) {
+	  bounds.Inset(gfx::Insets::TLBR(8, insets.left(), 0, insets.right()));
+    }
+	#else
     bounds.Inset(gfx::Insets::TLBR(0, insets.left(), 0, insets.right()));
+	#endif
   }
 
   bounds.set_x(GetMirroredXForRect(bounds));
diff --git a/ui/views/win/hwnd_message_handler.cc b/ui/views/win/hwnd_message_handler.cc
index f43aa724b2a8e..8956e92107f0a 100644
--- a/ui/views/win/hwnd_message_handler.cc
+++ b/ui/views/win/hwnd_message_handler.cc
@@ -29,6 +29,8 @@
 #include "base/win/dark_mode_support.h"
 #include "base/win/scoped_gdi_object.h"
 #include "base/win/win_util.h"
+#include "base/win/windows_version.h"
+#include "chrome/browser/win/titlebar_config.h"
 #include "services/tracing/public/cpp/perfetto/macros.h"
 #include "third_party/perfetto/protos/perfetto/trace/track_event/chrome_window_handle_event_info.pbzero.h"
 #include "third_party/skia/include/core/SkPath.h"
@@ -385,7 +387,8 @@ class HWNDMessageHandler::ScopedRedrawLock {
         hwnd_(owner_->hwnd()),
         should_lock_(owner_->IsVisible() && !owner->HasChildRenderingWindow() &&
                      ::IsWindow(hwnd_) && !owner_->IsHeadless() &&
-                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION))) {
+                     (!(GetWindowLong(hwnd_, GWL_STYLE) & WS_CAPTION) ||
+					  ShouldCustomDrawSystemTitlebar())) {
     if (should_lock_)
       owner_->LockUpdates();
   }
@@ -709,7 +712,8 @@ void HWNDMessageHandler::SetBounds(const gfx::Rect& bounds_in_pixels,
 }
 
 void HWNDMessageHandler::SetDwmFrameExtension(DwmFrameState state) {
-  if (!delegate_->HasFrame() && !is_translucent_) {
+  if (!delegate_->HasFrame() && !ShouldCustomDrawSystemTitlebar() &&
+	  !is_translucent_) {
     MARGINS m = {0, 0, 0, 0};
     if (state == DwmFrameState::kOn && !IsMaximized())
       m = {0, 0, 1, 0};
@@ -2010,7 +2014,8 @@ void HWNDMessageHandler::OnEnterSizeMove() {
 
 LRESULT HWNDMessageHandler::OnEraseBkgnd(HDC dc) {
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
+  if (!ShouldCustomDrawSystemTitlebar() && 
+	  delegate_->GetDwmFrameInsetsInPixels(&insets) && !insets.IsEmpty() &&
       needs_dwm_frame_clear_) {
     // This is necessary to avoid white flashing in the titlebar area around the
     // minimize/maximize/close buttons.
@@ -2236,8 +2241,12 @@ LRESULT HWNDMessageHandler::OnMouseRange(UINT message,
 LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
                                               WPARAM w_param,
                                               LPARAM l_param) {
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
   POINTER_INPUT_TYPE pointer_type;
-  if (::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type) &&
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
+  if (get_pointer_type && get_pointer_type(pointer_id, &pointer_type) &&
       pointer_type == PT_TOUCHPAD) {
     return PA_NOACTIVATE;
   }
@@ -2245,18 +2254,24 @@ LRESULT HWNDMessageHandler::OnPointerActivate(UINT message,
   return -1;
 }
 
+
 LRESULT HWNDMessageHandler::OnPointerEvent(UINT message,
                                            WPARAM w_param,
                                            LPARAM l_param) {
+  UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerTypeFn = BOOL(WINAPI*)(UINT32, POINTER_INPUT_TYPE*);
   POINTER_INPUT_TYPE pointer_type;
+  static const auto get_pointer_type = reinterpret_cast<GetPointerTypeFn>(
+      base::win::GetUser32FunctionPointer("GetPointerType"));
   // If the WM_POINTER messages are not sent from a stylus device, then we do
   // not handle them to make sure we do not change the current behavior of
   // touch and mouse inputs.
-  if (!::GetPointerType(GET_POINTERID_WPARAM(w_param), &pointer_type)) {
+  if (!get_pointer_type || !get_pointer_type(pointer_id, &pointer_type)) {
     SetMsgHandled(FALSE);
     return -1;
   }
 
+
   // |HandlePointerEventTypePenClient| assumes all pen events happen on the
   // client area, so WM_NCPOINTER messages sent to it would eventually be
   // dropped and the native frame wouldn't be able to respond to pens.
@@ -2576,6 +2591,7 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
   // It's required to avoid some native painting artifacts from appearing when
   // the window is resized.
   if (!delegate_->HasNonClientView() || IsFrameSystemDrawn()) {
+	  if (!ShouldCustomDrawSystemTitlebar()) {
     // The default WM_NCPAINT handler under Aero Glass doesn't clear the
     // nonclient area, so it'll remain the default white color. That area is
     // invisible initially (covered by the window border) but can become
@@ -2598,6 +2614,7 @@ void HWNDMessageHandler::OnNCPaint(HRGN rgn) {
     ::FillRect(dc, &dirty_region, brush);
     ::DeleteObject(brush);
     ::ReleaseDC(hwnd(), dc);
+	}
     SetMsgHandled(FALSE);
     return;
   }
@@ -2946,6 +2963,18 @@ LRESULT HWNDMessageHandler::OnTouchEvent(UINT message,
       POINT point;
       point.x = TOUCH_COORD_TO_PIXEL(input[i].x);
       point.y = TOUCH_COORD_TO_PIXEL(input[i].y);
+	  
+	  if (base::win::GetVersion() == base::win::Version::WIN7) {
+		  // Windows 7 sends touch events for NC area touches but Win8+ do not.
+		  // This code will be used to make Windows 7 ignore these touches as well.
+		  
+		  LPARAM l_param_ht = MAKELPARAM(point.x, point.y);
+		  LRESULT hittest = SendMessage(hwnd(), WM_NCHITTEST, 0, l_param_ht);
+		  
+		  if (hittest != HTCLIENT)
+			  return 0;
+	  }
+	  
       ScreenToClient(hwnd(), &point);
 
       last_touch_or_pen_message_time_ = ::GetMessageTime();
@@ -3589,12 +3618,18 @@ LRESULT HWNDMessageHandler::HandlePointerEventTypePenClient(UINT message,
                                                             WPARAM w_param,
                                                             LPARAM l_param) {
   UINT32 pointer_id = GET_POINTERID_WPARAM(w_param);
+  using GetPointerPenInfoFn = BOOL(WINAPI*)(UINT32, POINTER_PEN_INFO*);
   POINTER_PEN_INFO pointer_pen_info;
-  if (!GetPointerPenInfo(pointer_id, &pointer_pen_info)) {
+  static const auto get_pointer_pen_info =
+      reinterpret_cast<GetPointerPenInfoFn>(
+          base::win::GetUser32FunctionPointer("GetPointerPenInfo"));
+  if (!get_pointer_pen_info ||
+      !get_pointer_pen_info(pointer_id, &pointer_pen_info)) {
     SetMsgHandled(FALSE);
     return -1;
   }
 
+
   return HandlePointerEventTypePen(message, pointer_id, pointer_pen_info);
 }
 
@@ -3620,7 +3655,6 @@ bool HWNDMessageHandler::IsSynthesizedMouseMessage(unsigned int message,
 }
 
 void HWNDMessageHandler::PerformDwmTransition() {
-  CHECK(IsFrameSystemDrawn());
 
   dwm_transition_desired_ = false;
   delegate_->HandleFrameChanged();
@@ -3631,7 +3665,8 @@ void HWNDMessageHandler::UpdateDwmFrame() {
   TRACE_EVENT0("ui", "HWNDMessageHandler::UpdateDwmFrame");
 
   gfx::Insets insets;
-  if (delegate_->GetDwmFrameInsetsInPixels(&insets)) {
+  if (!ShouldCustomDrawSystemTitlebar() &&
+      delegate_->GetDwmFrameInsetsInPixels(&insets)) {
     MARGINS margins = {insets.left(), insets.right(), insets.top(),
                        insets.bottom()};
     DwmExtendFrameIntoClientArea(hwnd(), &margins);
diff --git a/ui/views/win/pen_id_handler.cc b/ui/views/win/pen_id_handler.cc
index 96826a9c5b271..94bbc3c3c8f94 100644
--- a/ui/views/win/pen_id_handler.cc
+++ b/ui/views/win/pen_id_handler.cc
@@ -38,7 +38,15 @@ class PenIdStatics {
     if (skip_initialization_) {
       return;
     }
+
     SCOPED_MAY_LOAD_LIBRARY_AT_BACKGROUND_PRIORITY();
+
+    if(!base::win::ResolveCoreWinRTDelayload()){
+	  pen_device_statics_ = nullptr;
+	  pointer_point_statics_ = nullptr;
+	  return;
+    }
+	
     base::win::AssertComInitialized();
     base::win::RoGetActivationFactory(
         base::win::HStringReference(
@@ -245,4 +253,4 @@ void PenIdHandler::InitPenIdStatics() {
       base::BindOnce(base::IgnoreResult(&PenIdStatics::GetInstance)));
 }
 
-}  // namespace views
+}  // namespace views
\ No newline at end of file
